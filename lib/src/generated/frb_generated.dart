// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.31.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/btc_ln.dart';
import 'api/error.dart';
import 'api/lbtc_ln.dart';
import 'api/types.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.io.dart' if (dart.library.html) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class BoltzCore
    extends BaseEntrypoint<BoltzCoreApi, BoltzCoreApiImpl, BoltzCoreWire> {
  @internal
  static final instance = BoltzCore._();

  BoltzCore._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    BoltzCoreApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<BoltzCoreApiImpl, BoltzCoreWire> get apiImplConstructor =>
      BoltzCoreApiImpl.new;

  @override
  WireConstructor<BoltzCoreWire> get wireConstructor =>
      BoltzCoreWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.0.0-dev.31';

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'boltzclient',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class BoltzCoreApi extends BaseApi {
  Future<String> btcLnV1SwapClaim(
      {required BtcLnV1Swap that,
      required String outAddress,
      required int absFee,
      dynamic hint});

  Future<BtcLnV1Swap> btcLnV1SwapNew(
      {required String id,
      required SwapType kind,
      required Chain network,
      required KeyPair keys,
      required PreImage preimage,
      required String redeemScript,
      required String invoice,
      required String scriptAddress,
      required int outAmount,
      required String electrumUrl,
      required String boltzUrl,
      dynamic hint});

  Future<BtcLnV1Swap> btcLnV1SwapNewReverse(
      {required String mnemonic,
      required int index,
      required int outAmount,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      required String pairHash,
      dynamic hint});

  Future<BtcLnV1Swap> btcLnV1SwapNewSubmarine(
      {required String mnemonic,
      required int index,
      required String invoice,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      required String pairHash,
      dynamic hint});

  Future<String> btcLnV1SwapRefund(
      {required BtcLnV1Swap that,
      required String outAddress,
      required int absFee,
      dynamic hint});

  Future<int> btcLnV1SwapTxSize({required BtcLnV1Swap that, dynamic hint});

  Future<String> btcLnV2SwapClaim(
      {required BtcLnV2Swap that,
      required String outAddress,
      required int absFee,
      required bool tryCooperate,
      dynamic hint});

  Future<void> btcLnV2SwapCoopCloseSubmarine(
      {required BtcLnV2Swap that, dynamic hint});

  Future<BtcLnV2Swap> btcLnV2SwapNew(
      {required String id,
      required SwapType kind,
      required Chain network,
      required KeyPair keys,
      required PreImage preimage,
      required BtcSwapScriptV2Str swapScript,
      required String invoice,
      required String scriptAddress,
      required int outAmount,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId,
      dynamic hint});

  Future<BtcLnV2Swap> btcLnV2SwapNewReverse(
      {required String mnemonic,
      required int index,
      required int outAmount,
      String? outAddress,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId,
      dynamic hint});

  Future<BtcLnV2Swap> btcLnV2SwapNewSubmarine(
      {required String mnemonic,
      required int index,
      required String invoice,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId,
      dynamic hint});

  Future<String> btcLnV2SwapRefund(
      {required BtcLnV2Swap that,
      required String outAddress,
      required int absFee,
      required bool tryCooperate,
      dynamic hint});

  Future<int> btcLnV2SwapTxSize({required BtcLnV2Swap that, dynamic hint});

  Future<BoltzError> boltzErrorNew(
      {required String kind, required String message, dynamic hint});

  Future<String> lbtcLnV1SwapClaim(
      {required LbtcLnV1Swap that,
      required String outAddress,
      required int absFee,
      dynamic hint});

  Future<LbtcLnV1Swap> lbtcLnV1SwapNew(
      {required String id,
      required SwapType kind,
      required Chain network,
      required KeyPair keys,
      required PreImage preimage,
      required String redeemScript,
      required String invoice,
      required int outAmount,
      required String outAddress,
      required String blindingKey,
      required String electrumUrl,
      required String boltzUrl,
      dynamic hint});

  Future<LbtcLnV1Swap> lbtcLnV1SwapNewReverse(
      {required String mnemonic,
      required int index,
      required int outAmount,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      required String pairHash,
      dynamic hint});

  Future<LbtcLnV1Swap> lbtcLnV1SwapNewSubmarine(
      {required String mnemonic,
      required int index,
      required String invoice,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      required String pairHash,
      dynamic hint});

  Future<String> lbtcLnV1SwapRefund(
      {required LbtcLnV1Swap that,
      required String outAddress,
      required int absFee,
      dynamic hint});

  Future<int> lbtcLnV1SwapTxSize({required LbtcLnV1Swap swap, dynamic hint});

  Future<String> lbtcLnV2SwapBroadcastTx(
      {required LbtcLnV2Swap that,
      required List<int> signedBytes,
      dynamic hint});

  Future<String> lbtcLnV2SwapClaim(
      {required LbtcLnV2Swap that,
      required String outAddress,
      required int absFee,
      required bool tryCooperate,
      dynamic hint});

  Future<Uint8List> lbtcLnV2SwapClaimBytes(
      {required LbtcLnV2Swap that,
      required String outAddress,
      required int absFee,
      required bool tryCooperate,
      dynamic hint});

  Future<void> lbtcLnV2SwapCoopCloseSubmarine(
      {required LbtcLnV2Swap that, dynamic hint});

  Future<LbtcLnV2Swap> lbtcLnV2SwapNew(
      {required String id,
      required SwapType kind,
      required Chain network,
      required KeyPair keys,
      required PreImage preimage,
      required LBtcSwapScriptV2Str swapScript,
      required String invoice,
      required int outAmount,
      required String outAddress,
      required String blindingKey,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId,
      dynamic hint});

  Future<LbtcLnV2Swap> lbtcLnV2SwapNewReverse(
      {required String mnemonic,
      required int index,
      required int outAmount,
      String? outAddress,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId,
      dynamic hint});

  Future<LbtcLnV2Swap> lbtcLnV2SwapNewSubmarine(
      {required String mnemonic,
      required int index,
      required String invoice,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId,
      dynamic hint});

  Future<String> lbtcLnV2SwapRefund(
      {required LbtcLnV2Swap that,
      required String outAddress,
      required int absFee,
      required bool tryCooperate,
      dynamic hint});

  Future<Uint8List> lbtcLnV2SwapRefundBytes(
      {required LbtcLnV2Swap that,
      required String outAddress,
      required int absFee,
      required bool tryCooperate,
      dynamic hint});

  Future<int> lbtcLnV2SwapTxSize({required LbtcLnV2Swap that, dynamic hint});

  Future<AllFees> allFeesFetch({required String boltzUrl, dynamic hint});

  BtcSwapScriptV2Str btcSwapScriptV2StrNew(
      {required SwapType swapType,
      String? fundingAddrs,
      required String hashlock,
      required String receiverPubkey,
      required int locktime,
      required String senderPubkey,
      dynamic hint});

  Future<DecodedInvoice> decodedInvoiceFromString(
      {required String s, String? boltzUrl, dynamic hint});

  Future<KeyPair> keyPairGenerate(
      {required String mnemonic,
      required Chain network,
      required int index,
      required SwapType swapType,
      dynamic hint});

  KeyPair keyPairNew(
      {required String secretKey, required String publicKey, dynamic hint});

  LBtcSwapScriptV2Str lBtcSwapScriptV2StrNew(
      {required SwapType swapType,
      String? fundingAddrs,
      required String hashlock,
      required String receiverPubkey,
      required int locktime,
      required String senderPubkey,
      required String blindingKey,
      dynamic hint});

  Future<PreImage> preImageGenerate({dynamic hint});

  PreImage preImageNew(
      {required String value,
      required String sha256,
      required String hash160,
      dynamic hint});
}

class BoltzCoreApiImpl extends BoltzCoreApiImplPlatform
    implements BoltzCoreApi {
  BoltzCoreApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<String> btcLnV1SwapClaim(
      {required BtcLnV1Swap that,
      required String outAddress,
      required int absFee,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_btc_ln_v_1_swap(that);
        var arg1 = cst_encode_String(outAddress);
        var arg2 = cst_encode_u_64(absFee);
        return wire.wire_btc_ln_v_1_swap_claim(port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kBtcLnV1SwapClaimConstMeta,
      argValues: [that, outAddress, absFee],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBtcLnV1SwapClaimConstMeta => const TaskConstMeta(
        debugName: "btc_ln_v_1_swap_claim",
        argNames: ["that", "outAddress", "absFee"],
      );

  @override
  Future<BtcLnV1Swap> btcLnV1SwapNew(
      {required String id,
      required SwapType kind,
      required Chain network,
      required KeyPair keys,
      required PreImage preimage,
      required String redeemScript,
      required String invoice,
      required String scriptAddress,
      required int outAmount,
      required String electrumUrl,
      required String boltzUrl,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(id);
        var arg1 = cst_encode_swap_type(kind);
        var arg2 = cst_encode_chain(network);
        var arg3 = cst_encode_box_autoadd_key_pair(keys);
        var arg4 = cst_encode_box_autoadd_pre_image(preimage);
        var arg5 = cst_encode_String(redeemScript);
        var arg6 = cst_encode_String(invoice);
        var arg7 = cst_encode_String(scriptAddress);
        var arg8 = cst_encode_u_64(outAmount);
        var arg9 = cst_encode_String(electrumUrl);
        var arg10 = cst_encode_String(boltzUrl);
        return wire.wire_btc_ln_v_1_swap_new(port_, arg0, arg1, arg2, arg3,
            arg4, arg5, arg6, arg7, arg8, arg9, arg10);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_btc_ln_v_1_swap,
        decodeErrorData: null,
      ),
      constMeta: kBtcLnV1SwapNewConstMeta,
      argValues: [
        id,
        kind,
        network,
        keys,
        preimage,
        redeemScript,
        invoice,
        scriptAddress,
        outAmount,
        electrumUrl,
        boltzUrl
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBtcLnV1SwapNewConstMeta => const TaskConstMeta(
        debugName: "btc_ln_v_1_swap_new",
        argNames: [
          "id",
          "kind",
          "network",
          "keys",
          "preimage",
          "redeemScript",
          "invoice",
          "scriptAddress",
          "outAmount",
          "electrumUrl",
          "boltzUrl"
        ],
      );

  @override
  Future<BtcLnV1Swap> btcLnV1SwapNewReverse(
      {required String mnemonic,
      required int index,
      required int outAmount,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      required String pairHash,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(mnemonic);
        var arg1 = cst_encode_u_64(index);
        var arg2 = cst_encode_u_64(outAmount);
        var arg3 = cst_encode_chain(network);
        var arg4 = cst_encode_String(electrumUrl);
        var arg5 = cst_encode_String(boltzUrl);
        var arg6 = cst_encode_String(pairHash);
        return wire.wire_btc_ln_v_1_swap_new_reverse(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_btc_ln_v_1_swap,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kBtcLnV1SwapNewReverseConstMeta,
      argValues: [
        mnemonic,
        index,
        outAmount,
        network,
        electrumUrl,
        boltzUrl,
        pairHash
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBtcLnV1SwapNewReverseConstMeta => const TaskConstMeta(
        debugName: "btc_ln_v_1_swap_new_reverse",
        argNames: [
          "mnemonic",
          "index",
          "outAmount",
          "network",
          "electrumUrl",
          "boltzUrl",
          "pairHash"
        ],
      );

  @override
  Future<BtcLnV1Swap> btcLnV1SwapNewSubmarine(
      {required String mnemonic,
      required int index,
      required String invoice,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      required String pairHash,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(mnemonic);
        var arg1 = cst_encode_u_64(index);
        var arg2 = cst_encode_String(invoice);
        var arg3 = cst_encode_chain(network);
        var arg4 = cst_encode_String(electrumUrl);
        var arg5 = cst_encode_String(boltzUrl);
        var arg6 = cst_encode_String(pairHash);
        return wire.wire_btc_ln_v_1_swap_new_submarine(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_btc_ln_v_1_swap,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kBtcLnV1SwapNewSubmarineConstMeta,
      argValues: [
        mnemonic,
        index,
        invoice,
        network,
        electrumUrl,
        boltzUrl,
        pairHash
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBtcLnV1SwapNewSubmarineConstMeta => const TaskConstMeta(
        debugName: "btc_ln_v_1_swap_new_submarine",
        argNames: [
          "mnemonic",
          "index",
          "invoice",
          "network",
          "electrumUrl",
          "boltzUrl",
          "pairHash"
        ],
      );

  @override
  Future<String> btcLnV1SwapRefund(
      {required BtcLnV1Swap that,
      required String outAddress,
      required int absFee,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_btc_ln_v_1_swap(that);
        var arg1 = cst_encode_String(outAddress);
        var arg2 = cst_encode_u_64(absFee);
        return wire.wire_btc_ln_v_1_swap_refund(port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kBtcLnV1SwapRefundConstMeta,
      argValues: [that, outAddress, absFee],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBtcLnV1SwapRefundConstMeta => const TaskConstMeta(
        debugName: "btc_ln_v_1_swap_refund",
        argNames: ["that", "outAddress", "absFee"],
      );

  @override
  Future<int> btcLnV1SwapTxSize({required BtcLnV1Swap that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_btc_ln_v_1_swap(that);
        return wire.wire_btc_ln_v_1_swap_tx_size(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_usize,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kBtcLnV1SwapTxSizeConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBtcLnV1SwapTxSizeConstMeta => const TaskConstMeta(
        debugName: "btc_ln_v_1_swap_tx_size",
        argNames: ["that"],
      );

  @override
  Future<String> btcLnV2SwapClaim(
      {required BtcLnV2Swap that,
      required String outAddress,
      required int absFee,
      required bool tryCooperate,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_btc_ln_v_2_swap(that);
        var arg1 = cst_encode_String(outAddress);
        var arg2 = cst_encode_u_64(absFee);
        var arg3 = cst_encode_bool(tryCooperate);
        return wire.wire_btc_ln_v_2_swap_claim(port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kBtcLnV2SwapClaimConstMeta,
      argValues: [that, outAddress, absFee, tryCooperate],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBtcLnV2SwapClaimConstMeta => const TaskConstMeta(
        debugName: "btc_ln_v_2_swap_claim",
        argNames: ["that", "outAddress", "absFee", "tryCooperate"],
      );

  @override
  Future<void> btcLnV2SwapCoopCloseSubmarine(
      {required BtcLnV2Swap that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_btc_ln_v_2_swap(that);
        return wire.wire_btc_ln_v_2_swap_coop_close_submarine(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kBtcLnV2SwapCoopCloseSubmarineConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBtcLnV2SwapCoopCloseSubmarineConstMeta =>
      const TaskConstMeta(
        debugName: "btc_ln_v_2_swap_coop_close_submarine",
        argNames: ["that"],
      );

  @override
  Future<BtcLnV2Swap> btcLnV2SwapNew(
      {required String id,
      required SwapType kind,
      required Chain network,
      required KeyPair keys,
      required PreImage preimage,
      required BtcSwapScriptV2Str swapScript,
      required String invoice,
      required String scriptAddress,
      required int outAmount,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(id);
        var arg1 = cst_encode_swap_type(kind);
        var arg2 = cst_encode_chain(network);
        var arg3 = cst_encode_box_autoadd_key_pair(keys);
        var arg4 = cst_encode_box_autoadd_pre_image(preimage);
        var arg5 = cst_encode_box_autoadd_btc_swap_script_v_2_str(swapScript);
        var arg6 = cst_encode_String(invoice);
        var arg7 = cst_encode_String(scriptAddress);
        var arg8 = cst_encode_u_64(outAmount);
        var arg9 = cst_encode_String(electrumUrl);
        var arg10 = cst_encode_String(boltzUrl);
        var arg11 = cst_encode_opt_String(referralId);
        return wire.wire_btc_ln_v_2_swap_new(port_, arg0, arg1, arg2, arg3,
            arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_btc_ln_v_2_swap,
        decodeErrorData: null,
      ),
      constMeta: kBtcLnV2SwapNewConstMeta,
      argValues: [
        id,
        kind,
        network,
        keys,
        preimage,
        swapScript,
        invoice,
        scriptAddress,
        outAmount,
        electrumUrl,
        boltzUrl,
        referralId
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBtcLnV2SwapNewConstMeta => const TaskConstMeta(
        debugName: "btc_ln_v_2_swap_new",
        argNames: [
          "id",
          "kind",
          "network",
          "keys",
          "preimage",
          "swapScript",
          "invoice",
          "scriptAddress",
          "outAmount",
          "electrumUrl",
          "boltzUrl",
          "referralId"
        ],
      );

  @override
  Future<BtcLnV2Swap> btcLnV2SwapNewReverse(
      {required String mnemonic,
      required int index,
      required int outAmount,
      String? outAddress,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(mnemonic);
        var arg1 = cst_encode_u_64(index);
        var arg2 = cst_encode_u_64(outAmount);
        var arg3 = cst_encode_opt_String(outAddress);
        var arg4 = cst_encode_chain(network);
        var arg5 = cst_encode_String(electrumUrl);
        var arg6 = cst_encode_String(boltzUrl);
        var arg7 = cst_encode_opt_String(referralId);
        return wire.wire_btc_ln_v_2_swap_new_reverse(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_btc_ln_v_2_swap,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kBtcLnV2SwapNewReverseConstMeta,
      argValues: [
        mnemonic,
        index,
        outAmount,
        outAddress,
        network,
        electrumUrl,
        boltzUrl,
        referralId
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBtcLnV2SwapNewReverseConstMeta => const TaskConstMeta(
        debugName: "btc_ln_v_2_swap_new_reverse",
        argNames: [
          "mnemonic",
          "index",
          "outAmount",
          "outAddress",
          "network",
          "electrumUrl",
          "boltzUrl",
          "referralId"
        ],
      );

  @override
  Future<BtcLnV2Swap> btcLnV2SwapNewSubmarine(
      {required String mnemonic,
      required int index,
      required String invoice,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(mnemonic);
        var arg1 = cst_encode_u_64(index);
        var arg2 = cst_encode_String(invoice);
        var arg3 = cst_encode_chain(network);
        var arg4 = cst_encode_String(electrumUrl);
        var arg5 = cst_encode_String(boltzUrl);
        var arg6 = cst_encode_opt_String(referralId);
        return wire.wire_btc_ln_v_2_swap_new_submarine(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_btc_ln_v_2_swap,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kBtcLnV2SwapNewSubmarineConstMeta,
      argValues: [
        mnemonic,
        index,
        invoice,
        network,
        electrumUrl,
        boltzUrl,
        referralId
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBtcLnV2SwapNewSubmarineConstMeta => const TaskConstMeta(
        debugName: "btc_ln_v_2_swap_new_submarine",
        argNames: [
          "mnemonic",
          "index",
          "invoice",
          "network",
          "electrumUrl",
          "boltzUrl",
          "referralId"
        ],
      );

  @override
  Future<String> btcLnV2SwapRefund(
      {required BtcLnV2Swap that,
      required String outAddress,
      required int absFee,
      required bool tryCooperate,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_btc_ln_v_2_swap(that);
        var arg1 = cst_encode_String(outAddress);
        var arg2 = cst_encode_u_64(absFee);
        var arg3 = cst_encode_bool(tryCooperate);
        return wire.wire_btc_ln_v_2_swap_refund(port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kBtcLnV2SwapRefundConstMeta,
      argValues: [that, outAddress, absFee, tryCooperate],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBtcLnV2SwapRefundConstMeta => const TaskConstMeta(
        debugName: "btc_ln_v_2_swap_refund",
        argNames: ["that", "outAddress", "absFee", "tryCooperate"],
      );

  @override
  Future<int> btcLnV2SwapTxSize({required BtcLnV2Swap that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_btc_ln_v_2_swap(that);
        return wire.wire_btc_ln_v_2_swap_tx_size(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_usize,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kBtcLnV2SwapTxSizeConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBtcLnV2SwapTxSizeConstMeta => const TaskConstMeta(
        debugName: "btc_ln_v_2_swap_tx_size",
        argNames: ["that"],
      );

  @override
  Future<BoltzError> boltzErrorNew(
      {required String kind, required String message, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(kind);
        var arg1 = cst_encode_String(message);
        return wire.wire_boltz_error_new(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_boltz_error,
        decodeErrorData: null,
      ),
      constMeta: kBoltzErrorNewConstMeta,
      argValues: [kind, message],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBoltzErrorNewConstMeta => const TaskConstMeta(
        debugName: "boltz_error_new",
        argNames: ["kind", "message"],
      );

  @override
  Future<String> lbtcLnV1SwapClaim(
      {required LbtcLnV1Swap that,
      required String outAddress,
      required int absFee,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_lbtc_ln_v_1_swap(that);
        var arg1 = cst_encode_String(outAddress);
        var arg2 = cst_encode_u_64(absFee);
        return wire.wire_lbtc_ln_v_1_swap_claim(port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kLbtcLnV1SwapClaimConstMeta,
      argValues: [that, outAddress, absFee],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLbtcLnV1SwapClaimConstMeta => const TaskConstMeta(
        debugName: "lbtc_ln_v_1_swap_claim",
        argNames: ["that", "outAddress", "absFee"],
      );

  @override
  Future<LbtcLnV1Swap> lbtcLnV1SwapNew(
      {required String id,
      required SwapType kind,
      required Chain network,
      required KeyPair keys,
      required PreImage preimage,
      required String redeemScript,
      required String invoice,
      required int outAmount,
      required String outAddress,
      required String blindingKey,
      required String electrumUrl,
      required String boltzUrl,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(id);
        var arg1 = cst_encode_swap_type(kind);
        var arg2 = cst_encode_chain(network);
        var arg3 = cst_encode_box_autoadd_key_pair(keys);
        var arg4 = cst_encode_box_autoadd_pre_image(preimage);
        var arg5 = cst_encode_String(redeemScript);
        var arg6 = cst_encode_String(invoice);
        var arg7 = cst_encode_u_64(outAmount);
        var arg8 = cst_encode_String(outAddress);
        var arg9 = cst_encode_String(blindingKey);
        var arg10 = cst_encode_String(electrumUrl);
        var arg11 = cst_encode_String(boltzUrl);
        return wire.wire_lbtc_ln_v_1_swap_new(port_, arg0, arg1, arg2, arg3,
            arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_lbtc_ln_v_1_swap,
        decodeErrorData: null,
      ),
      constMeta: kLbtcLnV1SwapNewConstMeta,
      argValues: [
        id,
        kind,
        network,
        keys,
        preimage,
        redeemScript,
        invoice,
        outAmount,
        outAddress,
        blindingKey,
        electrumUrl,
        boltzUrl
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLbtcLnV1SwapNewConstMeta => const TaskConstMeta(
        debugName: "lbtc_ln_v_1_swap_new",
        argNames: [
          "id",
          "kind",
          "network",
          "keys",
          "preimage",
          "redeemScript",
          "invoice",
          "outAmount",
          "outAddress",
          "blindingKey",
          "electrumUrl",
          "boltzUrl"
        ],
      );

  @override
  Future<LbtcLnV1Swap> lbtcLnV1SwapNewReverse(
      {required String mnemonic,
      required int index,
      required int outAmount,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      required String pairHash,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(mnemonic);
        var arg1 = cst_encode_u_64(index);
        var arg2 = cst_encode_u_64(outAmount);
        var arg3 = cst_encode_chain(network);
        var arg4 = cst_encode_String(electrumUrl);
        var arg5 = cst_encode_String(boltzUrl);
        var arg6 = cst_encode_String(pairHash);
        return wire.wire_lbtc_ln_v_1_swap_new_reverse(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_lbtc_ln_v_1_swap,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kLbtcLnV1SwapNewReverseConstMeta,
      argValues: [
        mnemonic,
        index,
        outAmount,
        network,
        electrumUrl,
        boltzUrl,
        pairHash
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLbtcLnV1SwapNewReverseConstMeta => const TaskConstMeta(
        debugName: "lbtc_ln_v_1_swap_new_reverse",
        argNames: [
          "mnemonic",
          "index",
          "outAmount",
          "network",
          "electrumUrl",
          "boltzUrl",
          "pairHash"
        ],
      );

  @override
  Future<LbtcLnV1Swap> lbtcLnV1SwapNewSubmarine(
      {required String mnemonic,
      required int index,
      required String invoice,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      required String pairHash,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(mnemonic);
        var arg1 = cst_encode_u_64(index);
        var arg2 = cst_encode_String(invoice);
        var arg3 = cst_encode_chain(network);
        var arg4 = cst_encode_String(electrumUrl);
        var arg5 = cst_encode_String(boltzUrl);
        var arg6 = cst_encode_String(pairHash);
        return wire.wire_lbtc_ln_v_1_swap_new_submarine(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_lbtc_ln_v_1_swap,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kLbtcLnV1SwapNewSubmarineConstMeta,
      argValues: [
        mnemonic,
        index,
        invoice,
        network,
        electrumUrl,
        boltzUrl,
        pairHash
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLbtcLnV1SwapNewSubmarineConstMeta => const TaskConstMeta(
        debugName: "lbtc_ln_v_1_swap_new_submarine",
        argNames: [
          "mnemonic",
          "index",
          "invoice",
          "network",
          "electrumUrl",
          "boltzUrl",
          "pairHash"
        ],
      );

  @override
  Future<String> lbtcLnV1SwapRefund(
      {required LbtcLnV1Swap that,
      required String outAddress,
      required int absFee,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_lbtc_ln_v_1_swap(that);
        var arg1 = cst_encode_String(outAddress);
        var arg2 = cst_encode_u_64(absFee);
        return wire.wire_lbtc_ln_v_1_swap_refund(port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kLbtcLnV1SwapRefundConstMeta,
      argValues: [that, outAddress, absFee],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLbtcLnV1SwapRefundConstMeta => const TaskConstMeta(
        debugName: "lbtc_ln_v_1_swap_refund",
        argNames: ["that", "outAddress", "absFee"],
      );

  @override
  Future<int> lbtcLnV1SwapTxSize({required LbtcLnV1Swap swap, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_lbtc_ln_v_1_swap(swap);
        return wire.wire_lbtc_ln_v_1_swap_tx_size(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_usize,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kLbtcLnV1SwapTxSizeConstMeta,
      argValues: [swap],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLbtcLnV1SwapTxSizeConstMeta => const TaskConstMeta(
        debugName: "lbtc_ln_v_1_swap_tx_size",
        argNames: ["swap"],
      );

  @override
  Future<String> lbtcLnV2SwapBroadcastTx(
      {required LbtcLnV2Swap that,
      required List<int> signedBytes,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_lbtc_ln_v_2_swap(that);
        var arg1 = cst_encode_list_prim_u_8_loose(signedBytes);
        return wire.wire_lbtc_ln_v_2_swap_broadcast_tx(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kLbtcLnV2SwapBroadcastTxConstMeta,
      argValues: [that, signedBytes],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLbtcLnV2SwapBroadcastTxConstMeta => const TaskConstMeta(
        debugName: "lbtc_ln_v_2_swap_broadcast_tx",
        argNames: ["that", "signedBytes"],
      );

  @override
  Future<String> lbtcLnV2SwapClaim(
      {required LbtcLnV2Swap that,
      required String outAddress,
      required int absFee,
      required bool tryCooperate,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_lbtc_ln_v_2_swap(that);
        var arg1 = cst_encode_String(outAddress);
        var arg2 = cst_encode_u_64(absFee);
        var arg3 = cst_encode_bool(tryCooperate);
        return wire.wire_lbtc_ln_v_2_swap_claim(port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kLbtcLnV2SwapClaimConstMeta,
      argValues: [that, outAddress, absFee, tryCooperate],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLbtcLnV2SwapClaimConstMeta => const TaskConstMeta(
        debugName: "lbtc_ln_v_2_swap_claim",
        argNames: ["that", "outAddress", "absFee", "tryCooperate"],
      );

  @override
  Future<Uint8List> lbtcLnV2SwapClaimBytes(
      {required LbtcLnV2Swap that,
      required String outAddress,
      required int absFee,
      required bool tryCooperate,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_lbtc_ln_v_2_swap(that);
        var arg1 = cst_encode_String(outAddress);
        var arg2 = cst_encode_u_64(absFee);
        var arg3 = cst_encode_bool(tryCooperate);
        return wire.wire_lbtc_ln_v_2_swap_claim_bytes(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_prim_u_8_strict,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kLbtcLnV2SwapClaimBytesConstMeta,
      argValues: [that, outAddress, absFee, tryCooperate],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLbtcLnV2SwapClaimBytesConstMeta => const TaskConstMeta(
        debugName: "lbtc_ln_v_2_swap_claim_bytes",
        argNames: ["that", "outAddress", "absFee", "tryCooperate"],
      );

  @override
  Future<void> lbtcLnV2SwapCoopCloseSubmarine(
      {required LbtcLnV2Swap that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_lbtc_ln_v_2_swap(that);
        return wire.wire_lbtc_ln_v_2_swap_coop_close_submarine(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kLbtcLnV2SwapCoopCloseSubmarineConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLbtcLnV2SwapCoopCloseSubmarineConstMeta =>
      const TaskConstMeta(
        debugName: "lbtc_ln_v_2_swap_coop_close_submarine",
        argNames: ["that"],
      );

  @override
  Future<LbtcLnV2Swap> lbtcLnV2SwapNew(
      {required String id,
      required SwapType kind,
      required Chain network,
      required KeyPair keys,
      required PreImage preimage,
      required LBtcSwapScriptV2Str swapScript,
      required String invoice,
      required int outAmount,
      required String outAddress,
      required String blindingKey,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(id);
        var arg1 = cst_encode_swap_type(kind);
        var arg2 = cst_encode_chain(network);
        var arg3 = cst_encode_box_autoadd_key_pair(keys);
        var arg4 = cst_encode_box_autoadd_pre_image(preimage);
        var arg5 = cst_encode_box_autoadd_l_btc_swap_script_v_2_str(swapScript);
        var arg6 = cst_encode_String(invoice);
        var arg7 = cst_encode_u_64(outAmount);
        var arg8 = cst_encode_String(outAddress);
        var arg9 = cst_encode_String(blindingKey);
        var arg10 = cst_encode_String(electrumUrl);
        var arg11 = cst_encode_String(boltzUrl);
        var arg12 = cst_encode_opt_String(referralId);
        return wire.wire_lbtc_ln_v_2_swap_new(port_, arg0, arg1, arg2, arg3,
            arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_lbtc_ln_v_2_swap,
        decodeErrorData: null,
      ),
      constMeta: kLbtcLnV2SwapNewConstMeta,
      argValues: [
        id,
        kind,
        network,
        keys,
        preimage,
        swapScript,
        invoice,
        outAmount,
        outAddress,
        blindingKey,
        electrumUrl,
        boltzUrl,
        referralId
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLbtcLnV2SwapNewConstMeta => const TaskConstMeta(
        debugName: "lbtc_ln_v_2_swap_new",
        argNames: [
          "id",
          "kind",
          "network",
          "keys",
          "preimage",
          "swapScript",
          "invoice",
          "outAmount",
          "outAddress",
          "blindingKey",
          "electrumUrl",
          "boltzUrl",
          "referralId"
        ],
      );

  @override
  Future<LbtcLnV2Swap> lbtcLnV2SwapNewReverse(
      {required String mnemonic,
      required int index,
      required int outAmount,
      String? outAddress,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(mnemonic);
        var arg1 = cst_encode_u_64(index);
        var arg2 = cst_encode_u_64(outAmount);
        var arg3 = cst_encode_opt_String(outAddress);
        var arg4 = cst_encode_chain(network);
        var arg5 = cst_encode_String(electrumUrl);
        var arg6 = cst_encode_String(boltzUrl);
        var arg7 = cst_encode_opt_String(referralId);
        return wire.wire_lbtc_ln_v_2_swap_new_reverse(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_lbtc_ln_v_2_swap,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kLbtcLnV2SwapNewReverseConstMeta,
      argValues: [
        mnemonic,
        index,
        outAmount,
        outAddress,
        network,
        electrumUrl,
        boltzUrl,
        referralId
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLbtcLnV2SwapNewReverseConstMeta => const TaskConstMeta(
        debugName: "lbtc_ln_v_2_swap_new_reverse",
        argNames: [
          "mnemonic",
          "index",
          "outAmount",
          "outAddress",
          "network",
          "electrumUrl",
          "boltzUrl",
          "referralId"
        ],
      );

  @override
  Future<LbtcLnV2Swap> lbtcLnV2SwapNewSubmarine(
      {required String mnemonic,
      required int index,
      required String invoice,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(mnemonic);
        var arg1 = cst_encode_u_64(index);
        var arg2 = cst_encode_String(invoice);
        var arg3 = cst_encode_chain(network);
        var arg4 = cst_encode_String(electrumUrl);
        var arg5 = cst_encode_String(boltzUrl);
        var arg6 = cst_encode_opt_String(referralId);
        return wire.wire_lbtc_ln_v_2_swap_new_submarine(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_lbtc_ln_v_2_swap,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kLbtcLnV2SwapNewSubmarineConstMeta,
      argValues: [
        mnemonic,
        index,
        invoice,
        network,
        electrumUrl,
        boltzUrl,
        referralId
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLbtcLnV2SwapNewSubmarineConstMeta => const TaskConstMeta(
        debugName: "lbtc_ln_v_2_swap_new_submarine",
        argNames: [
          "mnemonic",
          "index",
          "invoice",
          "network",
          "electrumUrl",
          "boltzUrl",
          "referralId"
        ],
      );

  @override
  Future<String> lbtcLnV2SwapRefund(
      {required LbtcLnV2Swap that,
      required String outAddress,
      required int absFee,
      required bool tryCooperate,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_lbtc_ln_v_2_swap(that);
        var arg1 = cst_encode_String(outAddress);
        var arg2 = cst_encode_u_64(absFee);
        var arg3 = cst_encode_bool(tryCooperate);
        return wire.wire_lbtc_ln_v_2_swap_refund(port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kLbtcLnV2SwapRefundConstMeta,
      argValues: [that, outAddress, absFee, tryCooperate],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLbtcLnV2SwapRefundConstMeta => const TaskConstMeta(
        debugName: "lbtc_ln_v_2_swap_refund",
        argNames: ["that", "outAddress", "absFee", "tryCooperate"],
      );

  @override
  Future<Uint8List> lbtcLnV2SwapRefundBytes(
      {required LbtcLnV2Swap that,
      required String outAddress,
      required int absFee,
      required bool tryCooperate,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_lbtc_ln_v_2_swap(that);
        var arg1 = cst_encode_String(outAddress);
        var arg2 = cst_encode_u_64(absFee);
        var arg3 = cst_encode_bool(tryCooperate);
        return wire.wire_lbtc_ln_v_2_swap_refund_bytes(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_list_prim_u_8_strict,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kLbtcLnV2SwapRefundBytesConstMeta,
      argValues: [that, outAddress, absFee, tryCooperate],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLbtcLnV2SwapRefundBytesConstMeta => const TaskConstMeta(
        debugName: "lbtc_ln_v_2_swap_refund_bytes",
        argNames: ["that", "outAddress", "absFee", "tryCooperate"],
      );

  @override
  Future<int> lbtcLnV2SwapTxSize({required LbtcLnV2Swap that, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_lbtc_ln_v_2_swap(that);
        return wire.wire_lbtc_ln_v_2_swap_tx_size(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_usize,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kLbtcLnV2SwapTxSizeConstMeta,
      argValues: [that],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLbtcLnV2SwapTxSizeConstMeta => const TaskConstMeta(
        debugName: "lbtc_ln_v_2_swap_tx_size",
        argNames: ["that"],
      );

  @override
  Future<AllFees> allFeesFetch({required String boltzUrl, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(boltzUrl);
        return wire.wire_all_fees_fetch(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_all_fees,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kAllFeesFetchConstMeta,
      argValues: [boltzUrl],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kAllFeesFetchConstMeta => const TaskConstMeta(
        debugName: "all_fees_fetch",
        argNames: ["boltzUrl"],
      );

  @override
  BtcSwapScriptV2Str btcSwapScriptV2StrNew(
      {required SwapType swapType,
      String? fundingAddrs,
      required String hashlock,
      required String receiverPubkey,
      required int locktime,
      required String senderPubkey,
      dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_swap_type(swapType);
        var arg1 = cst_encode_opt_String(fundingAddrs);
        var arg2 = cst_encode_String(hashlock);
        var arg3 = cst_encode_String(receiverPubkey);
        var arg4 = cst_encode_u_32(locktime);
        var arg5 = cst_encode_String(senderPubkey);
        return wire.wire_btc_swap_script_v_2_str_new(
            arg0, arg1, arg2, arg3, arg4, arg5);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_btc_swap_script_v_2_str,
        decodeErrorData: null,
      ),
      constMeta: kBtcSwapScriptV2StrNewConstMeta,
      argValues: [
        swapType,
        fundingAddrs,
        hashlock,
        receiverPubkey,
        locktime,
        senderPubkey
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kBtcSwapScriptV2StrNewConstMeta => const TaskConstMeta(
        debugName: "btc_swap_script_v_2_str_new",
        argNames: [
          "swapType",
          "fundingAddrs",
          "hashlock",
          "receiverPubkey",
          "locktime",
          "senderPubkey"
        ],
      );

  @override
  Future<DecodedInvoice> decodedInvoiceFromString(
      {required String s, String? boltzUrl, dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(s);
        var arg1 = cst_encode_opt_String(boltzUrl);
        return wire.wire_decoded_invoice_from_string(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_decoded_invoice,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kDecodedInvoiceFromStringConstMeta,
      argValues: [s, boltzUrl],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kDecodedInvoiceFromStringConstMeta => const TaskConstMeta(
        debugName: "decoded_invoice_from_string",
        argNames: ["s", "boltzUrl"],
      );

  @override
  Future<KeyPair> keyPairGenerate(
      {required String mnemonic,
      required Chain network,
      required int index,
      required SwapType swapType,
      dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(mnemonic);
        var arg1 = cst_encode_chain(network);
        var arg2 = cst_encode_u_64(index);
        var arg3 = cst_encode_swap_type(swapType);
        return wire.wire_key_pair_generate(port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_key_pair,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kKeyPairGenerateConstMeta,
      argValues: [mnemonic, network, index, swapType],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kKeyPairGenerateConstMeta => const TaskConstMeta(
        debugName: "key_pair_generate",
        argNames: ["mnemonic", "network", "index", "swapType"],
      );

  @override
  KeyPair keyPairNew(
      {required String secretKey, required String publicKey, dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_String(secretKey);
        var arg1 = cst_encode_String(publicKey);
        return wire.wire_key_pair_new(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_key_pair,
        decodeErrorData: null,
      ),
      constMeta: kKeyPairNewConstMeta,
      argValues: [secretKey, publicKey],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kKeyPairNewConstMeta => const TaskConstMeta(
        debugName: "key_pair_new",
        argNames: ["secretKey", "publicKey"],
      );

  @override
  LBtcSwapScriptV2Str lBtcSwapScriptV2StrNew(
      {required SwapType swapType,
      String? fundingAddrs,
      required String hashlock,
      required String receiverPubkey,
      required int locktime,
      required String senderPubkey,
      required String blindingKey,
      dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_swap_type(swapType);
        var arg1 = cst_encode_opt_String(fundingAddrs);
        var arg2 = cst_encode_String(hashlock);
        var arg3 = cst_encode_String(receiverPubkey);
        var arg4 = cst_encode_u_32(locktime);
        var arg5 = cst_encode_String(senderPubkey);
        var arg6 = cst_encode_String(blindingKey);
        return wire.wire_l_btc_swap_script_v_2_str_new(
            arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_l_btc_swap_script_v_2_str,
        decodeErrorData: null,
      ),
      constMeta: kLBtcSwapScriptV2StrNewConstMeta,
      argValues: [
        swapType,
        fundingAddrs,
        hashlock,
        receiverPubkey,
        locktime,
        senderPubkey,
        blindingKey
      ],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kLBtcSwapScriptV2StrNewConstMeta => const TaskConstMeta(
        debugName: "l_btc_swap_script_v_2_str_new",
        argNames: [
          "swapType",
          "fundingAddrs",
          "hashlock",
          "receiverPubkey",
          "locktime",
          "senderPubkey",
          "blindingKey"
        ],
      );

  @override
  Future<PreImage> preImageGenerate({dynamic hint}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire_pre_image_generate(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_pre_image,
        decodeErrorData: null,
      ),
      constMeta: kPreImageGenerateConstMeta,
      argValues: [],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kPreImageGenerateConstMeta => const TaskConstMeta(
        debugName: "pre_image_generate",
        argNames: [],
      );

  @override
  PreImage preImageNew(
      {required String value,
      required String sha256,
      required String hash160,
      dynamic hint}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_String(value);
        var arg1 = cst_encode_String(sha256);
        var arg2 = cst_encode_String(hash160);
        return wire.wire_pre_image_new(arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_pre_image,
        decodeErrorData: null,
      ),
      constMeta: kPreImageNewConstMeta,
      argValues: [value, sha256, hash160],
      apiImpl: this,
      hint: hint,
    ));
  }

  TaskConstMeta get kPreImageNewConstMeta => const TaskConstMeta(
        debugName: "pre_image_new",
        argNames: ["value", "sha256", "hash160"],
      );

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AllFees dco_decode_all_fees(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return AllFees(
      btcLimits: dco_decode_limits(arr[0]),
      lbtcLimits: dco_decode_limits(arr[1]),
      btcSubmarine: dco_decode_submarine_swap_fees(arr[2]),
      btcReverse: dco_decode_reverse_swap_fees(arr[3]),
      lbtcSubmarine: dco_decode_submarine_swap_fees(arr[4]),
      lbtcReverse: dco_decode_reverse_swap_fees(arr[5]),
      btcPairHash: dco_decode_String(arr[6]),
      lbtcPairHash: dco_decode_String(arr[7]),
    );
  }

  @protected
  BoltzError dco_decode_boltz_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BoltzError(
      kind: dco_decode_String(arr[0]),
      message: dco_decode_String(arr[1]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  BtcLnV1Swap dco_decode_box_autoadd_btc_ln_v_1_swap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_btc_ln_v_1_swap(raw);
  }

  @protected
  BtcLnV2Swap dco_decode_box_autoadd_btc_ln_v_2_swap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_btc_ln_v_2_swap(raw);
  }

  @protected
  BtcSwapScriptV2Str dco_decode_box_autoadd_btc_swap_script_v_2_str(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_btc_swap_script_v_2_str(raw);
  }

  @protected
  KeyPair dco_decode_box_autoadd_key_pair(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_key_pair(raw);
  }

  @protected
  LBtcSwapScriptV2Str dco_decode_box_autoadd_l_btc_swap_script_v_2_str(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_l_btc_swap_script_v_2_str(raw);
  }

  @protected
  LbtcLnV1Swap dco_decode_box_autoadd_lbtc_ln_v_1_swap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_lbtc_ln_v_1_swap(raw);
  }

  @protected
  LbtcLnV2Swap dco_decode_box_autoadd_lbtc_ln_v_2_swap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_lbtc_ln_v_2_swap(raw);
  }

  @protected
  PreImage dco_decode_box_autoadd_pre_image(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_pre_image(raw);
  }

  @protected
  BtcLnV1Swap dco_decode_btc_ln_v_1_swap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11)
      throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return BtcLnV1Swap(
      id: dco_decode_String(arr[0]),
      kind: dco_decode_swap_type(arr[1]),
      network: dco_decode_chain(arr[2]),
      keys: dco_decode_key_pair(arr[3]),
      preimage: dco_decode_pre_image(arr[4]),
      redeemScript: dco_decode_String(arr[5]),
      invoice: dco_decode_String(arr[6]),
      scriptAddress: dco_decode_String(arr[7]),
      outAmount: dco_decode_u_64(arr[8]),
      electrumUrl: dco_decode_String(arr[9]),
      boltzUrl: dco_decode_String(arr[10]),
    );
  }

  @protected
  BtcLnV2Swap dco_decode_btc_ln_v_2_swap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12)
      throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return BtcLnV2Swap(
      id: dco_decode_String(arr[0]),
      kind: dco_decode_swap_type(arr[1]),
      network: dco_decode_chain(arr[2]),
      keys: dco_decode_key_pair(arr[3]),
      preimage: dco_decode_pre_image(arr[4]),
      swapScript: dco_decode_btc_swap_script_v_2_str(arr[5]),
      invoice: dco_decode_String(arr[6]),
      scriptAddress: dco_decode_String(arr[7]),
      outAmount: dco_decode_u_64(arr[8]),
      electrumUrl: dco_decode_String(arr[9]),
      boltzUrl: dco_decode_String(arr[10]),
      referralId: dco_decode_opt_String(arr[11]),
    );
  }

  @protected
  BtcSwapScriptV2Str dco_decode_btc_swap_script_v_2_str(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return BtcSwapScriptV2Str.raw(
      swapType: dco_decode_swap_type(arr[0]),
      fundingAddrs: dco_decode_opt_String(arr[1]),
      hashlock: dco_decode_String(arr[2]),
      receiverPubkey: dco_decode_String(arr[3]),
      locktime: dco_decode_u_32(arr[4]),
      senderPubkey: dco_decode_String(arr[5]),
    );
  }

  @protected
  Chain dco_decode_chain(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Chain.values[raw as int];
  }

  @protected
  DecodedInvoice dco_decode_decoded_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return DecodedInvoice(
      msats: dco_decode_u_64(arr[0]),
      expiry: dco_decode_u_64(arr[1]),
      expiresIn: dco_decode_u_64(arr[2]),
      expiresAt: dco_decode_u_64(arr[3]),
      isExpired: dco_decode_bool(arr[4]),
      network: dco_decode_String(arr[5]),
      cltvExpDelta: dco_decode_u_64(arr[6]),
      bip21: dco_decode_opt_String(arr[7]),
      preimageHash: dco_decode_String(arr[8]),
    );
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  KeyPair dco_decode_key_pair(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return KeyPair.raw(
      secretKey: dco_decode_String(arr[0]),
      publicKey: dco_decode_String(arr[1]),
    );
  }

  @protected
  LBtcSwapScriptV2Str dco_decode_l_btc_swap_script_v_2_str(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return LBtcSwapScriptV2Str.raw(
      swapType: dco_decode_swap_type(arr[0]),
      fundingAddrs: dco_decode_opt_String(arr[1]),
      hashlock: dco_decode_String(arr[2]),
      receiverPubkey: dco_decode_String(arr[3]),
      locktime: dco_decode_u_32(arr[4]),
      senderPubkey: dco_decode_String(arr[5]),
      blindingKey: dco_decode_String(arr[6]),
    );
  }

  @protected
  LbtcLnV1Swap dco_decode_lbtc_ln_v_1_swap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 12)
      throw Exception('unexpected arr length: expect 12 but see ${arr.length}');
    return LbtcLnV1Swap(
      id: dco_decode_String(arr[0]),
      kind: dco_decode_swap_type(arr[1]),
      network: dco_decode_chain(arr[2]),
      keys: dco_decode_key_pair(arr[3]),
      preimage: dco_decode_pre_image(arr[4]),
      redeemScript: dco_decode_String(arr[5]),
      invoice: dco_decode_String(arr[6]),
      outAmount: dco_decode_u_64(arr[7]),
      scriptAddress: dco_decode_String(arr[8]),
      blindingKey: dco_decode_String(arr[9]),
      electrumUrl: dco_decode_String(arr[10]),
      boltzUrl: dco_decode_String(arr[11]),
    );
  }

  @protected
  LbtcLnV2Swap dco_decode_lbtc_ln_v_2_swap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 13)
      throw Exception('unexpected arr length: expect 13 but see ${arr.length}');
    return LbtcLnV2Swap(
      id: dco_decode_String(arr[0]),
      kind: dco_decode_swap_type(arr[1]),
      network: dco_decode_chain(arr[2]),
      keys: dco_decode_key_pair(arr[3]),
      preimage: dco_decode_pre_image(arr[4]),
      swapScript: dco_decode_l_btc_swap_script_v_2_str(arr[5]),
      invoice: dco_decode_String(arr[6]),
      outAmount: dco_decode_u_64(arr[7]),
      scriptAddress: dco_decode_String(arr[8]),
      blindingKey: dco_decode_String(arr[9]),
      electrumUrl: dco_decode_String(arr[10]),
      boltzUrl: dco_decode_String(arr[11]),
      referralId: dco_decode_opt_String(arr[12]),
    );
  }

  @protected
  Limits dco_decode_limits(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return Limits(
      minimal: dco_decode_u_64(arr[0]),
      maximal: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  PreImage dco_decode_pre_image(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PreImage.raw(
      value: dco_decode_String(arr[0]),
      sha256: dco_decode_String(arr[1]),
      hash160: dco_decode_String(arr[2]),
    );
  }

  @protected
  ReverseSwapFees dco_decode_reverse_swap_fees(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return ReverseSwapFees(
      boltzFeesRate: dco_decode_f_64(arr[0]),
      lockupFees: dco_decode_u_64(arr[1]),
      claimFeesEstimate: dco_decode_u_64(arr[2]),
    );
  }

  @protected
  SubmarineSwapFees dco_decode_submarine_swap_fees(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return SubmarineSwapFees(
      boltzFeesRate: dco_decode_f_64(arr[0]),
      claimFees: dco_decode_u_64(arr[1]),
      lockupFeesEstimate: dco_decode_u_64(arr[2]),
    );
  }

  @protected
  SwapType dco_decode_swap_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SwapType.values[raw as int];
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  int dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64OrU64(raw);
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AllFees sse_decode_all_fees(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_btcLimits = sse_decode_limits(deserializer);
    var var_lbtcLimits = sse_decode_limits(deserializer);
    var var_btcSubmarine = sse_decode_submarine_swap_fees(deserializer);
    var var_btcReverse = sse_decode_reverse_swap_fees(deserializer);
    var var_lbtcSubmarine = sse_decode_submarine_swap_fees(deserializer);
    var var_lbtcReverse = sse_decode_reverse_swap_fees(deserializer);
    var var_btcPairHash = sse_decode_String(deserializer);
    var var_lbtcPairHash = sse_decode_String(deserializer);
    return AllFees(
        btcLimits: var_btcLimits,
        lbtcLimits: var_lbtcLimits,
        btcSubmarine: var_btcSubmarine,
        btcReverse: var_btcReverse,
        lbtcSubmarine: var_lbtcSubmarine,
        lbtcReverse: var_lbtcReverse,
        btcPairHash: var_btcPairHash,
        lbtcPairHash: var_lbtcPairHash);
  }

  @protected
  BoltzError sse_decode_boltz_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_kind = sse_decode_String(deserializer);
    var var_message = sse_decode_String(deserializer);
    return BoltzError(kind: var_kind, message: var_message);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  BtcLnV1Swap sse_decode_box_autoadd_btc_ln_v_1_swap(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_btc_ln_v_1_swap(deserializer));
  }

  @protected
  BtcLnV2Swap sse_decode_box_autoadd_btc_ln_v_2_swap(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_btc_ln_v_2_swap(deserializer));
  }

  @protected
  BtcSwapScriptV2Str sse_decode_box_autoadd_btc_swap_script_v_2_str(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_btc_swap_script_v_2_str(deserializer));
  }

  @protected
  KeyPair sse_decode_box_autoadd_key_pair(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_key_pair(deserializer));
  }

  @protected
  LBtcSwapScriptV2Str sse_decode_box_autoadd_l_btc_swap_script_v_2_str(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_l_btc_swap_script_v_2_str(deserializer));
  }

  @protected
  LbtcLnV1Swap sse_decode_box_autoadd_lbtc_ln_v_1_swap(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_lbtc_ln_v_1_swap(deserializer));
  }

  @protected
  LbtcLnV2Swap sse_decode_box_autoadd_lbtc_ln_v_2_swap(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_lbtc_ln_v_2_swap(deserializer));
  }

  @protected
  PreImage sse_decode_box_autoadd_pre_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_pre_image(deserializer));
  }

  @protected
  BtcLnV1Swap sse_decode_btc_ln_v_1_swap(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_kind = sse_decode_swap_type(deserializer);
    var var_network = sse_decode_chain(deserializer);
    var var_keys = sse_decode_key_pair(deserializer);
    var var_preimage = sse_decode_pre_image(deserializer);
    var var_redeemScript = sse_decode_String(deserializer);
    var var_invoice = sse_decode_String(deserializer);
    var var_scriptAddress = sse_decode_String(deserializer);
    var var_outAmount = sse_decode_u_64(deserializer);
    var var_electrumUrl = sse_decode_String(deserializer);
    var var_boltzUrl = sse_decode_String(deserializer);
    return BtcLnV1Swap(
        id: var_id,
        kind: var_kind,
        network: var_network,
        keys: var_keys,
        preimage: var_preimage,
        redeemScript: var_redeemScript,
        invoice: var_invoice,
        scriptAddress: var_scriptAddress,
        outAmount: var_outAmount,
        electrumUrl: var_electrumUrl,
        boltzUrl: var_boltzUrl);
  }

  @protected
  BtcLnV2Swap sse_decode_btc_ln_v_2_swap(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_kind = sse_decode_swap_type(deserializer);
    var var_network = sse_decode_chain(deserializer);
    var var_keys = sse_decode_key_pair(deserializer);
    var var_preimage = sse_decode_pre_image(deserializer);
    var var_swapScript = sse_decode_btc_swap_script_v_2_str(deserializer);
    var var_invoice = sse_decode_String(deserializer);
    var var_scriptAddress = sse_decode_String(deserializer);
    var var_outAmount = sse_decode_u_64(deserializer);
    var var_electrumUrl = sse_decode_String(deserializer);
    var var_boltzUrl = sse_decode_String(deserializer);
    var var_referralId = sse_decode_opt_String(deserializer);
    return BtcLnV2Swap(
        id: var_id,
        kind: var_kind,
        network: var_network,
        keys: var_keys,
        preimage: var_preimage,
        swapScript: var_swapScript,
        invoice: var_invoice,
        scriptAddress: var_scriptAddress,
        outAmount: var_outAmount,
        electrumUrl: var_electrumUrl,
        boltzUrl: var_boltzUrl,
        referralId: var_referralId);
  }

  @protected
  BtcSwapScriptV2Str sse_decode_btc_swap_script_v_2_str(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_swapType = sse_decode_swap_type(deserializer);
    var var_fundingAddrs = sse_decode_opt_String(deserializer);
    var var_hashlock = sse_decode_String(deserializer);
    var var_receiverPubkey = sse_decode_String(deserializer);
    var var_locktime = sse_decode_u_32(deserializer);
    var var_senderPubkey = sse_decode_String(deserializer);
    return BtcSwapScriptV2Str.raw(
        swapType: var_swapType,
        fundingAddrs: var_fundingAddrs,
        hashlock: var_hashlock,
        receiverPubkey: var_receiverPubkey,
        locktime: var_locktime,
        senderPubkey: var_senderPubkey);
  }

  @protected
  Chain sse_decode_chain(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Chain.values[inner];
  }

  @protected
  DecodedInvoice sse_decode_decoded_invoice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_msats = sse_decode_u_64(deserializer);
    var var_expiry = sse_decode_u_64(deserializer);
    var var_expiresIn = sse_decode_u_64(deserializer);
    var var_expiresAt = sse_decode_u_64(deserializer);
    var var_isExpired = sse_decode_bool(deserializer);
    var var_network = sse_decode_String(deserializer);
    var var_cltvExpDelta = sse_decode_u_64(deserializer);
    var var_bip21 = sse_decode_opt_String(deserializer);
    var var_preimageHash = sse_decode_String(deserializer);
    return DecodedInvoice(
        msats: var_msats,
        expiry: var_expiry,
        expiresIn: var_expiresIn,
        expiresAt: var_expiresAt,
        isExpired: var_isExpired,
        network: var_network,
        cltvExpDelta: var_cltvExpDelta,
        bip21: var_bip21,
        preimageHash: var_preimageHash);
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  KeyPair sse_decode_key_pair(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_secretKey = sse_decode_String(deserializer);
    var var_publicKey = sse_decode_String(deserializer);
    return KeyPair.raw(secretKey: var_secretKey, publicKey: var_publicKey);
  }

  @protected
  LBtcSwapScriptV2Str sse_decode_l_btc_swap_script_v_2_str(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_swapType = sse_decode_swap_type(deserializer);
    var var_fundingAddrs = sse_decode_opt_String(deserializer);
    var var_hashlock = sse_decode_String(deserializer);
    var var_receiverPubkey = sse_decode_String(deserializer);
    var var_locktime = sse_decode_u_32(deserializer);
    var var_senderPubkey = sse_decode_String(deserializer);
    var var_blindingKey = sse_decode_String(deserializer);
    return LBtcSwapScriptV2Str.raw(
        swapType: var_swapType,
        fundingAddrs: var_fundingAddrs,
        hashlock: var_hashlock,
        receiverPubkey: var_receiverPubkey,
        locktime: var_locktime,
        senderPubkey: var_senderPubkey,
        blindingKey: var_blindingKey);
  }

  @protected
  LbtcLnV1Swap sse_decode_lbtc_ln_v_1_swap(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_kind = sse_decode_swap_type(deserializer);
    var var_network = sse_decode_chain(deserializer);
    var var_keys = sse_decode_key_pair(deserializer);
    var var_preimage = sse_decode_pre_image(deserializer);
    var var_redeemScript = sse_decode_String(deserializer);
    var var_invoice = sse_decode_String(deserializer);
    var var_outAmount = sse_decode_u_64(deserializer);
    var var_scriptAddress = sse_decode_String(deserializer);
    var var_blindingKey = sse_decode_String(deserializer);
    var var_electrumUrl = sse_decode_String(deserializer);
    var var_boltzUrl = sse_decode_String(deserializer);
    return LbtcLnV1Swap(
        id: var_id,
        kind: var_kind,
        network: var_network,
        keys: var_keys,
        preimage: var_preimage,
        redeemScript: var_redeemScript,
        invoice: var_invoice,
        outAmount: var_outAmount,
        scriptAddress: var_scriptAddress,
        blindingKey: var_blindingKey,
        electrumUrl: var_electrumUrl,
        boltzUrl: var_boltzUrl);
  }

  @protected
  LbtcLnV2Swap sse_decode_lbtc_ln_v_2_swap(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_kind = sse_decode_swap_type(deserializer);
    var var_network = sse_decode_chain(deserializer);
    var var_keys = sse_decode_key_pair(deserializer);
    var var_preimage = sse_decode_pre_image(deserializer);
    var var_swapScript = sse_decode_l_btc_swap_script_v_2_str(deserializer);
    var var_invoice = sse_decode_String(deserializer);
    var var_outAmount = sse_decode_u_64(deserializer);
    var var_scriptAddress = sse_decode_String(deserializer);
    var var_blindingKey = sse_decode_String(deserializer);
    var var_electrumUrl = sse_decode_String(deserializer);
    var var_boltzUrl = sse_decode_String(deserializer);
    var var_referralId = sse_decode_opt_String(deserializer);
    return LbtcLnV2Swap(
        id: var_id,
        kind: var_kind,
        network: var_network,
        keys: var_keys,
        preimage: var_preimage,
        swapScript: var_swapScript,
        invoice: var_invoice,
        outAmount: var_outAmount,
        scriptAddress: var_scriptAddress,
        blindingKey: var_blindingKey,
        electrumUrl: var_electrumUrl,
        boltzUrl: var_boltzUrl,
        referralId: var_referralId);
  }

  @protected
  Limits sse_decode_limits(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_minimal = sse_decode_u_64(deserializer);
    var var_maximal = sse_decode_u_64(deserializer);
    return Limits(minimal: var_minimal, maximal: var_maximal);
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PreImage sse_decode_pre_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_value = sse_decode_String(deserializer);
    var var_sha256 = sse_decode_String(deserializer);
    var var_hash160 = sse_decode_String(deserializer);
    return PreImage.raw(
        value: var_value, sha256: var_sha256, hash160: var_hash160);
  }

  @protected
  ReverseSwapFees sse_decode_reverse_swap_fees(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_boltzFeesRate = sse_decode_f_64(deserializer);
    var var_lockupFees = sse_decode_u_64(deserializer);
    var var_claimFeesEstimate = sse_decode_u_64(deserializer);
    return ReverseSwapFees(
        boltzFeesRate: var_boltzFeesRate,
        lockupFees: var_lockupFees,
        claimFeesEstimate: var_claimFeesEstimate);
  }

  @protected
  SubmarineSwapFees sse_decode_submarine_swap_fees(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_boltzFeesRate = sse_decode_f_64(deserializer);
    var var_claimFees = sse_decode_u_64(deserializer);
    var var_lockupFeesEstimate = sse_decode_u_64(deserializer);
    return SubmarineSwapFees(
        boltzFeesRate: var_boltzFeesRate,
        claimFees: var_claimFees,
        lockupFeesEstimate: var_lockupFeesEstimate);
  }

  @protected
  SwapType sse_decode_swap_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return SwapType.values[inner];
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  int sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  int sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint64();
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_chain(Chain raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  double cst_encode_f_64(double raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_swap_type(SwapType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_usize(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_all_fees(AllFees self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_limits(self.btcLimits, serializer);
    sse_encode_limits(self.lbtcLimits, serializer);
    sse_encode_submarine_swap_fees(self.btcSubmarine, serializer);
    sse_encode_reverse_swap_fees(self.btcReverse, serializer);
    sse_encode_submarine_swap_fees(self.lbtcSubmarine, serializer);
    sse_encode_reverse_swap_fees(self.lbtcReverse, serializer);
    sse_encode_String(self.btcPairHash, serializer);
    sse_encode_String(self.lbtcPairHash, serializer);
  }

  @protected
  void sse_encode_boltz_error(BoltzError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.kind, serializer);
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_btc_ln_v_1_swap(
      BtcLnV1Swap self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_btc_ln_v_1_swap(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_btc_ln_v_2_swap(
      BtcLnV2Swap self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_btc_ln_v_2_swap(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_btc_swap_script_v_2_str(
      BtcSwapScriptV2Str self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_btc_swap_script_v_2_str(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_key_pair(KeyPair self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_key_pair(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_l_btc_swap_script_v_2_str(
      LBtcSwapScriptV2Str self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_l_btc_swap_script_v_2_str(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_lbtc_ln_v_1_swap(
      LbtcLnV1Swap self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_lbtc_ln_v_1_swap(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_lbtc_ln_v_2_swap(
      LbtcLnV2Swap self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_lbtc_ln_v_2_swap(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_pre_image(
      PreImage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_pre_image(self, serializer);
  }

  @protected
  void sse_encode_btc_ln_v_1_swap(BtcLnV1Swap self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_swap_type(self.kind, serializer);
    sse_encode_chain(self.network, serializer);
    sse_encode_key_pair(self.keys, serializer);
    sse_encode_pre_image(self.preimage, serializer);
    sse_encode_String(self.redeemScript, serializer);
    sse_encode_String(self.invoice, serializer);
    sse_encode_String(self.scriptAddress, serializer);
    sse_encode_u_64(self.outAmount, serializer);
    sse_encode_String(self.electrumUrl, serializer);
    sse_encode_String(self.boltzUrl, serializer);
  }

  @protected
  void sse_encode_btc_ln_v_2_swap(BtcLnV2Swap self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_swap_type(self.kind, serializer);
    sse_encode_chain(self.network, serializer);
    sse_encode_key_pair(self.keys, serializer);
    sse_encode_pre_image(self.preimage, serializer);
    sse_encode_btc_swap_script_v_2_str(self.swapScript, serializer);
    sse_encode_String(self.invoice, serializer);
    sse_encode_String(self.scriptAddress, serializer);
    sse_encode_u_64(self.outAmount, serializer);
    sse_encode_String(self.electrumUrl, serializer);
    sse_encode_String(self.boltzUrl, serializer);
    sse_encode_opt_String(self.referralId, serializer);
  }

  @protected
  void sse_encode_btc_swap_script_v_2_str(
      BtcSwapScriptV2Str self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_swap_type(self.swapType, serializer);
    sse_encode_opt_String(self.fundingAddrs, serializer);
    sse_encode_String(self.hashlock, serializer);
    sse_encode_String(self.receiverPubkey, serializer);
    sse_encode_u_32(self.locktime, serializer);
    sse_encode_String(self.senderPubkey, serializer);
  }

  @protected
  void sse_encode_chain(Chain self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_decoded_invoice(
      DecodedInvoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.msats, serializer);
    sse_encode_u_64(self.expiry, serializer);
    sse_encode_u_64(self.expiresIn, serializer);
    sse_encode_u_64(self.expiresAt, serializer);
    sse_encode_bool(self.isExpired, serializer);
    sse_encode_String(self.network, serializer);
    sse_encode_u_64(self.cltvExpDelta, serializer);
    sse_encode_opt_String(self.bip21, serializer);
    sse_encode_String(self.preimageHash, serializer);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_key_pair(KeyPair self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.secretKey, serializer);
    sse_encode_String(self.publicKey, serializer);
  }

  @protected
  void sse_encode_l_btc_swap_script_v_2_str(
      LBtcSwapScriptV2Str self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_swap_type(self.swapType, serializer);
    sse_encode_opt_String(self.fundingAddrs, serializer);
    sse_encode_String(self.hashlock, serializer);
    sse_encode_String(self.receiverPubkey, serializer);
    sse_encode_u_32(self.locktime, serializer);
    sse_encode_String(self.senderPubkey, serializer);
    sse_encode_String(self.blindingKey, serializer);
  }

  @protected
  void sse_encode_lbtc_ln_v_1_swap(
      LbtcLnV1Swap self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_swap_type(self.kind, serializer);
    sse_encode_chain(self.network, serializer);
    sse_encode_key_pair(self.keys, serializer);
    sse_encode_pre_image(self.preimage, serializer);
    sse_encode_String(self.redeemScript, serializer);
    sse_encode_String(self.invoice, serializer);
    sse_encode_u_64(self.outAmount, serializer);
    sse_encode_String(self.scriptAddress, serializer);
    sse_encode_String(self.blindingKey, serializer);
    sse_encode_String(self.electrumUrl, serializer);
    sse_encode_String(self.boltzUrl, serializer);
  }

  @protected
  void sse_encode_lbtc_ln_v_2_swap(
      LbtcLnV2Swap self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_swap_type(self.kind, serializer);
    sse_encode_chain(self.network, serializer);
    sse_encode_key_pair(self.keys, serializer);
    sse_encode_pre_image(self.preimage, serializer);
    sse_encode_l_btc_swap_script_v_2_str(self.swapScript, serializer);
    sse_encode_String(self.invoice, serializer);
    sse_encode_u_64(self.outAmount, serializer);
    sse_encode_String(self.scriptAddress, serializer);
    sse_encode_String(self.blindingKey, serializer);
    sse_encode_String(self.electrumUrl, serializer);
    sse_encode_String(self.boltzUrl, serializer);
    sse_encode_opt_String(self.referralId, serializer);
  }

  @protected
  void sse_encode_limits(Limits self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.minimal, serializer);
    sse_encode_u_64(self.maximal, serializer);
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_pre_image(PreImage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.value, serializer);
    sse_encode_String(self.sha256, serializer);
    sse_encode_String(self.hash160, serializer);
  }

  @protected
  void sse_encode_reverse_swap_fees(
      ReverseSwapFees self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self.boltzFeesRate, serializer);
    sse_encode_u_64(self.lockupFees, serializer);
    sse_encode_u_64(self.claimFeesEstimate, serializer);
  }

  @protected
  void sse_encode_submarine_swap_fees(
      SubmarineSwapFees self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self.boltzFeesRate, serializer);
    sse_encode_u_64(self.claimFees, serializer);
    sse_encode_u_64(self.lockupFeesEstimate, serializer);
  }

  @protected
  void sse_encode_swap_type(SwapType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint64(self);
  }
}
