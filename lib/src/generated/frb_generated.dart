// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/btc_ln.dart';
import 'api/chain_swap.dart';
import 'api/error.dart';
import 'api/fees.dart';
import 'api/lbtc_ln.dart';
import 'api/types.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class BoltzCore
    extends BaseEntrypoint<BoltzCoreApi, BoltzCoreApiImpl, BoltzCoreWire> {
  @internal
  static final instance = BoltzCore._();

  BoltzCore._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    BoltzCoreApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<BoltzCoreApiImpl, BoltzCoreWire> get apiImplConstructor =>
      BoltzCoreApiImpl.new;

  @override
  WireConstructor<BoltzCoreWire> get wireConstructor =>
      BoltzCoreWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.0.0';

  @override
  int get rustContentHash => 165180085;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'boltz_dart',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class BoltzCoreApi extends BaseApi {
  Future<String> crateApiBtcLnBtcLnSwapBroadcastBoltz(
      {required BtcLnSwap that, required String signedHex});

  Future<String> crateApiBtcLnBtcLnSwapBroadcastLocal(
      {required BtcLnSwap that, required String signedHex});

  Future<String> crateApiBtcLnBtcLnSwapClaim(
      {required BtcLnSwap that,
      required String outAddress,
      required BigInt absFee,
      required bool tryCooperate});

  Future<void> crateApiBtcLnBtcLnSwapCoopCloseSubmarine(
      {required BtcLnSwap that});

  Future<BtcLnSwap> crateApiBtcLnBtcLnSwapNew(
      {required String id,
      required SwapType kind,
      required Chain network,
      required KeyPair keys,
      required BigInt keyIndex,
      required PreImage preimage,
      required BtcSwapScriptStr swapScript,
      required String invoice,
      required String scriptAddress,
      required BigInt outAmount,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId});

  Future<BtcLnSwap> crateApiBtcLnBtcLnSwapNewReverse(
      {required String mnemonic,
      required BigInt index,
      required BigInt outAmount,
      String? outAddress,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      String? description,
      String? referralId});

  Future<BtcLnSwap> crateApiBtcLnBtcLnSwapNewSubmarine(
      {required String mnemonic,
      required BigInt index,
      required String invoice,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId});

  Future<String> crateApiBtcLnBtcLnSwapRefund(
      {required BtcLnSwap that,
      required String outAddress,
      required BigInt absFee,
      required bool tryCooperate});

  Future<BigInt> crateApiBtcLnBtcLnSwapTxSize({required BtcLnSwap that});

  Future<String> crateApiChainSwapChainSwapBroadcastBoltz(
      {required ChainSwap that,
      required String signedHex,
      required SwapTxKind kind});

  Future<String> crateApiChainSwapChainSwapBroadcastLocal(
      {required ChainSwap that,
      required String signedHex,
      required SwapTxKind kind});

  Future<String> crateApiChainSwapChainSwapClaim(
      {required ChainSwap that,
      required String outAddress,
      required String refundAddress,
      required BigInt absFee,
      required bool tryCooperate});

  Future<String> crateApiChainSwapChainSwapGetServerLockup(
      {required ChainSwap that});

  Future<String> crateApiChainSwapChainSwapGetUserLockup(
      {required ChainSwap that});

  Future<ChainSwap> crateApiChainSwapChainSwapNew(
      {required String id,
      required bool isTestnet,
      required ChainSwapDirection direction,
      required KeyPair refundKeys,
      required BigInt refundIndex,
      required KeyPair claimKeys,
      required BigInt claimIndex,
      required PreImage preimage,
      required BtcSwapScriptStr btcScriptStr,
      required LBtcSwapScriptStr lbtcScriptStr,
      required String scriptAddress,
      required BigInt outAmount,
      required String btcElectrumUrl,
      required String lbtcElectrumUrl,
      required String boltzUrl,
      String? referralId,
      required String blindingKey});

  Future<ChainSwap> crateApiChainSwapChainSwapNewSwap(
      {required ChainSwapDirection direction,
      required String mnemonic,
      required BigInt index,
      required BigInt amount,
      required bool isTestnet,
      required String btcElectrumUrl,
      required String lbtcElectrumUrl,
      required String boltzUrl,
      String? referralId});

  Future<String> crateApiChainSwapChainSwapRefund(
      {required ChainSwap that,
      required String refundAddress,
      required BigInt absFee,
      required bool tryCooperate});

  Future<BoltzError> crateApiErrorBoltzErrorNew(
      {required String kind, required String message});

  Future<ChainFeesAndLimits> crateApiFeesFeesChain({required Fees that});

  Future<Fees> crateApiFeesFeesNew({required String boltzUrl});

  Future<ReverseFeesAndLimits> crateApiFeesFeesReverse({required Fees that});

  Future<SubmarineFeesAndLimits> crateApiFeesFeesSubmarine(
      {required Fees that});

  Future<String> crateApiLbtcLnLbtcLnSwapBroadcastBoltz(
      {required LbtcLnSwap that, required String signedHex});

  Future<String> crateApiLbtcLnLbtcLnSwapBroadcastLocal(
      {required LbtcLnSwap that, required String signedHex});

  Future<String> crateApiLbtcLnLbtcLnSwapClaim(
      {required LbtcLnSwap that,
      required String outAddress,
      required BigInt absFee,
      required bool tryCooperate});

  Future<void> crateApiLbtcLnLbtcLnSwapCoopCloseSubmarine(
      {required LbtcLnSwap that});

  Future<LbtcLnSwap> crateApiLbtcLnLbtcLnSwapNew(
      {required String id,
      required SwapType kind,
      required Chain network,
      required KeyPair keys,
      required BigInt keyIndex,
      required PreImage preimage,
      required LBtcSwapScriptStr swapScript,
      required String invoice,
      required BigInt outAmount,
      required String outAddress,
      required String blindingKey,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId});

  Future<LbtcLnSwap> crateApiLbtcLnLbtcLnSwapNewReverse(
      {required String mnemonic,
      required BigInt index,
      required BigInt outAmount,
      String? outAddress,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      String? description,
      String? referralId});

  Future<LbtcLnSwap> crateApiLbtcLnLbtcLnSwapNewSubmarine(
      {required String mnemonic,
      required BigInt index,
      required String invoice,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId});

  Future<String> crateApiLbtcLnLbtcLnSwapRefund(
      {required LbtcLnSwap that,
      required String outAddress,
      required BigInt absFee,
      required bool tryCooperate});

  Future<BigInt> crateApiLbtcLnLbtcLnSwapTxSize({required LbtcLnSwap that});

  BtcSwapScriptStr crateApiTypesBtcSwapScriptStrNew(
      {required SwapType swapType,
      String? fundingAddrs,
      required String hashlock,
      required String receiverPubkey,
      required int locktime,
      required String senderPubkey,
      Side? side});

  Future<DecodedInvoice> crateApiTypesDecodedInvoiceFromString(
      {required String s, String? boltzUrl});

  Future<BigInt> crateApiTypesGetVoucherMaxAmount({required String lnurl});

  Future<String> crateApiTypesInvoiceFromLnurl(
      {required String lnurl, required BigInt msats});

  Future<KeyPair> crateApiTypesKeyPairGenerate(
      {required String mnemonic,
      required Chain network,
      required BigInt index,
      required SwapType swapType});

  KeyPair crateApiTypesKeyPairNew(
      {required String secretKey, required String publicKey});

  LBtcSwapScriptStr crateApiTypesLBtcSwapScriptStrNew(
      {required SwapType swapType,
      String? fundingAddrs,
      required String hashlock,
      required String receiverPubkey,
      required int locktime,
      required String senderPubkey,
      required String blindingKey,
      Side? side});

  Future<PreImage> crateApiTypesPreImageGenerate();

  PreImage crateApiTypesPreImageNew(
      {required String value, required String sha256, required String hash160});

  Future<bool> crateApiTypesValidateLnurl({required String lnurl});

  Future<void> crateApiTypesWithdraw(
      {required String lnurl, required String invoice});
}

class BoltzCoreApiImpl extends BoltzCoreApiImplPlatform
    implements BoltzCoreApi {
  BoltzCoreApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<String> crateApiBtcLnBtcLnSwapBroadcastBoltz(
      {required BtcLnSwap that, required String signedHex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_btc_ln_swap(that);
        var arg1 = cst_encode_String(signedHex);
        return wire.wire__crate__api__btc_ln__btc_ln_swap_broadcast_boltz(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiBtcLnBtcLnSwapBroadcastBoltzConstMeta,
      argValues: [that, signedHex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBtcLnBtcLnSwapBroadcastBoltzConstMeta =>
      const TaskConstMeta(
        debugName: "btc_ln_swap_broadcast_boltz",
        argNames: ["that", "signedHex"],
      );

  @override
  Future<String> crateApiBtcLnBtcLnSwapBroadcastLocal(
      {required BtcLnSwap that, required String signedHex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_btc_ln_swap(that);
        var arg1 = cst_encode_String(signedHex);
        return wire.wire__crate__api__btc_ln__btc_ln_swap_broadcast_local(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiBtcLnBtcLnSwapBroadcastLocalConstMeta,
      argValues: [that, signedHex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBtcLnBtcLnSwapBroadcastLocalConstMeta =>
      const TaskConstMeta(
        debugName: "btc_ln_swap_broadcast_local",
        argNames: ["that", "signedHex"],
      );

  @override
  Future<String> crateApiBtcLnBtcLnSwapClaim(
      {required BtcLnSwap that,
      required String outAddress,
      required BigInt absFee,
      required bool tryCooperate}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_btc_ln_swap(that);
        var arg1 = cst_encode_String(outAddress);
        var arg2 = cst_encode_u_64(absFee);
        var arg3 = cst_encode_bool(tryCooperate);
        return wire.wire__crate__api__btc_ln__btc_ln_swap_claim(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiBtcLnBtcLnSwapClaimConstMeta,
      argValues: [that, outAddress, absFee, tryCooperate],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBtcLnBtcLnSwapClaimConstMeta =>
      const TaskConstMeta(
        debugName: "btc_ln_swap_claim",
        argNames: ["that", "outAddress", "absFee", "tryCooperate"],
      );

  @override
  Future<void> crateApiBtcLnBtcLnSwapCoopCloseSubmarine(
      {required BtcLnSwap that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_btc_ln_swap(that);
        return wire.wire__crate__api__btc_ln__btc_ln_swap_coop_close_submarine(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiBtcLnBtcLnSwapCoopCloseSubmarineConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBtcLnBtcLnSwapCoopCloseSubmarineConstMeta =>
      const TaskConstMeta(
        debugName: "btc_ln_swap_coop_close_submarine",
        argNames: ["that"],
      );

  @override
  Future<BtcLnSwap> crateApiBtcLnBtcLnSwapNew(
      {required String id,
      required SwapType kind,
      required Chain network,
      required KeyPair keys,
      required BigInt keyIndex,
      required PreImage preimage,
      required BtcSwapScriptStr swapScript,
      required String invoice,
      required String scriptAddress,
      required BigInt outAmount,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(id);
        var arg1 = cst_encode_swap_type(kind);
        var arg2 = cst_encode_chain(network);
        var arg3 = cst_encode_box_autoadd_key_pair(keys);
        var arg4 = cst_encode_u_64(keyIndex);
        var arg5 = cst_encode_box_autoadd_pre_image(preimage);
        var arg6 = cst_encode_box_autoadd_btc_swap_script_str(swapScript);
        var arg7 = cst_encode_String(invoice);
        var arg8 = cst_encode_String(scriptAddress);
        var arg9 = cst_encode_u_64(outAmount);
        var arg10 = cst_encode_String(electrumUrl);
        var arg11 = cst_encode_String(boltzUrl);
        var arg12 = cst_encode_opt_String(referralId);
        return wire.wire__crate__api__btc_ln__btc_ln_swap_new(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
            arg7,
            arg8,
            arg9,
            arg10,
            arg11,
            arg12);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_btc_ln_swap,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiBtcLnBtcLnSwapNewConstMeta,
      argValues: [
        id,
        kind,
        network,
        keys,
        keyIndex,
        preimage,
        swapScript,
        invoice,
        scriptAddress,
        outAmount,
        electrumUrl,
        boltzUrl,
        referralId
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBtcLnBtcLnSwapNewConstMeta => const TaskConstMeta(
        debugName: "btc_ln_swap_new",
        argNames: [
          "id",
          "kind",
          "network",
          "keys",
          "keyIndex",
          "preimage",
          "swapScript",
          "invoice",
          "scriptAddress",
          "outAmount",
          "electrumUrl",
          "boltzUrl",
          "referralId"
        ],
      );

  @override
  Future<BtcLnSwap> crateApiBtcLnBtcLnSwapNewReverse(
      {required String mnemonic,
      required BigInt index,
      required BigInt outAmount,
      String? outAddress,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      String? description,
      String? referralId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(mnemonic);
        var arg1 = cst_encode_u_64(index);
        var arg2 = cst_encode_u_64(outAmount);
        var arg3 = cst_encode_opt_String(outAddress);
        var arg4 = cst_encode_chain(network);
        var arg5 = cst_encode_String(electrumUrl);
        var arg6 = cst_encode_String(boltzUrl);
        var arg7 = cst_encode_opt_String(description);
        var arg8 = cst_encode_opt_String(referralId);
        return wire.wire__crate__api__btc_ln__btc_ln_swap_new_reverse(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_btc_ln_swap,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiBtcLnBtcLnSwapNewReverseConstMeta,
      argValues: [
        mnemonic,
        index,
        outAmount,
        outAddress,
        network,
        electrumUrl,
        boltzUrl,
        description,
        referralId
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBtcLnBtcLnSwapNewReverseConstMeta =>
      const TaskConstMeta(
        debugName: "btc_ln_swap_new_reverse",
        argNames: [
          "mnemonic",
          "index",
          "outAmount",
          "outAddress",
          "network",
          "electrumUrl",
          "boltzUrl",
          "description",
          "referralId"
        ],
      );

  @override
  Future<BtcLnSwap> crateApiBtcLnBtcLnSwapNewSubmarine(
      {required String mnemonic,
      required BigInt index,
      required String invoice,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(mnemonic);
        var arg1 = cst_encode_u_64(index);
        var arg2 = cst_encode_String(invoice);
        var arg3 = cst_encode_chain(network);
        var arg4 = cst_encode_String(electrumUrl);
        var arg5 = cst_encode_String(boltzUrl);
        var arg6 = cst_encode_opt_String(referralId);
        return wire.wire__crate__api__btc_ln__btc_ln_swap_new_submarine(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_btc_ln_swap,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiBtcLnBtcLnSwapNewSubmarineConstMeta,
      argValues: [
        mnemonic,
        index,
        invoice,
        network,
        electrumUrl,
        boltzUrl,
        referralId
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBtcLnBtcLnSwapNewSubmarineConstMeta =>
      const TaskConstMeta(
        debugName: "btc_ln_swap_new_submarine",
        argNames: [
          "mnemonic",
          "index",
          "invoice",
          "network",
          "electrumUrl",
          "boltzUrl",
          "referralId"
        ],
      );

  @override
  Future<String> crateApiBtcLnBtcLnSwapRefund(
      {required BtcLnSwap that,
      required String outAddress,
      required BigInt absFee,
      required bool tryCooperate}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_btc_ln_swap(that);
        var arg1 = cst_encode_String(outAddress);
        var arg2 = cst_encode_u_64(absFee);
        var arg3 = cst_encode_bool(tryCooperate);
        return wire.wire__crate__api__btc_ln__btc_ln_swap_refund(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiBtcLnBtcLnSwapRefundConstMeta,
      argValues: [that, outAddress, absFee, tryCooperate],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBtcLnBtcLnSwapRefundConstMeta =>
      const TaskConstMeta(
        debugName: "btc_ln_swap_refund",
        argNames: ["that", "outAddress", "absFee", "tryCooperate"],
      );

  @override
  Future<BigInt> crateApiBtcLnBtcLnSwapTxSize({required BtcLnSwap that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_btc_ln_swap(that);
        return wire.wire__crate__api__btc_ln__btc_ln_swap_tx_size(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_usize,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiBtcLnBtcLnSwapTxSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiBtcLnBtcLnSwapTxSizeConstMeta =>
      const TaskConstMeta(
        debugName: "btc_ln_swap_tx_size",
        argNames: ["that"],
      );

  @override
  Future<String> crateApiChainSwapChainSwapBroadcastBoltz(
      {required ChainSwap that,
      required String signedHex,
      required SwapTxKind kind}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_chain_swap(that);
        var arg1 = cst_encode_String(signedHex);
        var arg2 = cst_encode_swap_tx_kind(kind);
        return wire.wire__crate__api__chain_swap__chain_swap_broadcast_boltz(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiChainSwapChainSwapBroadcastBoltzConstMeta,
      argValues: [that, signedHex, kind],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiChainSwapChainSwapBroadcastBoltzConstMeta =>
      const TaskConstMeta(
        debugName: "chain_swap_broadcast_boltz",
        argNames: ["that", "signedHex", "kind"],
      );

  @override
  Future<String> crateApiChainSwapChainSwapBroadcastLocal(
      {required ChainSwap that,
      required String signedHex,
      required SwapTxKind kind}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_chain_swap(that);
        var arg1 = cst_encode_String(signedHex);
        var arg2 = cst_encode_swap_tx_kind(kind);
        return wire.wire__crate__api__chain_swap__chain_swap_broadcast_local(
            port_, arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiChainSwapChainSwapBroadcastLocalConstMeta,
      argValues: [that, signedHex, kind],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiChainSwapChainSwapBroadcastLocalConstMeta =>
      const TaskConstMeta(
        debugName: "chain_swap_broadcast_local",
        argNames: ["that", "signedHex", "kind"],
      );

  @override
  Future<String> crateApiChainSwapChainSwapClaim(
      {required ChainSwap that,
      required String outAddress,
      required String refundAddress,
      required BigInt absFee,
      required bool tryCooperate}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_chain_swap(that);
        var arg1 = cst_encode_String(outAddress);
        var arg2 = cst_encode_String(refundAddress);
        var arg3 = cst_encode_u_64(absFee);
        var arg4 = cst_encode_bool(tryCooperate);
        return wire.wire__crate__api__chain_swap__chain_swap_claim(
            port_, arg0, arg1, arg2, arg3, arg4);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiChainSwapChainSwapClaimConstMeta,
      argValues: [that, outAddress, refundAddress, absFee, tryCooperate],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiChainSwapChainSwapClaimConstMeta =>
      const TaskConstMeta(
        debugName: "chain_swap_claim",
        argNames: [
          "that",
          "outAddress",
          "refundAddress",
          "absFee",
          "tryCooperate"
        ],
      );

  @override
  Future<String> crateApiChainSwapChainSwapGetServerLockup(
      {required ChainSwap that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_chain_swap(that);
        return wire.wire__crate__api__chain_swap__chain_swap_get_server_lockup(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiChainSwapChainSwapGetServerLockupConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiChainSwapChainSwapGetServerLockupConstMeta =>
      const TaskConstMeta(
        debugName: "chain_swap_get_server_lockup",
        argNames: ["that"],
      );

  @override
  Future<String> crateApiChainSwapChainSwapGetUserLockup(
      {required ChainSwap that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_chain_swap(that);
        return wire.wire__crate__api__chain_swap__chain_swap_get_user_lockup(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiChainSwapChainSwapGetUserLockupConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiChainSwapChainSwapGetUserLockupConstMeta =>
      const TaskConstMeta(
        debugName: "chain_swap_get_user_lockup",
        argNames: ["that"],
      );

  @override
  Future<ChainSwap> crateApiChainSwapChainSwapNew(
      {required String id,
      required bool isTestnet,
      required ChainSwapDirection direction,
      required KeyPair refundKeys,
      required BigInt refundIndex,
      required KeyPair claimKeys,
      required BigInt claimIndex,
      required PreImage preimage,
      required BtcSwapScriptStr btcScriptStr,
      required LBtcSwapScriptStr lbtcScriptStr,
      required String scriptAddress,
      required BigInt outAmount,
      required String btcElectrumUrl,
      required String lbtcElectrumUrl,
      required String boltzUrl,
      String? referralId,
      required String blindingKey}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(id);
        var arg1 = cst_encode_bool(isTestnet);
        var arg2 = cst_encode_chain_swap_direction(direction);
        var arg3 = cst_encode_box_autoadd_key_pair(refundKeys);
        var arg4 = cst_encode_u_64(refundIndex);
        var arg5 = cst_encode_box_autoadd_key_pair(claimKeys);
        var arg6 = cst_encode_u_64(claimIndex);
        var arg7 = cst_encode_box_autoadd_pre_image(preimage);
        var arg8 = cst_encode_box_autoadd_btc_swap_script_str(btcScriptStr);
        var arg9 = cst_encode_box_autoadd_l_btc_swap_script_str(lbtcScriptStr);
        var arg10 = cst_encode_String(scriptAddress);
        var arg11 = cst_encode_u_64(outAmount);
        var arg12 = cst_encode_String(btcElectrumUrl);
        var arg13 = cst_encode_String(lbtcElectrumUrl);
        var arg14 = cst_encode_String(boltzUrl);
        var arg15 = cst_encode_opt_String(referralId);
        var arg16 = cst_encode_String(blindingKey);
        return wire.wire__crate__api__chain_swap__chain_swap_new(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
            arg7,
            arg8,
            arg9,
            arg10,
            arg11,
            arg12,
            arg13,
            arg14,
            arg15,
            arg16);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_chain_swap,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiChainSwapChainSwapNewConstMeta,
      argValues: [
        id,
        isTestnet,
        direction,
        refundKeys,
        refundIndex,
        claimKeys,
        claimIndex,
        preimage,
        btcScriptStr,
        lbtcScriptStr,
        scriptAddress,
        outAmount,
        btcElectrumUrl,
        lbtcElectrumUrl,
        boltzUrl,
        referralId,
        blindingKey
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiChainSwapChainSwapNewConstMeta =>
      const TaskConstMeta(
        debugName: "chain_swap_new",
        argNames: [
          "id",
          "isTestnet",
          "direction",
          "refundKeys",
          "refundIndex",
          "claimKeys",
          "claimIndex",
          "preimage",
          "btcScriptStr",
          "lbtcScriptStr",
          "scriptAddress",
          "outAmount",
          "btcElectrumUrl",
          "lbtcElectrumUrl",
          "boltzUrl",
          "referralId",
          "blindingKey"
        ],
      );

  @override
  Future<ChainSwap> crateApiChainSwapChainSwapNewSwap(
      {required ChainSwapDirection direction,
      required String mnemonic,
      required BigInt index,
      required BigInt amount,
      required bool isTestnet,
      required String btcElectrumUrl,
      required String lbtcElectrumUrl,
      required String boltzUrl,
      String? referralId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_chain_swap_direction(direction);
        var arg1 = cst_encode_String(mnemonic);
        var arg2 = cst_encode_u_64(index);
        var arg3 = cst_encode_u_64(amount);
        var arg4 = cst_encode_bool(isTestnet);
        var arg5 = cst_encode_String(btcElectrumUrl);
        var arg6 = cst_encode_String(lbtcElectrumUrl);
        var arg7 = cst_encode_String(boltzUrl);
        var arg8 = cst_encode_opt_String(referralId);
        return wire.wire__crate__api__chain_swap__chain_swap_new_swap(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_chain_swap,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiChainSwapChainSwapNewSwapConstMeta,
      argValues: [
        direction,
        mnemonic,
        index,
        amount,
        isTestnet,
        btcElectrumUrl,
        lbtcElectrumUrl,
        boltzUrl,
        referralId
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiChainSwapChainSwapNewSwapConstMeta =>
      const TaskConstMeta(
        debugName: "chain_swap_new_swap",
        argNames: [
          "direction",
          "mnemonic",
          "index",
          "amount",
          "isTestnet",
          "btcElectrumUrl",
          "lbtcElectrumUrl",
          "boltzUrl",
          "referralId"
        ],
      );

  @override
  Future<String> crateApiChainSwapChainSwapRefund(
      {required ChainSwap that,
      required String refundAddress,
      required BigInt absFee,
      required bool tryCooperate}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_chain_swap(that);
        var arg1 = cst_encode_String(refundAddress);
        var arg2 = cst_encode_u_64(absFee);
        var arg3 = cst_encode_bool(tryCooperate);
        return wire.wire__crate__api__chain_swap__chain_swap_refund(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiChainSwapChainSwapRefundConstMeta,
      argValues: [that, refundAddress, absFee, tryCooperate],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiChainSwapChainSwapRefundConstMeta =>
      const TaskConstMeta(
        debugName: "chain_swap_refund",
        argNames: ["that", "refundAddress", "absFee", "tryCooperate"],
      );

  @override
  Future<BoltzError> crateApiErrorBoltzErrorNew(
      {required String kind, required String message}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(kind);
        var arg1 = cst_encode_String(message);
        return wire.wire__crate__api__error__boltz_error_new(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_boltz_error,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiErrorBoltzErrorNewConstMeta,
      argValues: [kind, message],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiErrorBoltzErrorNewConstMeta => const TaskConstMeta(
        debugName: "boltz_error_new",
        argNames: ["kind", "message"],
      );

  @override
  Future<ChainFeesAndLimits> crateApiFeesFeesChain({required Fees that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_fees(that);
        return wire.wire__crate__api__fees__fees_chain(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_chain_fees_and_limits,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiFeesFeesChainConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFeesFeesChainConstMeta => const TaskConstMeta(
        debugName: "fees_chain",
        argNames: ["that"],
      );

  @override
  Future<Fees> crateApiFeesFeesNew({required String boltzUrl}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(boltzUrl);
        return wire.wire__crate__api__fees__fees_new(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_fees,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiFeesFeesNewConstMeta,
      argValues: [boltzUrl],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFeesFeesNewConstMeta => const TaskConstMeta(
        debugName: "fees_new",
        argNames: ["boltzUrl"],
      );

  @override
  Future<ReverseFeesAndLimits> crateApiFeesFeesReverse({required Fees that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_fees(that);
        return wire.wire__crate__api__fees__fees_reverse(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_reverse_fees_and_limits,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiFeesFeesReverseConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFeesFeesReverseConstMeta => const TaskConstMeta(
        debugName: "fees_reverse",
        argNames: ["that"],
      );

  @override
  Future<SubmarineFeesAndLimits> crateApiFeesFeesSubmarine(
      {required Fees that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_fees(that);
        return wire.wire__crate__api__fees__fees_submarine(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_submarine_fees_and_limits,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiFeesFeesSubmarineConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiFeesFeesSubmarineConstMeta => const TaskConstMeta(
        debugName: "fees_submarine",
        argNames: ["that"],
      );

  @override
  Future<String> crateApiLbtcLnLbtcLnSwapBroadcastBoltz(
      {required LbtcLnSwap that, required String signedHex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_lbtc_ln_swap(that);
        var arg1 = cst_encode_String(signedHex);
        return wire.wire__crate__api__lbtc_ln__lbtc_ln_swap_broadcast_boltz(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiLbtcLnLbtcLnSwapBroadcastBoltzConstMeta,
      argValues: [that, signedHex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLbtcLnLbtcLnSwapBroadcastBoltzConstMeta =>
      const TaskConstMeta(
        debugName: "lbtc_ln_swap_broadcast_boltz",
        argNames: ["that", "signedHex"],
      );

  @override
  Future<String> crateApiLbtcLnLbtcLnSwapBroadcastLocal(
      {required LbtcLnSwap that, required String signedHex}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_lbtc_ln_swap(that);
        var arg1 = cst_encode_String(signedHex);
        return wire.wire__crate__api__lbtc_ln__lbtc_ln_swap_broadcast_local(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiLbtcLnLbtcLnSwapBroadcastLocalConstMeta,
      argValues: [that, signedHex],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLbtcLnLbtcLnSwapBroadcastLocalConstMeta =>
      const TaskConstMeta(
        debugName: "lbtc_ln_swap_broadcast_local",
        argNames: ["that", "signedHex"],
      );

  @override
  Future<String> crateApiLbtcLnLbtcLnSwapClaim(
      {required LbtcLnSwap that,
      required String outAddress,
      required BigInt absFee,
      required bool tryCooperate}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_lbtc_ln_swap(that);
        var arg1 = cst_encode_String(outAddress);
        var arg2 = cst_encode_u_64(absFee);
        var arg3 = cst_encode_bool(tryCooperate);
        return wire.wire__crate__api__lbtc_ln__lbtc_ln_swap_claim(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiLbtcLnLbtcLnSwapClaimConstMeta,
      argValues: [that, outAddress, absFee, tryCooperate],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLbtcLnLbtcLnSwapClaimConstMeta =>
      const TaskConstMeta(
        debugName: "lbtc_ln_swap_claim",
        argNames: ["that", "outAddress", "absFee", "tryCooperate"],
      );

  @override
  Future<void> crateApiLbtcLnLbtcLnSwapCoopCloseSubmarine(
      {required LbtcLnSwap that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_lbtc_ln_swap(that);
        return wire
            .wire__crate__api__lbtc_ln__lbtc_ln_swap_coop_close_submarine(
                port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiLbtcLnLbtcLnSwapCoopCloseSubmarineConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLbtcLnLbtcLnSwapCoopCloseSubmarineConstMeta =>
      const TaskConstMeta(
        debugName: "lbtc_ln_swap_coop_close_submarine",
        argNames: ["that"],
      );

  @override
  Future<LbtcLnSwap> crateApiLbtcLnLbtcLnSwapNew(
      {required String id,
      required SwapType kind,
      required Chain network,
      required KeyPair keys,
      required BigInt keyIndex,
      required PreImage preimage,
      required LBtcSwapScriptStr swapScript,
      required String invoice,
      required BigInt outAmount,
      required String outAddress,
      required String blindingKey,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(id);
        var arg1 = cst_encode_swap_type(kind);
        var arg2 = cst_encode_chain(network);
        var arg3 = cst_encode_box_autoadd_key_pair(keys);
        var arg4 = cst_encode_u_64(keyIndex);
        var arg5 = cst_encode_box_autoadd_pre_image(preimage);
        var arg6 = cst_encode_box_autoadd_l_btc_swap_script_str(swapScript);
        var arg7 = cst_encode_String(invoice);
        var arg8 = cst_encode_u_64(outAmount);
        var arg9 = cst_encode_String(outAddress);
        var arg10 = cst_encode_String(blindingKey);
        var arg11 = cst_encode_String(electrumUrl);
        var arg12 = cst_encode_String(boltzUrl);
        var arg13 = cst_encode_opt_String(referralId);
        return wire.wire__crate__api__lbtc_ln__lbtc_ln_swap_new(
            port_,
            arg0,
            arg1,
            arg2,
            arg3,
            arg4,
            arg5,
            arg6,
            arg7,
            arg8,
            arg9,
            arg10,
            arg11,
            arg12,
            arg13);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_lbtc_ln_swap,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiLbtcLnLbtcLnSwapNewConstMeta,
      argValues: [
        id,
        kind,
        network,
        keys,
        keyIndex,
        preimage,
        swapScript,
        invoice,
        outAmount,
        outAddress,
        blindingKey,
        electrumUrl,
        boltzUrl,
        referralId
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLbtcLnLbtcLnSwapNewConstMeta =>
      const TaskConstMeta(
        debugName: "lbtc_ln_swap_new",
        argNames: [
          "id",
          "kind",
          "network",
          "keys",
          "keyIndex",
          "preimage",
          "swapScript",
          "invoice",
          "outAmount",
          "outAddress",
          "blindingKey",
          "electrumUrl",
          "boltzUrl",
          "referralId"
        ],
      );

  @override
  Future<LbtcLnSwap> crateApiLbtcLnLbtcLnSwapNewReverse(
      {required String mnemonic,
      required BigInt index,
      required BigInt outAmount,
      String? outAddress,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      String? description,
      String? referralId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(mnemonic);
        var arg1 = cst_encode_u_64(index);
        var arg2 = cst_encode_u_64(outAmount);
        var arg3 = cst_encode_opt_String(outAddress);
        var arg4 = cst_encode_chain(network);
        var arg5 = cst_encode_String(electrumUrl);
        var arg6 = cst_encode_String(boltzUrl);
        var arg7 = cst_encode_opt_String(description);
        var arg8 = cst_encode_opt_String(referralId);
        return wire.wire__crate__api__lbtc_ln__lbtc_ln_swap_new_reverse(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_lbtc_ln_swap,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiLbtcLnLbtcLnSwapNewReverseConstMeta,
      argValues: [
        mnemonic,
        index,
        outAmount,
        outAddress,
        network,
        electrumUrl,
        boltzUrl,
        description,
        referralId
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLbtcLnLbtcLnSwapNewReverseConstMeta =>
      const TaskConstMeta(
        debugName: "lbtc_ln_swap_new_reverse",
        argNames: [
          "mnemonic",
          "index",
          "outAmount",
          "outAddress",
          "network",
          "electrumUrl",
          "boltzUrl",
          "description",
          "referralId"
        ],
      );

  @override
  Future<LbtcLnSwap> crateApiLbtcLnLbtcLnSwapNewSubmarine(
      {required String mnemonic,
      required BigInt index,
      required String invoice,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      String? referralId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(mnemonic);
        var arg1 = cst_encode_u_64(index);
        var arg2 = cst_encode_String(invoice);
        var arg3 = cst_encode_chain(network);
        var arg4 = cst_encode_String(electrumUrl);
        var arg5 = cst_encode_String(boltzUrl);
        var arg6 = cst_encode_opt_String(referralId);
        return wire.wire__crate__api__lbtc_ln__lbtc_ln_swap_new_submarine(
            port_, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_lbtc_ln_swap,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiLbtcLnLbtcLnSwapNewSubmarineConstMeta,
      argValues: [
        mnemonic,
        index,
        invoice,
        network,
        electrumUrl,
        boltzUrl,
        referralId
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLbtcLnLbtcLnSwapNewSubmarineConstMeta =>
      const TaskConstMeta(
        debugName: "lbtc_ln_swap_new_submarine",
        argNames: [
          "mnemonic",
          "index",
          "invoice",
          "network",
          "electrumUrl",
          "boltzUrl",
          "referralId"
        ],
      );

  @override
  Future<String> crateApiLbtcLnLbtcLnSwapRefund(
      {required LbtcLnSwap that,
      required String outAddress,
      required BigInt absFee,
      required bool tryCooperate}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_lbtc_ln_swap(that);
        var arg1 = cst_encode_String(outAddress);
        var arg2 = cst_encode_u_64(absFee);
        var arg3 = cst_encode_bool(tryCooperate);
        return wire.wire__crate__api__lbtc_ln__lbtc_ln_swap_refund(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiLbtcLnLbtcLnSwapRefundConstMeta,
      argValues: [that, outAddress, absFee, tryCooperate],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLbtcLnLbtcLnSwapRefundConstMeta =>
      const TaskConstMeta(
        debugName: "lbtc_ln_swap_refund",
        argNames: ["that", "outAddress", "absFee", "tryCooperate"],
      );

  @override
  Future<BigInt> crateApiLbtcLnLbtcLnSwapTxSize({required LbtcLnSwap that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_box_autoadd_lbtc_ln_swap(that);
        return wire.wire__crate__api__lbtc_ln__lbtc_ln_swap_tx_size(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_usize,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiLbtcLnLbtcLnSwapTxSizeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiLbtcLnLbtcLnSwapTxSizeConstMeta =>
      const TaskConstMeta(
        debugName: "lbtc_ln_swap_tx_size",
        argNames: ["that"],
      );

  @override
  BtcSwapScriptStr crateApiTypesBtcSwapScriptStrNew(
      {required SwapType swapType,
      String? fundingAddrs,
      required String hashlock,
      required String receiverPubkey,
      required int locktime,
      required String senderPubkey,
      Side? side}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_swap_type(swapType);
        var arg1 = cst_encode_opt_String(fundingAddrs);
        var arg2 = cst_encode_String(hashlock);
        var arg3 = cst_encode_String(receiverPubkey);
        var arg4 = cst_encode_u_32(locktime);
        var arg5 = cst_encode_String(senderPubkey);
        var arg6 = cst_encode_opt_box_autoadd_side(side);
        return wire.wire__crate__api__types__btc_swap_script_str_new(
            arg0, arg1, arg2, arg3, arg4, arg5, arg6);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_btc_swap_script_str,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiTypesBtcSwapScriptStrNewConstMeta,
      argValues: [
        swapType,
        fundingAddrs,
        hashlock,
        receiverPubkey,
        locktime,
        senderPubkey,
        side
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTypesBtcSwapScriptStrNewConstMeta =>
      const TaskConstMeta(
        debugName: "btc_swap_script_str_new",
        argNames: [
          "swapType",
          "fundingAddrs",
          "hashlock",
          "receiverPubkey",
          "locktime",
          "senderPubkey",
          "side"
        ],
      );

  @override
  Future<DecodedInvoice> crateApiTypesDecodedInvoiceFromString(
      {required String s, String? boltzUrl}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(s);
        var arg1 = cst_encode_opt_String(boltzUrl);
        return wire.wire__crate__api__types__decoded_invoice_from_string(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_decoded_invoice,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiTypesDecodedInvoiceFromStringConstMeta,
      argValues: [s, boltzUrl],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTypesDecodedInvoiceFromStringConstMeta =>
      const TaskConstMeta(
        debugName: "decoded_invoice_from_string",
        argNames: ["s", "boltzUrl"],
      );

  @override
  Future<BigInt> crateApiTypesGetVoucherMaxAmount({required String lnurl}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(lnurl);
        return wire.wire__crate__api__types__get_voucher_max_amount(
            port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_u_64,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiTypesGetVoucherMaxAmountConstMeta,
      argValues: [lnurl],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTypesGetVoucherMaxAmountConstMeta =>
      const TaskConstMeta(
        debugName: "get_voucher_max_amount",
        argNames: ["lnurl"],
      );

  @override
  Future<String> crateApiTypesInvoiceFromLnurl(
      {required String lnurl, required BigInt msats}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(lnurl);
        var arg1 = cst_encode_u_64(msats);
        return wire.wire__crate__api__types__invoice_from_lnurl(
            port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_String,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiTypesInvoiceFromLnurlConstMeta,
      argValues: [lnurl, msats],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTypesInvoiceFromLnurlConstMeta =>
      const TaskConstMeta(
        debugName: "invoice_from_lnurl",
        argNames: ["lnurl", "msats"],
      );

  @override
  Future<KeyPair> crateApiTypesKeyPairGenerate(
      {required String mnemonic,
      required Chain network,
      required BigInt index,
      required SwapType swapType}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(mnemonic);
        var arg1 = cst_encode_chain(network);
        var arg2 = cst_encode_u_64(index);
        var arg3 = cst_encode_swap_type(swapType);
        return wire.wire__crate__api__types__key_pair_generate(
            port_, arg0, arg1, arg2, arg3);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_key_pair,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiTypesKeyPairGenerateConstMeta,
      argValues: [mnemonic, network, index, swapType],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTypesKeyPairGenerateConstMeta =>
      const TaskConstMeta(
        debugName: "key_pair_generate",
        argNames: ["mnemonic", "network", "index", "swapType"],
      );

  @override
  KeyPair crateApiTypesKeyPairNew(
      {required String secretKey, required String publicKey}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_String(secretKey);
        var arg1 = cst_encode_String(publicKey);
        return wire.wire__crate__api__types__key_pair_new(arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_key_pair,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiTypesKeyPairNewConstMeta,
      argValues: [secretKey, publicKey],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTypesKeyPairNewConstMeta => const TaskConstMeta(
        debugName: "key_pair_new",
        argNames: ["secretKey", "publicKey"],
      );

  @override
  LBtcSwapScriptStr crateApiTypesLBtcSwapScriptStrNew(
      {required SwapType swapType,
      String? fundingAddrs,
      required String hashlock,
      required String receiverPubkey,
      required int locktime,
      required String senderPubkey,
      required String blindingKey,
      Side? side}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_swap_type(swapType);
        var arg1 = cst_encode_opt_String(fundingAddrs);
        var arg2 = cst_encode_String(hashlock);
        var arg3 = cst_encode_String(receiverPubkey);
        var arg4 = cst_encode_u_32(locktime);
        var arg5 = cst_encode_String(senderPubkey);
        var arg6 = cst_encode_String(blindingKey);
        var arg7 = cst_encode_opt_box_autoadd_side(side);
        return wire.wire__crate__api__types__l_btc_swap_script_str_new(
            arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_l_btc_swap_script_str,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiTypesLBtcSwapScriptStrNewConstMeta,
      argValues: [
        swapType,
        fundingAddrs,
        hashlock,
        receiverPubkey,
        locktime,
        senderPubkey,
        blindingKey,
        side
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTypesLBtcSwapScriptStrNewConstMeta =>
      const TaskConstMeta(
        debugName: "l_btc_swap_script_str_new",
        argNames: [
          "swapType",
          "fundingAddrs",
          "hashlock",
          "receiverPubkey",
          "locktime",
          "senderPubkey",
          "blindingKey",
          "side"
        ],
      );

  @override
  Future<PreImage> crateApiTypesPreImageGenerate() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        return wire.wire__crate__api__types__pre_image_generate(port_);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_pre_image,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiTypesPreImageGenerateConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTypesPreImageGenerateConstMeta =>
      const TaskConstMeta(
        debugName: "pre_image_generate",
        argNames: [],
      );

  @override
  PreImage crateApiTypesPreImageNew(
      {required String value,
      required String sha256,
      required String hash160}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        var arg0 = cst_encode_String(value);
        var arg1 = cst_encode_String(sha256);
        var arg2 = cst_encode_String(hash160);
        return wire.wire__crate__api__types__pre_image_new(arg0, arg1, arg2);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_pre_image,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiTypesPreImageNewConstMeta,
      argValues: [value, sha256, hash160],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTypesPreImageNewConstMeta => const TaskConstMeta(
        debugName: "pre_image_new",
        argNames: ["value", "sha256", "hash160"],
      );

  @override
  Future<bool> crateApiTypesValidateLnurl({required String lnurl}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(lnurl);
        return wire.wire__crate__api__types__validate_lnurl(port_, arg0);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiTypesValidateLnurlConstMeta,
      argValues: [lnurl],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTypesValidateLnurlConstMeta => const TaskConstMeta(
        debugName: "validate_lnurl",
        argNames: ["lnurl"],
      );

  @override
  Future<void> crateApiTypesWithdraw(
      {required String lnurl, required String invoice}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        var arg0 = cst_encode_String(lnurl);
        var arg1 = cst_encode_String(invoice);
        return wire.wire__crate__api__types__withdraw(port_, arg0, arg1);
      },
      codec: DcoCodec(
        decodeSuccessData: dco_decode_unit,
        decodeErrorData: dco_decode_boltz_error,
      ),
      constMeta: kCrateApiTypesWithdrawConstMeta,
      argValues: [lnurl, invoice],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiTypesWithdrawConstMeta => const TaskConstMeta(
        debugName: "withdraw",
        argNames: ["lnurl", "invoice"],
      );

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  BoltzError dco_decode_boltz_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return BoltzError(
      kind: dco_decode_String(arr[0]),
      message: dco_decode_String(arr[1]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  BtcLnSwap dco_decode_box_autoadd_btc_ln_swap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_btc_ln_swap(raw);
  }

  @protected
  BtcSwapScriptStr dco_decode_box_autoadd_btc_swap_script_str(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_btc_swap_script_str(raw);
  }

  @protected
  ChainSwap dco_decode_box_autoadd_chain_swap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_chain_swap(raw);
  }

  @protected
  Fees dco_decode_box_autoadd_fees(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_fees(raw);
  }

  @protected
  KeyPair dco_decode_box_autoadd_key_pair(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_key_pair(raw);
  }

  @protected
  LBtcSwapScriptStr dco_decode_box_autoadd_l_btc_swap_script_str(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_l_btc_swap_script_str(raw);
  }

  @protected
  LbtcLnSwap dco_decode_box_autoadd_lbtc_ln_swap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_lbtc_ln_swap(raw);
  }

  @protected
  PreImage dco_decode_box_autoadd_pre_image(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_pre_image(raw);
  }

  @protected
  Side dco_decode_box_autoadd_side(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_side(raw);
  }

  @protected
  BtcLnSwap dco_decode_btc_ln_swap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 13)
      throw Exception('unexpected arr length: expect 13 but see ${arr.length}');
    return BtcLnSwap(
      id: dco_decode_String(arr[0]),
      kind: dco_decode_swap_type(arr[1]),
      network: dco_decode_chain(arr[2]),
      keys: dco_decode_key_pair(arr[3]),
      keyIndex: dco_decode_u_64(arr[4]),
      preimage: dco_decode_pre_image(arr[5]),
      swapScript: dco_decode_btc_swap_script_str(arr[6]),
      invoice: dco_decode_String(arr[7]),
      scriptAddress: dco_decode_String(arr[8]),
      outAmount: dco_decode_u_64(arr[9]),
      electrumUrl: dco_decode_String(arr[10]),
      boltzUrl: dco_decode_String(arr[11]),
      referralId: dco_decode_opt_String(arr[12]),
    );
  }

  @protected
  BtcSwapScriptStr dco_decode_btc_swap_script_str(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return BtcSwapScriptStr.raw(
      swapType: dco_decode_swap_type(arr[0]),
      fundingAddrs: dco_decode_opt_String(arr[1]),
      hashlock: dco_decode_String(arr[2]),
      receiverPubkey: dco_decode_String(arr[3]),
      locktime: dco_decode_u_32(arr[4]),
      senderPubkey: dco_decode_String(arr[5]),
      side: dco_decode_opt_box_autoadd_side(arr[6]),
    );
  }

  @protected
  Chain dco_decode_chain(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Chain.values[raw as int];
  }

  @protected
  ChainFeesAndLimits dco_decode_chain_fees_and_limits(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ChainFeesAndLimits(
      btcLimits: dco_decode_swap_limits(arr[0]),
      lbtcLimits: dco_decode_swap_limits(arr[1]),
      btcFees: dco_decode_chain_swap_fees(arr[2]),
      lbtcFees: dco_decode_chain_swap_fees(arr[3]),
    );
  }

  @protected
  ChainSwap dco_decode_chain_swap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 17)
      throw Exception('unexpected arr length: expect 17 but see ${arr.length}');
    return ChainSwap(
      id: dco_decode_String(arr[0]),
      isTestnet: dco_decode_bool(arr[1]),
      direction: dco_decode_chain_swap_direction(arr[2]),
      refundKeys: dco_decode_key_pair(arr[3]),
      refundIndex: dco_decode_u_64(arr[4]),
      claimKeys: dco_decode_key_pair(arr[5]),
      claimIndex: dco_decode_u_64(arr[6]),
      preimage: dco_decode_pre_image(arr[7]),
      btcScriptStr: dco_decode_btc_swap_script_str(arr[8]),
      lbtcScriptStr: dco_decode_l_btc_swap_script_str(arr[9]),
      scriptAddress: dco_decode_String(arr[10]),
      outAmount: dco_decode_u_64(arr[11]),
      btcElectrumUrl: dco_decode_String(arr[12]),
      lbtcElectrumUrl: dco_decode_String(arr[13]),
      boltzUrl: dco_decode_String(arr[14]),
      referralId: dco_decode_opt_String(arr[15]),
      blindingKey: dco_decode_String(arr[16]),
    );
  }

  @protected
  ChainSwapDirection dco_decode_chain_swap_direction(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ChainSwapDirection.values[raw as int];
  }

  @protected
  ChainSwapFees dco_decode_chain_swap_fees(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ChainSwapFees(
      percentage: dco_decode_f_64(arr[0]),
      userLockup: dco_decode_u_64(arr[1]),
      userClaim: dco_decode_u_64(arr[2]),
      server: dco_decode_u_64(arr[3]),
    );
  }

  @protected
  DecodedInvoice dco_decode_decoded_invoice(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return DecodedInvoice(
      msats: dco_decode_u_64(arr[0]),
      expiry: dco_decode_u_64(arr[1]),
      expiresIn: dco_decode_u_64(arr[2]),
      expiresAt: dco_decode_u_64(arr[3]),
      isExpired: dco_decode_bool(arr[4]),
      network: dco_decode_String(arr[5]),
      cltvExpDelta: dco_decode_u_64(arr[6]),
      bip21: dco_decode_opt_String(arr[7]),
      preimageHash: dco_decode_String(arr[8]),
    );
  }

  @protected
  double dco_decode_f_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  Fees dco_decode_fees(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return Fees(
      boltzUrl: dco_decode_String(arr[0]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  KeyPair dco_decode_key_pair(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return KeyPair.raw(
      secretKey: dco_decode_String(arr[0]),
      publicKey: dco_decode_String(arr[1]),
    );
  }

  @protected
  LBtcSwapScriptStr dco_decode_l_btc_swap_script_str(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return LBtcSwapScriptStr.raw(
      swapType: dco_decode_swap_type(arr[0]),
      fundingAddrs: dco_decode_opt_String(arr[1]),
      hashlock: dco_decode_String(arr[2]),
      receiverPubkey: dco_decode_String(arr[3]),
      locktime: dco_decode_u_32(arr[4]),
      senderPubkey: dco_decode_String(arr[5]),
      blindingKey: dco_decode_String(arr[6]),
      side: dco_decode_opt_box_autoadd_side(arr[7]),
    );
  }

  @protected
  LbtcLnSwap dco_decode_lbtc_ln_swap(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 14)
      throw Exception('unexpected arr length: expect 14 but see ${arr.length}');
    return LbtcLnSwap(
      id: dco_decode_String(arr[0]),
      kind: dco_decode_swap_type(arr[1]),
      network: dco_decode_chain(arr[2]),
      keys: dco_decode_key_pair(arr[3]),
      keyIndex: dco_decode_u_64(arr[4]),
      preimage: dco_decode_pre_image(arr[5]),
      swapScript: dco_decode_l_btc_swap_script_str(arr[6]),
      invoice: dco_decode_String(arr[7]),
      outAmount: dco_decode_u_64(arr[8]),
      scriptAddress: dco_decode_String(arr[9]),
      blindingKey: dco_decode_String(arr[10]),
      electrumUrl: dco_decode_String(arr[11]),
      boltzUrl: dco_decode_String(arr[12]),
      referralId: dco_decode_opt_String(arr[13]),
    );
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  MinerFees dco_decode_miner_fees(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return MinerFees(
      lockup: dco_decode_u_64(arr[0]),
      claim: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  Side? dco_decode_opt_box_autoadd_side(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_side(raw);
  }

  @protected
  PreImage dco_decode_pre_image(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return PreImage.raw(
      value: dco_decode_String(arr[0]),
      sha256: dco_decode_String(arr[1]),
      hash160: dco_decode_String(arr[2]),
    );
  }

  @protected
  RevSwapFees dco_decode_rev_swap_fees(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return RevSwapFees(
      percentage: dco_decode_f_64(arr[0]),
      minerFees: dco_decode_miner_fees(arr[1]),
    );
  }

  @protected
  ReverseFeesAndLimits dco_decode_reverse_fees_and_limits(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return ReverseFeesAndLimits(
      btcLimits: dco_decode_swap_limits(arr[0]),
      lbtcLimits: dco_decode_swap_limits(arr[1]),
      btcFees: dco_decode_rev_swap_fees(arr[2]),
      lbtcFees: dco_decode_rev_swap_fees(arr[3]),
    );
  }

  @protected
  Side dco_decode_side(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Side.values[raw as int];
  }

  @protected
  SubSwapFees dco_decode_sub_swap_fees(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SubSwapFees(
      percentage: dco_decode_f_64(arr[0]),
      minerFees: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  SubmarineFeesAndLimits dco_decode_submarine_fees_and_limits(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return SubmarineFeesAndLimits(
      btcLimits: dco_decode_swap_limits(arr[0]),
      lbtcLimits: dco_decode_swap_limits(arr[1]),
      btcFees: dco_decode_sub_swap_fees(arr[2]),
      lbtcFees: dco_decode_sub_swap_fees(arr[3]),
    );
  }

  @protected
  SwapLimits dco_decode_swap_limits(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SwapLimits(
      minimal: dco_decode_u_64(arr[0]),
      maximal: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  SwapTxKind dco_decode_swap_tx_kind(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SwapTxKind.values[raw as int];
  }

  @protected
  SwapType dco_decode_swap_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SwapType.values[raw as int];
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  BoltzError sse_decode_boltz_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_kind = sse_decode_String(deserializer);
    var var_message = sse_decode_String(deserializer);
    return BoltzError(kind: var_kind, message: var_message);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  BtcLnSwap sse_decode_box_autoadd_btc_ln_swap(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_btc_ln_swap(deserializer));
  }

  @protected
  BtcSwapScriptStr sse_decode_box_autoadd_btc_swap_script_str(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_btc_swap_script_str(deserializer));
  }

  @protected
  ChainSwap sse_decode_box_autoadd_chain_swap(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_chain_swap(deserializer));
  }

  @protected
  Fees sse_decode_box_autoadd_fees(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_fees(deserializer));
  }

  @protected
  KeyPair sse_decode_box_autoadd_key_pair(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_key_pair(deserializer));
  }

  @protected
  LBtcSwapScriptStr sse_decode_box_autoadd_l_btc_swap_script_str(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_l_btc_swap_script_str(deserializer));
  }

  @protected
  LbtcLnSwap sse_decode_box_autoadd_lbtc_ln_swap(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_lbtc_ln_swap(deserializer));
  }

  @protected
  PreImage sse_decode_box_autoadd_pre_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_pre_image(deserializer));
  }

  @protected
  Side sse_decode_box_autoadd_side(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_side(deserializer));
  }

  @protected
  BtcLnSwap sse_decode_btc_ln_swap(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_kind = sse_decode_swap_type(deserializer);
    var var_network = sse_decode_chain(deserializer);
    var var_keys = sse_decode_key_pair(deserializer);
    var var_keyIndex = sse_decode_u_64(deserializer);
    var var_preimage = sse_decode_pre_image(deserializer);
    var var_swapScript = sse_decode_btc_swap_script_str(deserializer);
    var var_invoice = sse_decode_String(deserializer);
    var var_scriptAddress = sse_decode_String(deserializer);
    var var_outAmount = sse_decode_u_64(deserializer);
    var var_electrumUrl = sse_decode_String(deserializer);
    var var_boltzUrl = sse_decode_String(deserializer);
    var var_referralId = sse_decode_opt_String(deserializer);
    return BtcLnSwap(
        id: var_id,
        kind: var_kind,
        network: var_network,
        keys: var_keys,
        keyIndex: var_keyIndex,
        preimage: var_preimage,
        swapScript: var_swapScript,
        invoice: var_invoice,
        scriptAddress: var_scriptAddress,
        outAmount: var_outAmount,
        electrumUrl: var_electrumUrl,
        boltzUrl: var_boltzUrl,
        referralId: var_referralId);
  }

  @protected
  BtcSwapScriptStr sse_decode_btc_swap_script_str(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_swapType = sse_decode_swap_type(deserializer);
    var var_fundingAddrs = sse_decode_opt_String(deserializer);
    var var_hashlock = sse_decode_String(deserializer);
    var var_receiverPubkey = sse_decode_String(deserializer);
    var var_locktime = sse_decode_u_32(deserializer);
    var var_senderPubkey = sse_decode_String(deserializer);
    var var_side = sse_decode_opt_box_autoadd_side(deserializer);
    return BtcSwapScriptStr.raw(
        swapType: var_swapType,
        fundingAddrs: var_fundingAddrs,
        hashlock: var_hashlock,
        receiverPubkey: var_receiverPubkey,
        locktime: var_locktime,
        senderPubkey: var_senderPubkey,
        side: var_side);
  }

  @protected
  Chain sse_decode_chain(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Chain.values[inner];
  }

  @protected
  ChainFeesAndLimits sse_decode_chain_fees_and_limits(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_btcLimits = sse_decode_swap_limits(deserializer);
    var var_lbtcLimits = sse_decode_swap_limits(deserializer);
    var var_btcFees = sse_decode_chain_swap_fees(deserializer);
    var var_lbtcFees = sse_decode_chain_swap_fees(deserializer);
    return ChainFeesAndLimits(
        btcLimits: var_btcLimits,
        lbtcLimits: var_lbtcLimits,
        btcFees: var_btcFees,
        lbtcFees: var_lbtcFees);
  }

  @protected
  ChainSwap sse_decode_chain_swap(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_isTestnet = sse_decode_bool(deserializer);
    var var_direction = sse_decode_chain_swap_direction(deserializer);
    var var_refundKeys = sse_decode_key_pair(deserializer);
    var var_refundIndex = sse_decode_u_64(deserializer);
    var var_claimKeys = sse_decode_key_pair(deserializer);
    var var_claimIndex = sse_decode_u_64(deserializer);
    var var_preimage = sse_decode_pre_image(deserializer);
    var var_btcScriptStr = sse_decode_btc_swap_script_str(deserializer);
    var var_lbtcScriptStr = sse_decode_l_btc_swap_script_str(deserializer);
    var var_scriptAddress = sse_decode_String(deserializer);
    var var_outAmount = sse_decode_u_64(deserializer);
    var var_btcElectrumUrl = sse_decode_String(deserializer);
    var var_lbtcElectrumUrl = sse_decode_String(deserializer);
    var var_boltzUrl = sse_decode_String(deserializer);
    var var_referralId = sse_decode_opt_String(deserializer);
    var var_blindingKey = sse_decode_String(deserializer);
    return ChainSwap(
        id: var_id,
        isTestnet: var_isTestnet,
        direction: var_direction,
        refundKeys: var_refundKeys,
        refundIndex: var_refundIndex,
        claimKeys: var_claimKeys,
        claimIndex: var_claimIndex,
        preimage: var_preimage,
        btcScriptStr: var_btcScriptStr,
        lbtcScriptStr: var_lbtcScriptStr,
        scriptAddress: var_scriptAddress,
        outAmount: var_outAmount,
        btcElectrumUrl: var_btcElectrumUrl,
        lbtcElectrumUrl: var_lbtcElectrumUrl,
        boltzUrl: var_boltzUrl,
        referralId: var_referralId,
        blindingKey: var_blindingKey);
  }

  @protected
  ChainSwapDirection sse_decode_chain_swap_direction(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ChainSwapDirection.values[inner];
  }

  @protected
  ChainSwapFees sse_decode_chain_swap_fees(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_percentage = sse_decode_f_64(deserializer);
    var var_userLockup = sse_decode_u_64(deserializer);
    var var_userClaim = sse_decode_u_64(deserializer);
    var var_server = sse_decode_u_64(deserializer);
    return ChainSwapFees(
        percentage: var_percentage,
        userLockup: var_userLockup,
        userClaim: var_userClaim,
        server: var_server);
  }

  @protected
  DecodedInvoice sse_decode_decoded_invoice(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_msats = sse_decode_u_64(deserializer);
    var var_expiry = sse_decode_u_64(deserializer);
    var var_expiresIn = sse_decode_u_64(deserializer);
    var var_expiresAt = sse_decode_u_64(deserializer);
    var var_isExpired = sse_decode_bool(deserializer);
    var var_network = sse_decode_String(deserializer);
    var var_cltvExpDelta = sse_decode_u_64(deserializer);
    var var_bip21 = sse_decode_opt_String(deserializer);
    var var_preimageHash = sse_decode_String(deserializer);
    return DecodedInvoice(
        msats: var_msats,
        expiry: var_expiry,
        expiresIn: var_expiresIn,
        expiresAt: var_expiresAt,
        isExpired: var_isExpired,
        network: var_network,
        cltvExpDelta: var_cltvExpDelta,
        bip21: var_bip21,
        preimageHash: var_preimageHash);
  }

  @protected
  double sse_decode_f_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat64();
  }

  @protected
  Fees sse_decode_fees(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_boltzUrl = sse_decode_String(deserializer);
    return Fees(boltzUrl: var_boltzUrl);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  KeyPair sse_decode_key_pair(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_secretKey = sse_decode_String(deserializer);
    var var_publicKey = sse_decode_String(deserializer);
    return KeyPair.raw(secretKey: var_secretKey, publicKey: var_publicKey);
  }

  @protected
  LBtcSwapScriptStr sse_decode_l_btc_swap_script_str(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_swapType = sse_decode_swap_type(deserializer);
    var var_fundingAddrs = sse_decode_opt_String(deserializer);
    var var_hashlock = sse_decode_String(deserializer);
    var var_receiverPubkey = sse_decode_String(deserializer);
    var var_locktime = sse_decode_u_32(deserializer);
    var var_senderPubkey = sse_decode_String(deserializer);
    var var_blindingKey = sse_decode_String(deserializer);
    var var_side = sse_decode_opt_box_autoadd_side(deserializer);
    return LBtcSwapScriptStr.raw(
        swapType: var_swapType,
        fundingAddrs: var_fundingAddrs,
        hashlock: var_hashlock,
        receiverPubkey: var_receiverPubkey,
        locktime: var_locktime,
        senderPubkey: var_senderPubkey,
        blindingKey: var_blindingKey,
        side: var_side);
  }

  @protected
  LbtcLnSwap sse_decode_lbtc_ln_swap(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_kind = sse_decode_swap_type(deserializer);
    var var_network = sse_decode_chain(deserializer);
    var var_keys = sse_decode_key_pair(deserializer);
    var var_keyIndex = sse_decode_u_64(deserializer);
    var var_preimage = sse_decode_pre_image(deserializer);
    var var_swapScript = sse_decode_l_btc_swap_script_str(deserializer);
    var var_invoice = sse_decode_String(deserializer);
    var var_outAmount = sse_decode_u_64(deserializer);
    var var_scriptAddress = sse_decode_String(deserializer);
    var var_blindingKey = sse_decode_String(deserializer);
    var var_electrumUrl = sse_decode_String(deserializer);
    var var_boltzUrl = sse_decode_String(deserializer);
    var var_referralId = sse_decode_opt_String(deserializer);
    return LbtcLnSwap(
        id: var_id,
        kind: var_kind,
        network: var_network,
        keys: var_keys,
        keyIndex: var_keyIndex,
        preimage: var_preimage,
        swapScript: var_swapScript,
        invoice: var_invoice,
        outAmount: var_outAmount,
        scriptAddress: var_scriptAddress,
        blindingKey: var_blindingKey,
        electrumUrl: var_electrumUrl,
        boltzUrl: var_boltzUrl,
        referralId: var_referralId);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  MinerFees sse_decode_miner_fees(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_lockup = sse_decode_u_64(deserializer);
    var var_claim = sse_decode_u_64(deserializer);
    return MinerFees(lockup: var_lockup, claim: var_claim);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Side? sse_decode_opt_box_autoadd_side(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_side(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PreImage sse_decode_pre_image(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_value = sse_decode_String(deserializer);
    var var_sha256 = sse_decode_String(deserializer);
    var var_hash160 = sse_decode_String(deserializer);
    return PreImage.raw(
        value: var_value, sha256: var_sha256, hash160: var_hash160);
  }

  @protected
  RevSwapFees sse_decode_rev_swap_fees(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_percentage = sse_decode_f_64(deserializer);
    var var_minerFees = sse_decode_miner_fees(deserializer);
    return RevSwapFees(percentage: var_percentage, minerFees: var_minerFees);
  }

  @protected
  ReverseFeesAndLimits sse_decode_reverse_fees_and_limits(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_btcLimits = sse_decode_swap_limits(deserializer);
    var var_lbtcLimits = sse_decode_swap_limits(deserializer);
    var var_btcFees = sse_decode_rev_swap_fees(deserializer);
    var var_lbtcFees = sse_decode_rev_swap_fees(deserializer);
    return ReverseFeesAndLimits(
        btcLimits: var_btcLimits,
        lbtcLimits: var_lbtcLimits,
        btcFees: var_btcFees,
        lbtcFees: var_lbtcFees);
  }

  @protected
  Side sse_decode_side(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return Side.values[inner];
  }

  @protected
  SubSwapFees sse_decode_sub_swap_fees(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_percentage = sse_decode_f_64(deserializer);
    var var_minerFees = sse_decode_u_64(deserializer);
    return SubSwapFees(percentage: var_percentage, minerFees: var_minerFees);
  }

  @protected
  SubmarineFeesAndLimits sse_decode_submarine_fees_and_limits(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_btcLimits = sse_decode_swap_limits(deserializer);
    var var_lbtcLimits = sse_decode_swap_limits(deserializer);
    var var_btcFees = sse_decode_sub_swap_fees(deserializer);
    var var_lbtcFees = sse_decode_sub_swap_fees(deserializer);
    return SubmarineFeesAndLimits(
        btcLimits: var_btcLimits,
        lbtcLimits: var_lbtcLimits,
        btcFees: var_btcFees,
        lbtcFees: var_lbtcFees);
  }

  @protected
  SwapLimits sse_decode_swap_limits(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_minimal = sse_decode_u_64(deserializer);
    var var_maximal = sse_decode_u_64(deserializer);
    return SwapLimits(minimal: var_minimal, maximal: var_maximal);
  }

  @protected
  SwapTxKind sse_decode_swap_tx_kind(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return SwapTxKind.values[inner];
  }

  @protected
  SwapType sse_decode_swap_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return SwapType.values[inner];
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  bool cst_encode_bool(bool raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_chain(Chain raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_chain_swap_direction(ChainSwapDirection raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  double cst_encode_f_64(double raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_i_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_side(Side raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_swap_tx_kind(SwapTxKind raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_swap_type(SwapType raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return cst_encode_i_32(raw.index);
  }

  @protected
  int cst_encode_u_32(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  int cst_encode_u_8(int raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void cst_encode_unit(void raw) {
    // Codec=Cst (C-struct based), see doc to use other codecs
    return raw;
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_boltz_error(BoltzError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.kind, serializer);
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_btc_ln_swap(
      BtcLnSwap self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_btc_ln_swap(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_btc_swap_script_str(
      BtcSwapScriptStr self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_btc_swap_script_str(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_chain_swap(
      ChainSwap self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_chain_swap(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_fees(Fees self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_fees(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_key_pair(KeyPair self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_key_pair(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_l_btc_swap_script_str(
      LBtcSwapScriptStr self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_l_btc_swap_script_str(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_lbtc_ln_swap(
      LbtcLnSwap self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_lbtc_ln_swap(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_pre_image(
      PreImage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_pre_image(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_side(Side self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_side(self, serializer);
  }

  @protected
  void sse_encode_btc_ln_swap(BtcLnSwap self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_swap_type(self.kind, serializer);
    sse_encode_chain(self.network, serializer);
    sse_encode_key_pair(self.keys, serializer);
    sse_encode_u_64(self.keyIndex, serializer);
    sse_encode_pre_image(self.preimage, serializer);
    sse_encode_btc_swap_script_str(self.swapScript, serializer);
    sse_encode_String(self.invoice, serializer);
    sse_encode_String(self.scriptAddress, serializer);
    sse_encode_u_64(self.outAmount, serializer);
    sse_encode_String(self.electrumUrl, serializer);
    sse_encode_String(self.boltzUrl, serializer);
    sse_encode_opt_String(self.referralId, serializer);
  }

  @protected
  void sse_encode_btc_swap_script_str(
      BtcSwapScriptStr self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_swap_type(self.swapType, serializer);
    sse_encode_opt_String(self.fundingAddrs, serializer);
    sse_encode_String(self.hashlock, serializer);
    sse_encode_String(self.receiverPubkey, serializer);
    sse_encode_u_32(self.locktime, serializer);
    sse_encode_String(self.senderPubkey, serializer);
    sse_encode_opt_box_autoadd_side(self.side, serializer);
  }

  @protected
  void sse_encode_chain(Chain self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_chain_fees_and_limits(
      ChainFeesAndLimits self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_swap_limits(self.btcLimits, serializer);
    sse_encode_swap_limits(self.lbtcLimits, serializer);
    sse_encode_chain_swap_fees(self.btcFees, serializer);
    sse_encode_chain_swap_fees(self.lbtcFees, serializer);
  }

  @protected
  void sse_encode_chain_swap(ChainSwap self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_bool(self.isTestnet, serializer);
    sse_encode_chain_swap_direction(self.direction, serializer);
    sse_encode_key_pair(self.refundKeys, serializer);
    sse_encode_u_64(self.refundIndex, serializer);
    sse_encode_key_pair(self.claimKeys, serializer);
    sse_encode_u_64(self.claimIndex, serializer);
    sse_encode_pre_image(self.preimage, serializer);
    sse_encode_btc_swap_script_str(self.btcScriptStr, serializer);
    sse_encode_l_btc_swap_script_str(self.lbtcScriptStr, serializer);
    sse_encode_String(self.scriptAddress, serializer);
    sse_encode_u_64(self.outAmount, serializer);
    sse_encode_String(self.btcElectrumUrl, serializer);
    sse_encode_String(self.lbtcElectrumUrl, serializer);
    sse_encode_String(self.boltzUrl, serializer);
    sse_encode_opt_String(self.referralId, serializer);
    sse_encode_String(self.blindingKey, serializer);
  }

  @protected
  void sse_encode_chain_swap_direction(
      ChainSwapDirection self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_chain_swap_fees(
      ChainSwapFees self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self.percentage, serializer);
    sse_encode_u_64(self.userLockup, serializer);
    sse_encode_u_64(self.userClaim, serializer);
    sse_encode_u_64(self.server, serializer);
  }

  @protected
  void sse_encode_decoded_invoice(
      DecodedInvoice self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.msats, serializer);
    sse_encode_u_64(self.expiry, serializer);
    sse_encode_u_64(self.expiresIn, serializer);
    sse_encode_u_64(self.expiresAt, serializer);
    sse_encode_bool(self.isExpired, serializer);
    sse_encode_String(self.network, serializer);
    sse_encode_u_64(self.cltvExpDelta, serializer);
    sse_encode_opt_String(self.bip21, serializer);
    sse_encode_String(self.preimageHash, serializer);
  }

  @protected
  void sse_encode_f_64(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat64(self);
  }

  @protected
  void sse_encode_fees(Fees self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.boltzUrl, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_key_pair(KeyPair self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.secretKey, serializer);
    sse_encode_String(self.publicKey, serializer);
  }

  @protected
  void sse_encode_l_btc_swap_script_str(
      LBtcSwapScriptStr self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_swap_type(self.swapType, serializer);
    sse_encode_opt_String(self.fundingAddrs, serializer);
    sse_encode_String(self.hashlock, serializer);
    sse_encode_String(self.receiverPubkey, serializer);
    sse_encode_u_32(self.locktime, serializer);
    sse_encode_String(self.senderPubkey, serializer);
    sse_encode_String(self.blindingKey, serializer);
    sse_encode_opt_box_autoadd_side(self.side, serializer);
  }

  @protected
  void sse_encode_lbtc_ln_swap(LbtcLnSwap self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_swap_type(self.kind, serializer);
    sse_encode_chain(self.network, serializer);
    sse_encode_key_pair(self.keys, serializer);
    sse_encode_u_64(self.keyIndex, serializer);
    sse_encode_pre_image(self.preimage, serializer);
    sse_encode_l_btc_swap_script_str(self.swapScript, serializer);
    sse_encode_String(self.invoice, serializer);
    sse_encode_u_64(self.outAmount, serializer);
    sse_encode_String(self.scriptAddress, serializer);
    sse_encode_String(self.blindingKey, serializer);
    sse_encode_String(self.electrumUrl, serializer);
    sse_encode_String(self.boltzUrl, serializer);
    sse_encode_opt_String(self.referralId, serializer);
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_miner_fees(MinerFees self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.lockup, serializer);
    sse_encode_u_64(self.claim, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_side(Side? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_side(self, serializer);
    }
  }

  @protected
  void sse_encode_pre_image(PreImage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.value, serializer);
    sse_encode_String(self.sha256, serializer);
    sse_encode_String(self.hash160, serializer);
  }

  @protected
  void sse_encode_rev_swap_fees(RevSwapFees self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self.percentage, serializer);
    sse_encode_miner_fees(self.minerFees, serializer);
  }

  @protected
  void sse_encode_reverse_fees_and_limits(
      ReverseFeesAndLimits self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_swap_limits(self.btcLimits, serializer);
    sse_encode_swap_limits(self.lbtcLimits, serializer);
    sse_encode_rev_swap_fees(self.btcFees, serializer);
    sse_encode_rev_swap_fees(self.lbtcFees, serializer);
  }

  @protected
  void sse_encode_side(Side self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_sub_swap_fees(SubSwapFees self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_64(self.percentage, serializer);
    sse_encode_u_64(self.minerFees, serializer);
  }

  @protected
  void sse_encode_submarine_fees_and_limits(
      SubmarineFeesAndLimits self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_swap_limits(self.btcLimits, serializer);
    sse_encode_swap_limits(self.lbtcLimits, serializer);
    sse_encode_sub_swap_fees(self.btcFees, serializer);
    sse_encode_sub_swap_fees(self.lbtcFees, serializer);
  }

  @protected
  void sse_encode_swap_limits(SwapLimits self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.minimal, serializer);
    sse_encode_u_64(self.maximal, serializer);
  }

  @protected
  void sse_encode_swap_tx_kind(SwapTxKind self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_swap_type(SwapType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }
}
