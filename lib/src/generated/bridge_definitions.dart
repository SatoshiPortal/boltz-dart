// AUTO GENERATED FILE, DO NOT EDIT.
// Generated by `flutter_rust_bridge`@ 1.82.6.
// ignore_for_file: non_constant_identifier_names, unused_element, duplicate_ignore, directives_ordering, curly_braces_in_flow_control_structures, unnecessary_lambdas, slash_for_doc_comments, prefer_const_literals_to_create_immutables, implicit_dynamic_list_literal, duplicate_import, unused_import, unnecessary_import, prefer_single_quotes, prefer_const_constructors, use_super_parameters, always_use_package_imports, annotate_overrides, invalid_use_of_protected_member, constant_identifier_names, invalid_use_of_internal_member, prefer_is_empty, unnecessary_const

import 'dart:convert';
import 'dart:async';
import 'package:meta/meta.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge.dart';
import 'package:uuid/uuid.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;

part 'bridge_definitions.freezed.dart';

abstract class BoltzDart {
  Future<AllFees> swapFeesStaticMethodApi(
      {required String boltzUrl, required int outputAmount, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSwapFeesStaticMethodApiConstMeta;

  Future<BtcLnSwap> newBtcLnSubmarineStaticMethodApi(
      {required String mnemonic,
      required int index,
      required String invoice,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      required String pairHash,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNewBtcLnSubmarineStaticMethodApiConstMeta;

  Future<BtcLnSwap> newBtcLnReverseStaticMethodApi(
      {required String mnemonic,
      required int index,
      required int outAmount,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      required String pairHash,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNewBtcLnReverseStaticMethodApiConstMeta;

  Future<int> btcLnTxSizeStaticMethodApi(
      {required BtcLnSwap swap, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kBtcLnTxSizeStaticMethodApiConstMeta;

  Future<String> btcLnReverseClaimStaticMethodApi(
      {required BtcLnSwap swap,
      required String outAddress,
      required int absFee,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kBtcLnReverseClaimStaticMethodApiConstMeta;

  Future<String> btcLnSubmarineRefundStaticMethodApi(
      {required BtcLnSwap swap,
      required String outAddress,
      required int absFee,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kBtcLnSubmarineRefundStaticMethodApiConstMeta;

  Future<LbtcLnSwap> newLbtcLnSubmarineStaticMethodApi(
      {required String mnemonic,
      required int index,
      required String invoice,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      required String pairHash,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kNewLbtcLnSubmarineStaticMethodApiConstMeta;

  Future<LbtcLnSwap> newLbtcLnReverseStaticMethodApi(
      {required String mnemonic,
      required int index,
      required int outAmount,
      required Chain network,
      required String electrumUrl,
      required String boltzUrl,
      required String pairHash,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta get kNewLbtcLnReverseStaticMethodApiConstMeta;

  Future<int> lbtcLnTxSizeStaticMethodApi(
      {required LbtcLnSwap swap, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kLbtcLnTxSizeStaticMethodApiConstMeta;

  Future<String> lbtcLnReverseClaimStaticMethodApi(
      {required LbtcLnSwap swap,
      required String outAddress,
      required int absFee,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kLbtcLnReverseClaimStaticMethodApiConstMeta;

  Future<String> lbtcLnSubmarineRefundStaticMethodApi(
      {required LbtcLnSwap swap,
      required String outAddress,
      required int absFee,
      dynamic hint});

  FlutterRustBridgeTaskConstMeta
      get kLbtcLnSubmarineRefundStaticMethodApiConstMeta;

  Future<String> swapStatusStaticMethodApi(
      {required String boltzUrl, required String id, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kSwapStatusStaticMethodApiConstMeta;

  Future<DecodedInvoice> decodeInvoiceStaticMethodApi(
      {required String invoiceStr, dynamic hint});

  FlutterRustBridgeTaskConstMeta get kDecodeInvoiceStaticMethodApiConstMeta;
}

@freezed
class AllFees with _$AllFees {
  const factory AllFees({
    required Limits btcLimits,
    required Limits lbtcLimits,
    required SubmarineSwapFees btcSubmarine,
    required ReverseSwapFees btcReverse,
    required SubmarineSwapFees lbtcSubmarine,
    required ReverseSwapFees lbtcReverse,
    required String btcPairHash,
    required String lbtcPairHash,
  }) = _AllFees;
}

@freezed
class BoltzError with _$BoltzError implements FrbException {
  const factory BoltzError({
    required String kind,
    required String message,
  }) = _BoltzError;
}

@freezed
class BtcLnSwap with _$BtcLnSwap {
  const factory BtcLnSwap({
    required String id,
    required SwapType kind,
    required Chain network,
    required KeyPair keys,
    required PreImage preimage,
    required String redeemScript,
    required String invoice,
    required String scriptAddress,
    required int outAmount,
    required String electrumUrl,
    required String boltzUrl,
  }) = _BtcLnSwap;
}

enum Chain {
  Testnet,
  LiquidTestnet,
}

class DecodedInvoice {
  final int msats;
  final int expiry;
  final int expiresIn;
  final int expiresAt;
  final bool isExpired;
  final String network;
  final int cltvExpDelta;

  const DecodedInvoice({
    required this.msats,
    required this.expiry,
    required this.expiresIn,
    required this.expiresAt,
    required this.isExpired,
    required this.network,
    required this.cltvExpDelta,
  });
}

@freezed
class KeyPair with _$KeyPair {
  const factory KeyPair({
    required String secretKey,
    required String publicKey,
  }) = _KeyPair;
}

@freezed
class LbtcLnSwap with _$LbtcLnSwap {
  const factory LbtcLnSwap({
    required String id,
    required SwapType kind,
    required Chain network,
    required KeyPair keys,
    required PreImage preimage,
    required String redeemScript,
    required String invoice,
    required int outAmount,
    required String scriptAddress,
    required String blindingKey,
    required String electrumUrl,
    required String boltzUrl,
  }) = _LbtcLnSwap;
}

@freezed
class Limits with _$Limits {
  const factory Limits({
    required int minimal,
    required int maximal,
  }) = _Limits;
}

@freezed
class PreImage with _$PreImage {
  const factory PreImage({
    required String value,
    required String sha256,
    required String hash160,
  }) = _PreImage;
}

@freezed
class ReverseSwapFees with _$ReverseSwapFees {
  const factory ReverseSwapFees({
    required int boltzFees,
    required int lockupFees,
    required int claimFeesEstimate,
  }) = _ReverseSwapFees;
}

@freezed
class SubmarineSwapFees with _$SubmarineSwapFees {
  const factory SubmarineSwapFees({
    required int boltzFees,
    required int claimFees,
    required int lockupFeesEstimate,
  }) = _SubmarineSwapFees;
}

enum SwapType {
  Submarine,
  Reverse,
}
