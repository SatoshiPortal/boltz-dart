// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'bridge_definitions.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AllFees {
  Limits get btcLimits => throw _privateConstructorUsedError;
  Limits get lbtcLimits => throw _privateConstructorUsedError;
  SubmarineSwapFees get btcSubmarine => throw _privateConstructorUsedError;
  ReverseSwapFees get btcReverse => throw _privateConstructorUsedError;
  SubmarineSwapFees get lbtcSubmarine => throw _privateConstructorUsedError;
  ReverseSwapFees get lbtcReverse => throw _privateConstructorUsedError;
  String get btcPairHash => throw _privateConstructorUsedError;
  String get lbtcPairHash => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AllFeesCopyWith<AllFees> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AllFeesCopyWith<$Res> {
  factory $AllFeesCopyWith(AllFees value, $Res Function(AllFees) then) =
      _$AllFeesCopyWithImpl<$Res, AllFees>;
  @useResult
  $Res call(
      {Limits btcLimits,
      Limits lbtcLimits,
      SubmarineSwapFees btcSubmarine,
      ReverseSwapFees btcReverse,
      SubmarineSwapFees lbtcSubmarine,
      ReverseSwapFees lbtcReverse,
      String btcPairHash,
      String lbtcPairHash});

  $LimitsCopyWith<$Res> get btcLimits;
  $LimitsCopyWith<$Res> get lbtcLimits;
  $SubmarineSwapFeesCopyWith<$Res> get btcSubmarine;
  $ReverseSwapFeesCopyWith<$Res> get btcReverse;
  $SubmarineSwapFeesCopyWith<$Res> get lbtcSubmarine;
  $ReverseSwapFeesCopyWith<$Res> get lbtcReverse;
}

/// @nodoc
class _$AllFeesCopyWithImpl<$Res, $Val extends AllFees>
    implements $AllFeesCopyWith<$Res> {
  _$AllFeesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? btcLimits = null,
    Object? lbtcLimits = null,
    Object? btcSubmarine = null,
    Object? btcReverse = null,
    Object? lbtcSubmarine = null,
    Object? lbtcReverse = null,
    Object? btcPairHash = null,
    Object? lbtcPairHash = null,
  }) {
    return _then(_value.copyWith(
      btcLimits: null == btcLimits
          ? _value.btcLimits
          : btcLimits // ignore: cast_nullable_to_non_nullable
              as Limits,
      lbtcLimits: null == lbtcLimits
          ? _value.lbtcLimits
          : lbtcLimits // ignore: cast_nullable_to_non_nullable
              as Limits,
      btcSubmarine: null == btcSubmarine
          ? _value.btcSubmarine
          : btcSubmarine // ignore: cast_nullable_to_non_nullable
              as SubmarineSwapFees,
      btcReverse: null == btcReverse
          ? _value.btcReverse
          : btcReverse // ignore: cast_nullable_to_non_nullable
              as ReverseSwapFees,
      lbtcSubmarine: null == lbtcSubmarine
          ? _value.lbtcSubmarine
          : lbtcSubmarine // ignore: cast_nullable_to_non_nullable
              as SubmarineSwapFees,
      lbtcReverse: null == lbtcReverse
          ? _value.lbtcReverse
          : lbtcReverse // ignore: cast_nullable_to_non_nullable
              as ReverseSwapFees,
      btcPairHash: null == btcPairHash
          ? _value.btcPairHash
          : btcPairHash // ignore: cast_nullable_to_non_nullable
              as String,
      lbtcPairHash: null == lbtcPairHash
          ? _value.lbtcPairHash
          : lbtcPairHash // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $LimitsCopyWith<$Res> get btcLimits {
    return $LimitsCopyWith<$Res>(_value.btcLimits, (value) {
      return _then(_value.copyWith(btcLimits: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $LimitsCopyWith<$Res> get lbtcLimits {
    return $LimitsCopyWith<$Res>(_value.lbtcLimits, (value) {
      return _then(_value.copyWith(lbtcLimits: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SubmarineSwapFeesCopyWith<$Res> get btcSubmarine {
    return $SubmarineSwapFeesCopyWith<$Res>(_value.btcSubmarine, (value) {
      return _then(_value.copyWith(btcSubmarine: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReverseSwapFeesCopyWith<$Res> get btcReverse {
    return $ReverseSwapFeesCopyWith<$Res>(_value.btcReverse, (value) {
      return _then(_value.copyWith(btcReverse: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $SubmarineSwapFeesCopyWith<$Res> get lbtcSubmarine {
    return $SubmarineSwapFeesCopyWith<$Res>(_value.lbtcSubmarine, (value) {
      return _then(_value.copyWith(lbtcSubmarine: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $ReverseSwapFeesCopyWith<$Res> get lbtcReverse {
    return $ReverseSwapFeesCopyWith<$Res>(_value.lbtcReverse, (value) {
      return _then(_value.copyWith(lbtcReverse: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AllFeesImplCopyWith<$Res> implements $AllFeesCopyWith<$Res> {
  factory _$$AllFeesImplCopyWith(
          _$AllFeesImpl value, $Res Function(_$AllFeesImpl) then) =
      __$$AllFeesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Limits btcLimits,
      Limits lbtcLimits,
      SubmarineSwapFees btcSubmarine,
      ReverseSwapFees btcReverse,
      SubmarineSwapFees lbtcSubmarine,
      ReverseSwapFees lbtcReverse,
      String btcPairHash,
      String lbtcPairHash});

  @override
  $LimitsCopyWith<$Res> get btcLimits;
  @override
  $LimitsCopyWith<$Res> get lbtcLimits;
  @override
  $SubmarineSwapFeesCopyWith<$Res> get btcSubmarine;
  @override
  $ReverseSwapFeesCopyWith<$Res> get btcReverse;
  @override
  $SubmarineSwapFeesCopyWith<$Res> get lbtcSubmarine;
  @override
  $ReverseSwapFeesCopyWith<$Res> get lbtcReverse;
}

/// @nodoc
class __$$AllFeesImplCopyWithImpl<$Res>
    extends _$AllFeesCopyWithImpl<$Res, _$AllFeesImpl>
    implements _$$AllFeesImplCopyWith<$Res> {
  __$$AllFeesImplCopyWithImpl(
      _$AllFeesImpl _value, $Res Function(_$AllFeesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? btcLimits = null,
    Object? lbtcLimits = null,
    Object? btcSubmarine = null,
    Object? btcReverse = null,
    Object? lbtcSubmarine = null,
    Object? lbtcReverse = null,
    Object? btcPairHash = null,
    Object? lbtcPairHash = null,
  }) {
    return _then(_$AllFeesImpl(
      btcLimits: null == btcLimits
          ? _value.btcLimits
          : btcLimits // ignore: cast_nullable_to_non_nullable
              as Limits,
      lbtcLimits: null == lbtcLimits
          ? _value.lbtcLimits
          : lbtcLimits // ignore: cast_nullable_to_non_nullable
              as Limits,
      btcSubmarine: null == btcSubmarine
          ? _value.btcSubmarine
          : btcSubmarine // ignore: cast_nullable_to_non_nullable
              as SubmarineSwapFees,
      btcReverse: null == btcReverse
          ? _value.btcReverse
          : btcReverse // ignore: cast_nullable_to_non_nullable
              as ReverseSwapFees,
      lbtcSubmarine: null == lbtcSubmarine
          ? _value.lbtcSubmarine
          : lbtcSubmarine // ignore: cast_nullable_to_non_nullable
              as SubmarineSwapFees,
      lbtcReverse: null == lbtcReverse
          ? _value.lbtcReverse
          : lbtcReverse // ignore: cast_nullable_to_non_nullable
              as ReverseSwapFees,
      btcPairHash: null == btcPairHash
          ? _value.btcPairHash
          : btcPairHash // ignore: cast_nullable_to_non_nullable
              as String,
      lbtcPairHash: null == lbtcPairHash
          ? _value.lbtcPairHash
          : lbtcPairHash // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AllFeesImpl implements _AllFees {
  const _$AllFeesImpl(
      {required this.btcLimits,
      required this.lbtcLimits,
      required this.btcSubmarine,
      required this.btcReverse,
      required this.lbtcSubmarine,
      required this.lbtcReverse,
      required this.btcPairHash,
      required this.lbtcPairHash});

  @override
  final Limits btcLimits;
  @override
  final Limits lbtcLimits;
  @override
  final SubmarineSwapFees btcSubmarine;
  @override
  final ReverseSwapFees btcReverse;
  @override
  final SubmarineSwapFees lbtcSubmarine;
  @override
  final ReverseSwapFees lbtcReverse;
  @override
  final String btcPairHash;
  @override
  final String lbtcPairHash;

  @override
  String toString() {
    return 'AllFees(btcLimits: $btcLimits, lbtcLimits: $lbtcLimits, btcSubmarine: $btcSubmarine, btcReverse: $btcReverse, lbtcSubmarine: $lbtcSubmarine, lbtcReverse: $lbtcReverse, btcPairHash: $btcPairHash, lbtcPairHash: $lbtcPairHash)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AllFeesImpl &&
            (identical(other.btcLimits, btcLimits) ||
                other.btcLimits == btcLimits) &&
            (identical(other.lbtcLimits, lbtcLimits) ||
                other.lbtcLimits == lbtcLimits) &&
            (identical(other.btcSubmarine, btcSubmarine) ||
                other.btcSubmarine == btcSubmarine) &&
            (identical(other.btcReverse, btcReverse) ||
                other.btcReverse == btcReverse) &&
            (identical(other.lbtcSubmarine, lbtcSubmarine) ||
                other.lbtcSubmarine == lbtcSubmarine) &&
            (identical(other.lbtcReverse, lbtcReverse) ||
                other.lbtcReverse == lbtcReverse) &&
            (identical(other.btcPairHash, btcPairHash) ||
                other.btcPairHash == btcPairHash) &&
            (identical(other.lbtcPairHash, lbtcPairHash) ||
                other.lbtcPairHash == lbtcPairHash));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      btcLimits,
      lbtcLimits,
      btcSubmarine,
      btcReverse,
      lbtcSubmarine,
      lbtcReverse,
      btcPairHash,
      lbtcPairHash);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AllFeesImplCopyWith<_$AllFeesImpl> get copyWith =>
      __$$AllFeesImplCopyWithImpl<_$AllFeesImpl>(this, _$identity);
}

abstract class _AllFees implements AllFees {
  const factory _AllFees(
      {required final Limits btcLimits,
      required final Limits lbtcLimits,
      required final SubmarineSwapFees btcSubmarine,
      required final ReverseSwapFees btcReverse,
      required final SubmarineSwapFees lbtcSubmarine,
      required final ReverseSwapFees lbtcReverse,
      required final String btcPairHash,
      required final String lbtcPairHash}) = _$AllFeesImpl;

  @override
  Limits get btcLimits;
  @override
  Limits get lbtcLimits;
  @override
  SubmarineSwapFees get btcSubmarine;
  @override
  ReverseSwapFees get btcReverse;
  @override
  SubmarineSwapFees get lbtcSubmarine;
  @override
  ReverseSwapFees get lbtcReverse;
  @override
  String get btcPairHash;
  @override
  String get lbtcPairHash;
  @override
  @JsonKey(ignore: true)
  _$$AllFeesImplCopyWith<_$AllFeesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BoltzError {
  String get kind => throw _privateConstructorUsedError;
  String get message => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BoltzErrorCopyWith<BoltzError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BoltzErrorCopyWith<$Res> {
  factory $BoltzErrorCopyWith(
          BoltzError value, $Res Function(BoltzError) then) =
      _$BoltzErrorCopyWithImpl<$Res, BoltzError>;
  @useResult
  $Res call({String kind, String message});
}

/// @nodoc
class _$BoltzErrorCopyWithImpl<$Res, $Val extends BoltzError>
    implements $BoltzErrorCopyWith<$Res> {
  _$BoltzErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? kind = null,
    Object? message = null,
  }) {
    return _then(_value.copyWith(
      kind: null == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as String,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BoltzErrorImplCopyWith<$Res>
    implements $BoltzErrorCopyWith<$Res> {
  factory _$$BoltzErrorImplCopyWith(
          _$BoltzErrorImpl value, $Res Function(_$BoltzErrorImpl) then) =
      __$$BoltzErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String kind, String message});
}

/// @nodoc
class __$$BoltzErrorImplCopyWithImpl<$Res>
    extends _$BoltzErrorCopyWithImpl<$Res, _$BoltzErrorImpl>
    implements _$$BoltzErrorImplCopyWith<$Res> {
  __$$BoltzErrorImplCopyWithImpl(
      _$BoltzErrorImpl _value, $Res Function(_$BoltzErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? kind = null,
    Object? message = null,
  }) {
    return _then(_$BoltzErrorImpl(
      kind: null == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as String,
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$BoltzErrorImpl implements _BoltzError {
  const _$BoltzErrorImpl({required this.kind, required this.message});

  @override
  final String kind;
  @override
  final String message;

  @override
  String toString() {
    return 'BoltzError(kind: $kind, message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BoltzErrorImpl &&
            (identical(other.kind, kind) || other.kind == kind) &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, kind, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BoltzErrorImplCopyWith<_$BoltzErrorImpl> get copyWith =>
      __$$BoltzErrorImplCopyWithImpl<_$BoltzErrorImpl>(this, _$identity);
}

abstract class _BoltzError implements BoltzError {
  const factory _BoltzError(
      {required final String kind,
      required final String message}) = _$BoltzErrorImpl;

  @override
  String get kind;
  @override
  String get message;
  @override
  @JsonKey(ignore: true)
  _$$BoltzErrorImplCopyWith<_$BoltzErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

BtcLnSwap _$BtcLnSwapFromJson(Map<String, dynamic> json) {
  return _BtcLnSwap.fromJson(json);
}

/// @nodoc
mixin _$BtcLnSwap {
  String get id => throw _privateConstructorUsedError;
  SwapType get kind => throw _privateConstructorUsedError;
  Chain get network => throw _privateConstructorUsedError;
  KeyPair get keys => throw _privateConstructorUsedError;
  PreImage get preimage => throw _privateConstructorUsedError;
  String get redeemScript => throw _privateConstructorUsedError;
  String get invoice => throw _privateConstructorUsedError;
  String get scriptAddress => throw _privateConstructorUsedError;
  int get outAmount => throw _privateConstructorUsedError;
  String get electrumUrl => throw _privateConstructorUsedError;
  String get boltzUrl => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BtcLnSwapCopyWith<BtcLnSwap> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BtcLnSwapCopyWith<$Res> {
  factory $BtcLnSwapCopyWith(BtcLnSwap value, $Res Function(BtcLnSwap) then) =
      _$BtcLnSwapCopyWithImpl<$Res, BtcLnSwap>;
  @useResult
  $Res call(
      {String id,
      SwapType kind,
      Chain network,
      KeyPair keys,
      PreImage preimage,
      String redeemScript,
      String invoice,
      String scriptAddress,
      int outAmount,
      String electrumUrl,
      String boltzUrl});

  $KeyPairCopyWith<$Res> get keys;
  $PreImageCopyWith<$Res> get preimage;
}

/// @nodoc
class _$BtcLnSwapCopyWithImpl<$Res, $Val extends BtcLnSwap>
    implements $BtcLnSwapCopyWith<$Res> {
  _$BtcLnSwapCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? kind = null,
    Object? network = null,
    Object? keys = null,
    Object? preimage = null,
    Object? redeemScript = null,
    Object? invoice = null,
    Object? scriptAddress = null,
    Object? outAmount = null,
    Object? electrumUrl = null,
    Object? boltzUrl = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      kind: null == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as SwapType,
      network: null == network
          ? _value.network
          : network // ignore: cast_nullable_to_non_nullable
              as Chain,
      keys: null == keys
          ? _value.keys
          : keys // ignore: cast_nullable_to_non_nullable
              as KeyPair,
      preimage: null == preimage
          ? _value.preimage
          : preimage // ignore: cast_nullable_to_non_nullable
              as PreImage,
      redeemScript: null == redeemScript
          ? _value.redeemScript
          : redeemScript // ignore: cast_nullable_to_non_nullable
              as String,
      invoice: null == invoice
          ? _value.invoice
          : invoice // ignore: cast_nullable_to_non_nullable
              as String,
      scriptAddress: null == scriptAddress
          ? _value.scriptAddress
          : scriptAddress // ignore: cast_nullable_to_non_nullable
              as String,
      outAmount: null == outAmount
          ? _value.outAmount
          : outAmount // ignore: cast_nullable_to_non_nullable
              as int,
      electrumUrl: null == electrumUrl
          ? _value.electrumUrl
          : electrumUrl // ignore: cast_nullable_to_non_nullable
              as String,
      boltzUrl: null == boltzUrl
          ? _value.boltzUrl
          : boltzUrl // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $KeyPairCopyWith<$Res> get keys {
    return $KeyPairCopyWith<$Res>(_value.keys, (value) {
      return _then(_value.copyWith(keys: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PreImageCopyWith<$Res> get preimage {
    return $PreImageCopyWith<$Res>(_value.preimage, (value) {
      return _then(_value.copyWith(preimage: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$BtcLnSwapImplCopyWith<$Res>
    implements $BtcLnSwapCopyWith<$Res> {
  factory _$$BtcLnSwapImplCopyWith(
          _$BtcLnSwapImpl value, $Res Function(_$BtcLnSwapImpl) then) =
      __$$BtcLnSwapImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      SwapType kind,
      Chain network,
      KeyPair keys,
      PreImage preimage,
      String redeemScript,
      String invoice,
      String scriptAddress,
      int outAmount,
      String electrumUrl,
      String boltzUrl});

  @override
  $KeyPairCopyWith<$Res> get keys;
  @override
  $PreImageCopyWith<$Res> get preimage;
}

/// @nodoc
class __$$BtcLnSwapImplCopyWithImpl<$Res>
    extends _$BtcLnSwapCopyWithImpl<$Res, _$BtcLnSwapImpl>
    implements _$$BtcLnSwapImplCopyWith<$Res> {
  __$$BtcLnSwapImplCopyWithImpl(
      _$BtcLnSwapImpl _value, $Res Function(_$BtcLnSwapImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? kind = null,
    Object? network = null,
    Object? keys = null,
    Object? preimage = null,
    Object? redeemScript = null,
    Object? invoice = null,
    Object? scriptAddress = null,
    Object? outAmount = null,
    Object? electrumUrl = null,
    Object? boltzUrl = null,
  }) {
    return _then(_$BtcLnSwapImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      kind: null == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as SwapType,
      network: null == network
          ? _value.network
          : network // ignore: cast_nullable_to_non_nullable
              as Chain,
      keys: null == keys
          ? _value.keys
          : keys // ignore: cast_nullable_to_non_nullable
              as KeyPair,
      preimage: null == preimage
          ? _value.preimage
          : preimage // ignore: cast_nullable_to_non_nullable
              as PreImage,
      redeemScript: null == redeemScript
          ? _value.redeemScript
          : redeemScript // ignore: cast_nullable_to_non_nullable
              as String,
      invoice: null == invoice
          ? _value.invoice
          : invoice // ignore: cast_nullable_to_non_nullable
              as String,
      scriptAddress: null == scriptAddress
          ? _value.scriptAddress
          : scriptAddress // ignore: cast_nullable_to_non_nullable
              as String,
      outAmount: null == outAmount
          ? _value.outAmount
          : outAmount // ignore: cast_nullable_to_non_nullable
              as int,
      electrumUrl: null == electrumUrl
          ? _value.electrumUrl
          : electrumUrl // ignore: cast_nullable_to_non_nullable
              as String,
      boltzUrl: null == boltzUrl
          ? _value.boltzUrl
          : boltzUrl // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$BtcLnSwapImpl implements _BtcLnSwap {
  const _$BtcLnSwapImpl(
      {required this.id,
      required this.kind,
      required this.network,
      required this.keys,
      required this.preimage,
      required this.redeemScript,
      required this.invoice,
      required this.scriptAddress,
      required this.outAmount,
      required this.electrumUrl,
      required this.boltzUrl});

  factory _$BtcLnSwapImpl.fromJson(Map<String, dynamic> json) =>
      _$$BtcLnSwapImplFromJson(json);

  @override
  final String id;
  @override
  final SwapType kind;
  @override
  final Chain network;
  @override
  final KeyPair keys;
  @override
  final PreImage preimage;
  @override
  final String redeemScript;
  @override
  final String invoice;
  @override
  final String scriptAddress;
  @override
  final int outAmount;
  @override
  final String electrumUrl;
  @override
  final String boltzUrl;

  @override
  String toString() {
    return 'BtcLnSwap(id: $id, kind: $kind, network: $network, keys: $keys, preimage: $preimage, redeemScript: $redeemScript, invoice: $invoice, scriptAddress: $scriptAddress, outAmount: $outAmount, electrumUrl: $electrumUrl, boltzUrl: $boltzUrl)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BtcLnSwapImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.kind, kind) || other.kind == kind) &&
            (identical(other.network, network) || other.network == network) &&
            (identical(other.keys, keys) || other.keys == keys) &&
            (identical(other.preimage, preimage) ||
                other.preimage == preimage) &&
            (identical(other.redeemScript, redeemScript) ||
                other.redeemScript == redeemScript) &&
            (identical(other.invoice, invoice) || other.invoice == invoice) &&
            (identical(other.scriptAddress, scriptAddress) ||
                other.scriptAddress == scriptAddress) &&
            (identical(other.outAmount, outAmount) ||
                other.outAmount == outAmount) &&
            (identical(other.electrumUrl, electrumUrl) ||
                other.electrumUrl == electrumUrl) &&
            (identical(other.boltzUrl, boltzUrl) ||
                other.boltzUrl == boltzUrl));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      kind,
      network,
      keys,
      preimage,
      redeemScript,
      invoice,
      scriptAddress,
      outAmount,
      electrumUrl,
      boltzUrl);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BtcLnSwapImplCopyWith<_$BtcLnSwapImpl> get copyWith =>
      __$$BtcLnSwapImplCopyWithImpl<_$BtcLnSwapImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BtcLnSwapImplToJson(
      this,
    );
  }
}

abstract class _BtcLnSwap implements BtcLnSwap {
  const factory _BtcLnSwap(
      {required final String id,
      required final SwapType kind,
      required final Chain network,
      required final KeyPair keys,
      required final PreImage preimage,
      required final String redeemScript,
      required final String invoice,
      required final String scriptAddress,
      required final int outAmount,
      required final String electrumUrl,
      required final String boltzUrl}) = _$BtcLnSwapImpl;

  factory _BtcLnSwap.fromJson(Map<String, dynamic> json) =
      _$BtcLnSwapImpl.fromJson;

  @override
  String get id;
  @override
  SwapType get kind;
  @override
  Chain get network;
  @override
  KeyPair get keys;
  @override
  PreImage get preimage;
  @override
  String get redeemScript;
  @override
  String get invoice;
  @override
  String get scriptAddress;
  @override
  int get outAmount;
  @override
  String get electrumUrl;
  @override
  String get boltzUrl;
  @override
  @JsonKey(ignore: true)
  _$$BtcLnSwapImplCopyWith<_$BtcLnSwapImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

KeyPair _$KeyPairFromJson(Map<String, dynamic> json) {
  return _KeyPair.fromJson(json);
}

/// @nodoc
mixin _$KeyPair {
  String get secretKey => throw _privateConstructorUsedError;
  String get publicKey => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $KeyPairCopyWith<KeyPair> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $KeyPairCopyWith<$Res> {
  factory $KeyPairCopyWith(KeyPair value, $Res Function(KeyPair) then) =
      _$KeyPairCopyWithImpl<$Res, KeyPair>;
  @useResult
  $Res call({String secretKey, String publicKey});
}

/// @nodoc
class _$KeyPairCopyWithImpl<$Res, $Val extends KeyPair>
    implements $KeyPairCopyWith<$Res> {
  _$KeyPairCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? secretKey = null,
    Object? publicKey = null,
  }) {
    return _then(_value.copyWith(
      secretKey: null == secretKey
          ? _value.secretKey
          : secretKey // ignore: cast_nullable_to_non_nullable
              as String,
      publicKey: null == publicKey
          ? _value.publicKey
          : publicKey // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$KeyPairImplCopyWith<$Res> implements $KeyPairCopyWith<$Res> {
  factory _$$KeyPairImplCopyWith(
          _$KeyPairImpl value, $Res Function(_$KeyPairImpl) then) =
      __$$KeyPairImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String secretKey, String publicKey});
}

/// @nodoc
class __$$KeyPairImplCopyWithImpl<$Res>
    extends _$KeyPairCopyWithImpl<$Res, _$KeyPairImpl>
    implements _$$KeyPairImplCopyWith<$Res> {
  __$$KeyPairImplCopyWithImpl(
      _$KeyPairImpl _value, $Res Function(_$KeyPairImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? secretKey = null,
    Object? publicKey = null,
  }) {
    return _then(_$KeyPairImpl(
      secretKey: null == secretKey
          ? _value.secretKey
          : secretKey // ignore: cast_nullable_to_non_nullable
              as String,
      publicKey: null == publicKey
          ? _value.publicKey
          : publicKey // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$KeyPairImpl implements _KeyPair {
  const _$KeyPairImpl({required this.secretKey, required this.publicKey});

  factory _$KeyPairImpl.fromJson(Map<String, dynamic> json) =>
      _$$KeyPairImplFromJson(json);

  @override
  final String secretKey;
  @override
  final String publicKey;

  @override
  String toString() {
    return 'KeyPair(secretKey: $secretKey, publicKey: $publicKey)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$KeyPairImpl &&
            (identical(other.secretKey, secretKey) ||
                other.secretKey == secretKey) &&
            (identical(other.publicKey, publicKey) ||
                other.publicKey == publicKey));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, secretKey, publicKey);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$KeyPairImplCopyWith<_$KeyPairImpl> get copyWith =>
      __$$KeyPairImplCopyWithImpl<_$KeyPairImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$KeyPairImplToJson(
      this,
    );
  }
}

abstract class _KeyPair implements KeyPair {
  const factory _KeyPair(
      {required final String secretKey,
      required final String publicKey}) = _$KeyPairImpl;

  factory _KeyPair.fromJson(Map<String, dynamic> json) = _$KeyPairImpl.fromJson;

  @override
  String get secretKey;
  @override
  String get publicKey;
  @override
  @JsonKey(ignore: true)
  _$$KeyPairImplCopyWith<_$KeyPairImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

LbtcLnSwap _$LbtcLnSwapFromJson(Map<String, dynamic> json) {
  return _LbtcLnSwap.fromJson(json);
}

/// @nodoc
mixin _$LbtcLnSwap {
  String get id => throw _privateConstructorUsedError;
  SwapType get kind => throw _privateConstructorUsedError;
  Chain get network => throw _privateConstructorUsedError;
  KeyPair get keys => throw _privateConstructorUsedError;
  PreImage get preimage => throw _privateConstructorUsedError;
  String get redeemScript => throw _privateConstructorUsedError;
  String get invoice => throw _privateConstructorUsedError;
  int get outAmount => throw _privateConstructorUsedError;
  String get scriptAddress => throw _privateConstructorUsedError;
  String get blindingKey => throw _privateConstructorUsedError;
  String get electrumUrl => throw _privateConstructorUsedError;
  String get boltzUrl => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LbtcLnSwapCopyWith<LbtcLnSwap> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LbtcLnSwapCopyWith<$Res> {
  factory $LbtcLnSwapCopyWith(
          LbtcLnSwap value, $Res Function(LbtcLnSwap) then) =
      _$LbtcLnSwapCopyWithImpl<$Res, LbtcLnSwap>;
  @useResult
  $Res call(
      {String id,
      SwapType kind,
      Chain network,
      KeyPair keys,
      PreImage preimage,
      String redeemScript,
      String invoice,
      int outAmount,
      String scriptAddress,
      String blindingKey,
      String electrumUrl,
      String boltzUrl});

  $KeyPairCopyWith<$Res> get keys;
  $PreImageCopyWith<$Res> get preimage;
}

/// @nodoc
class _$LbtcLnSwapCopyWithImpl<$Res, $Val extends LbtcLnSwap>
    implements $LbtcLnSwapCopyWith<$Res> {
  _$LbtcLnSwapCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? kind = null,
    Object? network = null,
    Object? keys = null,
    Object? preimage = null,
    Object? redeemScript = null,
    Object? invoice = null,
    Object? outAmount = null,
    Object? scriptAddress = null,
    Object? blindingKey = null,
    Object? electrumUrl = null,
    Object? boltzUrl = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      kind: null == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as SwapType,
      network: null == network
          ? _value.network
          : network // ignore: cast_nullable_to_non_nullable
              as Chain,
      keys: null == keys
          ? _value.keys
          : keys // ignore: cast_nullable_to_non_nullable
              as KeyPair,
      preimage: null == preimage
          ? _value.preimage
          : preimage // ignore: cast_nullable_to_non_nullable
              as PreImage,
      redeemScript: null == redeemScript
          ? _value.redeemScript
          : redeemScript // ignore: cast_nullable_to_non_nullable
              as String,
      invoice: null == invoice
          ? _value.invoice
          : invoice // ignore: cast_nullable_to_non_nullable
              as String,
      outAmount: null == outAmount
          ? _value.outAmount
          : outAmount // ignore: cast_nullable_to_non_nullable
              as int,
      scriptAddress: null == scriptAddress
          ? _value.scriptAddress
          : scriptAddress // ignore: cast_nullable_to_non_nullable
              as String,
      blindingKey: null == blindingKey
          ? _value.blindingKey
          : blindingKey // ignore: cast_nullable_to_non_nullable
              as String,
      electrumUrl: null == electrumUrl
          ? _value.electrumUrl
          : electrumUrl // ignore: cast_nullable_to_non_nullable
              as String,
      boltzUrl: null == boltzUrl
          ? _value.boltzUrl
          : boltzUrl // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $KeyPairCopyWith<$Res> get keys {
    return $KeyPairCopyWith<$Res>(_value.keys, (value) {
      return _then(_value.copyWith(keys: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PreImageCopyWith<$Res> get preimage {
    return $PreImageCopyWith<$Res>(_value.preimage, (value) {
      return _then(_value.copyWith(preimage: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$LbtcLnSwapImplCopyWith<$Res>
    implements $LbtcLnSwapCopyWith<$Res> {
  factory _$$LbtcLnSwapImplCopyWith(
          _$LbtcLnSwapImpl value, $Res Function(_$LbtcLnSwapImpl) then) =
      __$$LbtcLnSwapImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      SwapType kind,
      Chain network,
      KeyPair keys,
      PreImage preimage,
      String redeemScript,
      String invoice,
      int outAmount,
      String scriptAddress,
      String blindingKey,
      String electrumUrl,
      String boltzUrl});

  @override
  $KeyPairCopyWith<$Res> get keys;
  @override
  $PreImageCopyWith<$Res> get preimage;
}

/// @nodoc
class __$$LbtcLnSwapImplCopyWithImpl<$Res>
    extends _$LbtcLnSwapCopyWithImpl<$Res, _$LbtcLnSwapImpl>
    implements _$$LbtcLnSwapImplCopyWith<$Res> {
  __$$LbtcLnSwapImplCopyWithImpl(
      _$LbtcLnSwapImpl _value, $Res Function(_$LbtcLnSwapImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? kind = null,
    Object? network = null,
    Object? keys = null,
    Object? preimage = null,
    Object? redeemScript = null,
    Object? invoice = null,
    Object? outAmount = null,
    Object? scriptAddress = null,
    Object? blindingKey = null,
    Object? electrumUrl = null,
    Object? boltzUrl = null,
  }) {
    return _then(_$LbtcLnSwapImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      kind: null == kind
          ? _value.kind
          : kind // ignore: cast_nullable_to_non_nullable
              as SwapType,
      network: null == network
          ? _value.network
          : network // ignore: cast_nullable_to_non_nullable
              as Chain,
      keys: null == keys
          ? _value.keys
          : keys // ignore: cast_nullable_to_non_nullable
              as KeyPair,
      preimage: null == preimage
          ? _value.preimage
          : preimage // ignore: cast_nullable_to_non_nullable
              as PreImage,
      redeemScript: null == redeemScript
          ? _value.redeemScript
          : redeemScript // ignore: cast_nullable_to_non_nullable
              as String,
      invoice: null == invoice
          ? _value.invoice
          : invoice // ignore: cast_nullable_to_non_nullable
              as String,
      outAmount: null == outAmount
          ? _value.outAmount
          : outAmount // ignore: cast_nullable_to_non_nullable
              as int,
      scriptAddress: null == scriptAddress
          ? _value.scriptAddress
          : scriptAddress // ignore: cast_nullable_to_non_nullable
              as String,
      blindingKey: null == blindingKey
          ? _value.blindingKey
          : blindingKey // ignore: cast_nullable_to_non_nullable
              as String,
      electrumUrl: null == electrumUrl
          ? _value.electrumUrl
          : electrumUrl // ignore: cast_nullable_to_non_nullable
              as String,
      boltzUrl: null == boltzUrl
          ? _value.boltzUrl
          : boltzUrl // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$LbtcLnSwapImpl implements _LbtcLnSwap {
  const _$LbtcLnSwapImpl(
      {required this.id,
      required this.kind,
      required this.network,
      required this.keys,
      required this.preimage,
      required this.redeemScript,
      required this.invoice,
      required this.outAmount,
      required this.scriptAddress,
      required this.blindingKey,
      required this.electrumUrl,
      required this.boltzUrl});

  factory _$LbtcLnSwapImpl.fromJson(Map<String, dynamic> json) =>
      _$$LbtcLnSwapImplFromJson(json);

  @override
  final String id;
  @override
  final SwapType kind;
  @override
  final Chain network;
  @override
  final KeyPair keys;
  @override
  final PreImage preimage;
  @override
  final String redeemScript;
  @override
  final String invoice;
  @override
  final int outAmount;
  @override
  final String scriptAddress;
  @override
  final String blindingKey;
  @override
  final String electrumUrl;
  @override
  final String boltzUrl;

  @override
  String toString() {
    return 'LbtcLnSwap(id: $id, kind: $kind, network: $network, keys: $keys, preimage: $preimage, redeemScript: $redeemScript, invoice: $invoice, outAmount: $outAmount, scriptAddress: $scriptAddress, blindingKey: $blindingKey, electrumUrl: $electrumUrl, boltzUrl: $boltzUrl)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LbtcLnSwapImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.kind, kind) || other.kind == kind) &&
            (identical(other.network, network) || other.network == network) &&
            (identical(other.keys, keys) || other.keys == keys) &&
            (identical(other.preimage, preimage) ||
                other.preimage == preimage) &&
            (identical(other.redeemScript, redeemScript) ||
                other.redeemScript == redeemScript) &&
            (identical(other.invoice, invoice) || other.invoice == invoice) &&
            (identical(other.outAmount, outAmount) ||
                other.outAmount == outAmount) &&
            (identical(other.scriptAddress, scriptAddress) ||
                other.scriptAddress == scriptAddress) &&
            (identical(other.blindingKey, blindingKey) ||
                other.blindingKey == blindingKey) &&
            (identical(other.electrumUrl, electrumUrl) ||
                other.electrumUrl == electrumUrl) &&
            (identical(other.boltzUrl, boltzUrl) ||
                other.boltzUrl == boltzUrl));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      kind,
      network,
      keys,
      preimage,
      redeemScript,
      invoice,
      outAmount,
      scriptAddress,
      blindingKey,
      electrumUrl,
      boltzUrl);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LbtcLnSwapImplCopyWith<_$LbtcLnSwapImpl> get copyWith =>
      __$$LbtcLnSwapImplCopyWithImpl<_$LbtcLnSwapImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$LbtcLnSwapImplToJson(
      this,
    );
  }
}

abstract class _LbtcLnSwap implements LbtcLnSwap {
  const factory _LbtcLnSwap(
      {required final String id,
      required final SwapType kind,
      required final Chain network,
      required final KeyPair keys,
      required final PreImage preimage,
      required final String redeemScript,
      required final String invoice,
      required final int outAmount,
      required final String scriptAddress,
      required final String blindingKey,
      required final String electrumUrl,
      required final String boltzUrl}) = _$LbtcLnSwapImpl;

  factory _LbtcLnSwap.fromJson(Map<String, dynamic> json) =
      _$LbtcLnSwapImpl.fromJson;

  @override
  String get id;
  @override
  SwapType get kind;
  @override
  Chain get network;
  @override
  KeyPair get keys;
  @override
  PreImage get preimage;
  @override
  String get redeemScript;
  @override
  String get invoice;
  @override
  int get outAmount;
  @override
  String get scriptAddress;
  @override
  String get blindingKey;
  @override
  String get electrumUrl;
  @override
  String get boltzUrl;
  @override
  @JsonKey(ignore: true)
  _$$LbtcLnSwapImplCopyWith<_$LbtcLnSwapImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Limits {
  int get minimal => throw _privateConstructorUsedError;
  int get maximal => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $LimitsCopyWith<Limits> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LimitsCopyWith<$Res> {
  factory $LimitsCopyWith(Limits value, $Res Function(Limits) then) =
      _$LimitsCopyWithImpl<$Res, Limits>;
  @useResult
  $Res call({int minimal, int maximal});
}

/// @nodoc
class _$LimitsCopyWithImpl<$Res, $Val extends Limits>
    implements $LimitsCopyWith<$Res> {
  _$LimitsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? minimal = null,
    Object? maximal = null,
  }) {
    return _then(_value.copyWith(
      minimal: null == minimal
          ? _value.minimal
          : minimal // ignore: cast_nullable_to_non_nullable
              as int,
      maximal: null == maximal
          ? _value.maximal
          : maximal // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LimitsImplCopyWith<$Res> implements $LimitsCopyWith<$Res> {
  factory _$$LimitsImplCopyWith(
          _$LimitsImpl value, $Res Function(_$LimitsImpl) then) =
      __$$LimitsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int minimal, int maximal});
}

/// @nodoc
class __$$LimitsImplCopyWithImpl<$Res>
    extends _$LimitsCopyWithImpl<$Res, _$LimitsImpl>
    implements _$$LimitsImplCopyWith<$Res> {
  __$$LimitsImplCopyWithImpl(
      _$LimitsImpl _value, $Res Function(_$LimitsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? minimal = null,
    Object? maximal = null,
  }) {
    return _then(_$LimitsImpl(
      minimal: null == minimal
          ? _value.minimal
          : minimal // ignore: cast_nullable_to_non_nullable
              as int,
      maximal: null == maximal
          ? _value.maximal
          : maximal // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LimitsImpl implements _Limits {
  const _$LimitsImpl({required this.minimal, required this.maximal});

  @override
  final int minimal;
  @override
  final int maximal;

  @override
  String toString() {
    return 'Limits(minimal: $minimal, maximal: $maximal)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LimitsImpl &&
            (identical(other.minimal, minimal) || other.minimal == minimal) &&
            (identical(other.maximal, maximal) || other.maximal == maximal));
  }

  @override
  int get hashCode => Object.hash(runtimeType, minimal, maximal);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LimitsImplCopyWith<_$LimitsImpl> get copyWith =>
      __$$LimitsImplCopyWithImpl<_$LimitsImpl>(this, _$identity);
}

abstract class _Limits implements Limits {
  const factory _Limits(
      {required final int minimal, required final int maximal}) = _$LimitsImpl;

  @override
  int get minimal;
  @override
  int get maximal;
  @override
  @JsonKey(ignore: true)
  _$$LimitsImplCopyWith<_$LimitsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PreImage _$PreImageFromJson(Map<String, dynamic> json) {
  return _PreImage.fromJson(json);
}

/// @nodoc
mixin _$PreImage {
  String get value => throw _privateConstructorUsedError;
  String get sha256 => throw _privateConstructorUsedError;
  String get hash160 => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $PreImageCopyWith<PreImage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PreImageCopyWith<$Res> {
  factory $PreImageCopyWith(PreImage value, $Res Function(PreImage) then) =
      _$PreImageCopyWithImpl<$Res, PreImage>;
  @useResult
  $Res call({String value, String sha256, String hash160});
}

/// @nodoc
class _$PreImageCopyWithImpl<$Res, $Val extends PreImage>
    implements $PreImageCopyWith<$Res> {
  _$PreImageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
    Object? sha256 = null,
    Object? hash160 = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      sha256: null == sha256
          ? _value.sha256
          : sha256 // ignore: cast_nullable_to_non_nullable
              as String,
      hash160: null == hash160
          ? _value.hash160
          : hash160 // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PreImageImplCopyWith<$Res>
    implements $PreImageCopyWith<$Res> {
  factory _$$PreImageImplCopyWith(
          _$PreImageImpl value, $Res Function(_$PreImageImpl) then) =
      __$$PreImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String value, String sha256, String hash160});
}

/// @nodoc
class __$$PreImageImplCopyWithImpl<$Res>
    extends _$PreImageCopyWithImpl<$Res, _$PreImageImpl>
    implements _$$PreImageImplCopyWith<$Res> {
  __$$PreImageImplCopyWithImpl(
      _$PreImageImpl _value, $Res Function(_$PreImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
    Object? sha256 = null,
    Object? hash160 = null,
  }) {
    return _then(_$PreImageImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      sha256: null == sha256
          ? _value.sha256
          : sha256 // ignore: cast_nullable_to_non_nullable
              as String,
      hash160: null == hash160
          ? _value.hash160
          : hash160 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PreImageImpl implements _PreImage {
  const _$PreImageImpl(
      {required this.value, required this.sha256, required this.hash160});

  factory _$PreImageImpl.fromJson(Map<String, dynamic> json) =>
      _$$PreImageImplFromJson(json);

  @override
  final String value;
  @override
  final String sha256;
  @override
  final String hash160;

  @override
  String toString() {
    return 'PreImage(value: $value, sha256: $sha256, hash160: $hash160)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PreImageImpl &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.sha256, sha256) || other.sha256 == sha256) &&
            (identical(other.hash160, hash160) || other.hash160 == hash160));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, value, sha256, hash160);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PreImageImplCopyWith<_$PreImageImpl> get copyWith =>
      __$$PreImageImplCopyWithImpl<_$PreImageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PreImageImplToJson(
      this,
    );
  }
}

abstract class _PreImage implements PreImage {
  const factory _PreImage(
      {required final String value,
      required final String sha256,
      required final String hash160}) = _$PreImageImpl;

  factory _PreImage.fromJson(Map<String, dynamic> json) =
      _$PreImageImpl.fromJson;

  @override
  String get value;
  @override
  String get sha256;
  @override
  String get hash160;
  @override
  @JsonKey(ignore: true)
  _$$PreImageImplCopyWith<_$PreImageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ReverseSwapFees {
  int get boltzFees => throw _privateConstructorUsedError;
  int get lockupFees => throw _privateConstructorUsedError;
  int get claimFeesEstimate => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ReverseSwapFeesCopyWith<ReverseSwapFees> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ReverseSwapFeesCopyWith<$Res> {
  factory $ReverseSwapFeesCopyWith(
          ReverseSwapFees value, $Res Function(ReverseSwapFees) then) =
      _$ReverseSwapFeesCopyWithImpl<$Res, ReverseSwapFees>;
  @useResult
  $Res call({int boltzFees, int lockupFees, int claimFeesEstimate});
}

/// @nodoc
class _$ReverseSwapFeesCopyWithImpl<$Res, $Val extends ReverseSwapFees>
    implements $ReverseSwapFeesCopyWith<$Res> {
  _$ReverseSwapFeesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? boltzFees = null,
    Object? lockupFees = null,
    Object? claimFeesEstimate = null,
  }) {
    return _then(_value.copyWith(
      boltzFees: null == boltzFees
          ? _value.boltzFees
          : boltzFees // ignore: cast_nullable_to_non_nullable
              as int,
      lockupFees: null == lockupFees
          ? _value.lockupFees
          : lockupFees // ignore: cast_nullable_to_non_nullable
              as int,
      claimFeesEstimate: null == claimFeesEstimate
          ? _value.claimFeesEstimate
          : claimFeesEstimate // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ReverseSwapFeesImplCopyWith<$Res>
    implements $ReverseSwapFeesCopyWith<$Res> {
  factory _$$ReverseSwapFeesImplCopyWith(_$ReverseSwapFeesImpl value,
          $Res Function(_$ReverseSwapFeesImpl) then) =
      __$$ReverseSwapFeesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int boltzFees, int lockupFees, int claimFeesEstimate});
}

/// @nodoc
class __$$ReverseSwapFeesImplCopyWithImpl<$Res>
    extends _$ReverseSwapFeesCopyWithImpl<$Res, _$ReverseSwapFeesImpl>
    implements _$$ReverseSwapFeesImplCopyWith<$Res> {
  __$$ReverseSwapFeesImplCopyWithImpl(
      _$ReverseSwapFeesImpl _value, $Res Function(_$ReverseSwapFeesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? boltzFees = null,
    Object? lockupFees = null,
    Object? claimFeesEstimate = null,
  }) {
    return _then(_$ReverseSwapFeesImpl(
      boltzFees: null == boltzFees
          ? _value.boltzFees
          : boltzFees // ignore: cast_nullable_to_non_nullable
              as int,
      lockupFees: null == lockupFees
          ? _value.lockupFees
          : lockupFees // ignore: cast_nullable_to_non_nullable
              as int,
      claimFeesEstimate: null == claimFeesEstimate
          ? _value.claimFeesEstimate
          : claimFeesEstimate // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ReverseSwapFeesImpl implements _ReverseSwapFees {
  const _$ReverseSwapFeesImpl(
      {required this.boltzFees,
      required this.lockupFees,
      required this.claimFeesEstimate});

  @override
  final int boltzFees;
  @override
  final int lockupFees;
  @override
  final int claimFeesEstimate;

  @override
  String toString() {
    return 'ReverseSwapFees(boltzFees: $boltzFees, lockupFees: $lockupFees, claimFeesEstimate: $claimFeesEstimate)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ReverseSwapFeesImpl &&
            (identical(other.boltzFees, boltzFees) ||
                other.boltzFees == boltzFees) &&
            (identical(other.lockupFees, lockupFees) ||
                other.lockupFees == lockupFees) &&
            (identical(other.claimFeesEstimate, claimFeesEstimate) ||
                other.claimFeesEstimate == claimFeesEstimate));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, boltzFees, lockupFees, claimFeesEstimate);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ReverseSwapFeesImplCopyWith<_$ReverseSwapFeesImpl> get copyWith =>
      __$$ReverseSwapFeesImplCopyWithImpl<_$ReverseSwapFeesImpl>(
          this, _$identity);
}

abstract class _ReverseSwapFees implements ReverseSwapFees {
  const factory _ReverseSwapFees(
      {required final int boltzFees,
      required final int lockupFees,
      required final int claimFeesEstimate}) = _$ReverseSwapFeesImpl;

  @override
  int get boltzFees;
  @override
  int get lockupFees;
  @override
  int get claimFeesEstimate;
  @override
  @JsonKey(ignore: true)
  _$$ReverseSwapFeesImplCopyWith<_$ReverseSwapFeesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SubmarineSwapFees {
  int get boltzFees => throw _privateConstructorUsedError;
  int get claimFees => throw _privateConstructorUsedError;
  int get lockupFeesEstimate => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SubmarineSwapFeesCopyWith<SubmarineSwapFees> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubmarineSwapFeesCopyWith<$Res> {
  factory $SubmarineSwapFeesCopyWith(
          SubmarineSwapFees value, $Res Function(SubmarineSwapFees) then) =
      _$SubmarineSwapFeesCopyWithImpl<$Res, SubmarineSwapFees>;
  @useResult
  $Res call({int boltzFees, int claimFees, int lockupFeesEstimate});
}

/// @nodoc
class _$SubmarineSwapFeesCopyWithImpl<$Res, $Val extends SubmarineSwapFees>
    implements $SubmarineSwapFeesCopyWith<$Res> {
  _$SubmarineSwapFeesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? boltzFees = null,
    Object? claimFees = null,
    Object? lockupFeesEstimate = null,
  }) {
    return _then(_value.copyWith(
      boltzFees: null == boltzFees
          ? _value.boltzFees
          : boltzFees // ignore: cast_nullable_to_non_nullable
              as int,
      claimFees: null == claimFees
          ? _value.claimFees
          : claimFees // ignore: cast_nullable_to_non_nullable
              as int,
      lockupFeesEstimate: null == lockupFeesEstimate
          ? _value.lockupFeesEstimate
          : lockupFeesEstimate // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SubmarineSwapFeesImplCopyWith<$Res>
    implements $SubmarineSwapFeesCopyWith<$Res> {
  factory _$$SubmarineSwapFeesImplCopyWith(_$SubmarineSwapFeesImpl value,
          $Res Function(_$SubmarineSwapFeesImpl) then) =
      __$$SubmarineSwapFeesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int boltzFees, int claimFees, int lockupFeesEstimate});
}

/// @nodoc
class __$$SubmarineSwapFeesImplCopyWithImpl<$Res>
    extends _$SubmarineSwapFeesCopyWithImpl<$Res, _$SubmarineSwapFeesImpl>
    implements _$$SubmarineSwapFeesImplCopyWith<$Res> {
  __$$SubmarineSwapFeesImplCopyWithImpl(_$SubmarineSwapFeesImpl _value,
      $Res Function(_$SubmarineSwapFeesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? boltzFees = null,
    Object? claimFees = null,
    Object? lockupFeesEstimate = null,
  }) {
    return _then(_$SubmarineSwapFeesImpl(
      boltzFees: null == boltzFees
          ? _value.boltzFees
          : boltzFees // ignore: cast_nullable_to_non_nullable
              as int,
      claimFees: null == claimFees
          ? _value.claimFees
          : claimFees // ignore: cast_nullable_to_non_nullable
              as int,
      lockupFeesEstimate: null == lockupFeesEstimate
          ? _value.lockupFeesEstimate
          : lockupFeesEstimate // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SubmarineSwapFeesImpl implements _SubmarineSwapFees {
  const _$SubmarineSwapFeesImpl(
      {required this.boltzFees,
      required this.claimFees,
      required this.lockupFeesEstimate});

  @override
  final int boltzFees;
  @override
  final int claimFees;
  @override
  final int lockupFeesEstimate;

  @override
  String toString() {
    return 'SubmarineSwapFees(boltzFees: $boltzFees, claimFees: $claimFees, lockupFeesEstimate: $lockupFeesEstimate)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubmarineSwapFeesImpl &&
            (identical(other.boltzFees, boltzFees) ||
                other.boltzFees == boltzFees) &&
            (identical(other.claimFees, claimFees) ||
                other.claimFees == claimFees) &&
            (identical(other.lockupFeesEstimate, lockupFeesEstimate) ||
                other.lockupFeesEstimate == lockupFeesEstimate));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, boltzFees, claimFees, lockupFeesEstimate);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SubmarineSwapFeesImplCopyWith<_$SubmarineSwapFeesImpl> get copyWith =>
      __$$SubmarineSwapFeesImplCopyWithImpl<_$SubmarineSwapFeesImpl>(
          this, _$identity);
}

abstract class _SubmarineSwapFees implements SubmarineSwapFees {
  const factory _SubmarineSwapFees(
      {required final int boltzFees,
      required final int claimFees,
      required final int lockupFeesEstimate}) = _$SubmarineSwapFeesImpl;

  @override
  int get boltzFees;
  @override
  int get claimFees;
  @override
  int get lockupFeesEstimate;
  @override
  @JsonKey(ignore: true)
  _$$SubmarineSwapFeesImplCopyWith<_$SubmarineSwapFeesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
