// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `into`, `into`, `into`, `try_into`, `try_into`, `try_into`

/// Complete fees and limits class for Chain swaps
class ChainFeesAndLimits {
  final SwapLimits btcLimits;
  final SwapLimits lbtcLimits;
  final ChainSwapFees btcFees;
  final ChainSwapFees lbtcFees;

  const ChainFeesAndLimits({
    required this.btcLimits,
    required this.lbtcLimits,
    required this.btcFees,
    required this.lbtcFees,
  });

  @override
  int get hashCode =>
      btcLimits.hashCode ^
      lbtcLimits.hashCode ^
      btcFees.hashCode ^
      lbtcFees.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChainFeesAndLimits &&
          runtimeType == other.runtimeType &&
          btcLimits == other.btcLimits &&
          lbtcLimits == other.lbtcLimits &&
          btcFees == other.btcFees &&
          lbtcFees == other.lbtcFees;
}

/// Chain swap fee breakdown.
class ChainSwapFees {
  final double percentage;
  final BigInt userLockup;
  final BigInt userClaim;
  final BigInt server;

  const ChainSwapFees({
    required this.percentage,
    required this.userLockup,
    required this.userClaim,
    required this.server,
  });

  @override
  int get hashCode =>
      percentage.hashCode ^
      userLockup.hashCode ^
      userClaim.hashCode ^
      server.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ChainSwapFees &&
          runtimeType == other.runtimeType &&
          percentage == other.percentage &&
          userLockup == other.userLockup &&
          userClaim == other.userClaim &&
          server == other.server;
}

/// A Class that helps fetch both Fees and Limits for the various swap types
class Fees {
  final String boltzUrl;

  const Fees({
    required this.boltzUrl,
  });

  /// Method to get the fees & limits for a chain swap
  Future<ChainFeesAndLimits> chain() =>
      BoltzCore.instance.api.crateApiFeesFeesChain(
        that: this,
      );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Constructor
  static Future<Fees> newInstance({required String boltzUrl}) =>
      BoltzCore.instance.api.crateApiFeesFeesNew(boltzUrl: boltzUrl);

  /// Method to get the fees & limits for a reverse swap
  Future<ReverseFeesAndLimits> reverse() =>
      BoltzCore.instance.api.crateApiFeesFeesReverse(
        that: this,
      );

  /// Method to get the fees & limits for a submarine swap
  Future<SubmarineFeesAndLimits> submarine() =>
      BoltzCore.instance.api.crateApiFeesFeesSubmarine(
        that: this,
      );

  @override
  int get hashCode => boltzUrl.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Fees &&
          runtimeType == other.runtimeType &&
          boltzUrl == other.boltzUrl;
}

/// Breakdown of Miner Fees
class MinerFees {
  final BigInt lockup;
  final BigInt claim;

  const MinerFees({
    required this.lockup,
    required this.claim,
  });

  @override
  int get hashCode => lockup.hashCode ^ claim.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MinerFees &&
          runtimeType == other.runtimeType &&
          lockup == other.lockup &&
          claim == other.claim;
}

/// Reverse swap fee breakdown.
class RevSwapFees {
  final double percentage;
  final MinerFees minerFees;

  const RevSwapFees({
    required this.percentage,
    required this.minerFees,
  });

  @override
  int get hashCode => percentage.hashCode ^ minerFees.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is RevSwapFees &&
          runtimeType == other.runtimeType &&
          percentage == other.percentage &&
          minerFees == other.minerFees;
}

/// Complete fees and limits class for Reverse swaps
class ReverseFeesAndLimits {
  final SwapLimits btcLimits;
  final SwapLimits lbtcLimits;
  final RevSwapFees btcFees;
  final RevSwapFees lbtcFees;

  const ReverseFeesAndLimits({
    required this.btcLimits,
    required this.lbtcLimits,
    required this.btcFees,
    required this.lbtcFees,
  });

  @override
  int get hashCode =>
      btcLimits.hashCode ^
      lbtcLimits.hashCode ^
      btcFees.hashCode ^
      lbtcFees.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReverseFeesAndLimits &&
          runtimeType == other.runtimeType &&
          btcLimits == other.btcLimits &&
          lbtcLimits == other.lbtcLimits &&
          btcFees == other.btcFees &&
          lbtcFees == other.lbtcFees;
}

/// Submarine swap fee breakdown.
class SubSwapFees {
  /// Boltz fees as a percentage
  final double percentage;

  /// Fees going to Bitcoin miners/Liquid block validators
  final BigInt minerFees;

  const SubSwapFees({
    required this.percentage,
    required this.minerFees,
  });

  @override
  int get hashCode => percentage.hashCode ^ minerFees.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SubSwapFees &&
          runtimeType == other.runtimeType &&
          percentage == other.percentage &&
          minerFees == other.minerFees;
}

/// Complete fees and limits class for Submarine swaps
class SubmarineFeesAndLimits {
  final SwapLimits btcLimits;
  final SwapLimits lbtcLimits;
  final SubSwapFees btcFees;
  final SubSwapFees lbtcFees;

  const SubmarineFeesAndLimits({
    required this.btcLimits,
    required this.lbtcLimits,
    required this.btcFees,
    required this.lbtcFees,
  });

  @override
  int get hashCode =>
      btcLimits.hashCode ^
      lbtcLimits.hashCode ^
      btcFees.hashCode ^
      lbtcFees.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SubmarineFeesAndLimits &&
          runtimeType == other.runtimeType &&
          btcLimits == other.btcLimits &&
          lbtcLimits == other.lbtcLimits &&
          btcFees == other.btcFees &&
          lbtcFees == other.lbtcFees;
}

/// Boltz limits for swaps.
/// Internally used and returned by the Fees class methods.
class SwapLimits {
  final BigInt minimal;
  final BigInt maximal;

  const SwapLimits({
    required this.minimal,
    required this.maximal,
  });

  @override
  int get hashCode => minimal.hashCode ^ maximal.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SwapLimits &&
          runtimeType == other.runtimeType &&
          minimal == other.minimal &&
          maximal == other.maximal;
}
