// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'fees.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ChainFeesAndLimits {
  SwapLimits get btcLimits => throw _privateConstructorUsedError;
  SwapLimits get lbtcLimits => throw _privateConstructorUsedError;
  ChainSwapFees get btcFees => throw _privateConstructorUsedError;
  ChainSwapFees get lbtcFees => throw _privateConstructorUsedError;

  /// Create a copy of ChainFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ChainFeesAndLimitsCopyWith<ChainFeesAndLimits> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChainFeesAndLimitsCopyWith<$Res> {
  factory $ChainFeesAndLimitsCopyWith(
          ChainFeesAndLimits value, $Res Function(ChainFeesAndLimits) then) =
      _$ChainFeesAndLimitsCopyWithImpl<$Res, ChainFeesAndLimits>;
  @useResult
  $Res call(
      {SwapLimits btcLimits,
      SwapLimits lbtcLimits,
      ChainSwapFees btcFees,
      ChainSwapFees lbtcFees});

  $SwapLimitsCopyWith<$Res> get btcLimits;
  $SwapLimitsCopyWith<$Res> get lbtcLimits;
  $ChainSwapFeesCopyWith<$Res> get btcFees;
  $ChainSwapFeesCopyWith<$Res> get lbtcFees;
}

/// @nodoc
class _$ChainFeesAndLimitsCopyWithImpl<$Res, $Val extends ChainFeesAndLimits>
    implements $ChainFeesAndLimitsCopyWith<$Res> {
  _$ChainFeesAndLimitsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ChainFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? btcLimits = null,
    Object? lbtcLimits = null,
    Object? btcFees = null,
    Object? lbtcFees = null,
  }) {
    return _then(_value.copyWith(
      btcLimits: null == btcLimits
          ? _value.btcLimits
          : btcLimits // ignore: cast_nullable_to_non_nullable
              as SwapLimits,
      lbtcLimits: null == lbtcLimits
          ? _value.lbtcLimits
          : lbtcLimits // ignore: cast_nullable_to_non_nullable
              as SwapLimits,
      btcFees: null == btcFees
          ? _value.btcFees
          : btcFees // ignore: cast_nullable_to_non_nullable
              as ChainSwapFees,
      lbtcFees: null == lbtcFees
          ? _value.lbtcFees
          : lbtcFees // ignore: cast_nullable_to_non_nullable
              as ChainSwapFees,
    ) as $Val);
  }

  /// Create a copy of ChainFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $SwapLimitsCopyWith<$Res> get btcLimits {
    return $SwapLimitsCopyWith<$Res>(_value.btcLimits, (value) {
      return _then(_value.copyWith(btcLimits: value) as $Val);
    });
  }

  /// Create a copy of ChainFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $SwapLimitsCopyWith<$Res> get lbtcLimits {
    return $SwapLimitsCopyWith<$Res>(_value.lbtcLimits, (value) {
      return _then(_value.copyWith(lbtcLimits: value) as $Val);
    });
  }

  /// Create a copy of ChainFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChainSwapFeesCopyWith<$Res> get btcFees {
    return $ChainSwapFeesCopyWith<$Res>(_value.btcFees, (value) {
      return _then(_value.copyWith(btcFees: value) as $Val);
    });
  }

  /// Create a copy of ChainFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ChainSwapFeesCopyWith<$Res> get lbtcFees {
    return $ChainSwapFeesCopyWith<$Res>(_value.lbtcFees, (value) {
      return _then(_value.copyWith(lbtcFees: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ChainFeesAndLimitsImplCopyWith<$Res>
    implements $ChainFeesAndLimitsCopyWith<$Res> {
  factory _$$ChainFeesAndLimitsImplCopyWith(_$ChainFeesAndLimitsImpl value,
          $Res Function(_$ChainFeesAndLimitsImpl) then) =
      __$$ChainFeesAndLimitsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {SwapLimits btcLimits,
      SwapLimits lbtcLimits,
      ChainSwapFees btcFees,
      ChainSwapFees lbtcFees});

  @override
  $SwapLimitsCopyWith<$Res> get btcLimits;
  @override
  $SwapLimitsCopyWith<$Res> get lbtcLimits;
  @override
  $ChainSwapFeesCopyWith<$Res> get btcFees;
  @override
  $ChainSwapFeesCopyWith<$Res> get lbtcFees;
}

/// @nodoc
class __$$ChainFeesAndLimitsImplCopyWithImpl<$Res>
    extends _$ChainFeesAndLimitsCopyWithImpl<$Res, _$ChainFeesAndLimitsImpl>
    implements _$$ChainFeesAndLimitsImplCopyWith<$Res> {
  __$$ChainFeesAndLimitsImplCopyWithImpl(_$ChainFeesAndLimitsImpl _value,
      $Res Function(_$ChainFeesAndLimitsImpl) _then)
      : super(_value, _then);

  /// Create a copy of ChainFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? btcLimits = null,
    Object? lbtcLimits = null,
    Object? btcFees = null,
    Object? lbtcFees = null,
  }) {
    return _then(_$ChainFeesAndLimitsImpl(
      btcLimits: null == btcLimits
          ? _value.btcLimits
          : btcLimits // ignore: cast_nullable_to_non_nullable
              as SwapLimits,
      lbtcLimits: null == lbtcLimits
          ? _value.lbtcLimits
          : lbtcLimits // ignore: cast_nullable_to_non_nullable
              as SwapLimits,
      btcFees: null == btcFees
          ? _value.btcFees
          : btcFees // ignore: cast_nullable_to_non_nullable
              as ChainSwapFees,
      lbtcFees: null == lbtcFees
          ? _value.lbtcFees
          : lbtcFees // ignore: cast_nullable_to_non_nullable
              as ChainSwapFees,
    ));
  }
}

/// @nodoc

class _$ChainFeesAndLimitsImpl implements _ChainFeesAndLimits {
  const _$ChainFeesAndLimitsImpl(
      {required this.btcLimits,
      required this.lbtcLimits,
      required this.btcFees,
      required this.lbtcFees});

  @override
  final SwapLimits btcLimits;
  @override
  final SwapLimits lbtcLimits;
  @override
  final ChainSwapFees btcFees;
  @override
  final ChainSwapFees lbtcFees;

  @override
  String toString() {
    return 'ChainFeesAndLimits(btcLimits: $btcLimits, lbtcLimits: $lbtcLimits, btcFees: $btcFees, lbtcFees: $lbtcFees)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChainFeesAndLimitsImpl &&
            (identical(other.btcLimits, btcLimits) ||
                other.btcLimits == btcLimits) &&
            (identical(other.lbtcLimits, lbtcLimits) ||
                other.lbtcLimits == lbtcLimits) &&
            (identical(other.btcFees, btcFees) || other.btcFees == btcFees) &&
            (identical(other.lbtcFees, lbtcFees) ||
                other.lbtcFees == lbtcFees));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, btcLimits, lbtcLimits, btcFees, lbtcFees);

  /// Create a copy of ChainFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ChainFeesAndLimitsImplCopyWith<_$ChainFeesAndLimitsImpl> get copyWith =>
      __$$ChainFeesAndLimitsImplCopyWithImpl<_$ChainFeesAndLimitsImpl>(
          this, _$identity);
}

abstract class _ChainFeesAndLimits implements ChainFeesAndLimits {
  const factory _ChainFeesAndLimits(
      {required final SwapLimits btcLimits,
      required final SwapLimits lbtcLimits,
      required final ChainSwapFees btcFees,
      required final ChainSwapFees lbtcFees}) = _$ChainFeesAndLimitsImpl;

  @override
  SwapLimits get btcLimits;
  @override
  SwapLimits get lbtcLimits;
  @override
  ChainSwapFees get btcFees;
  @override
  ChainSwapFees get lbtcFees;

  /// Create a copy of ChainFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ChainFeesAndLimitsImplCopyWith<_$ChainFeesAndLimitsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ChainSwapFees {
  double get percentage => throw _privateConstructorUsedError;
  int get userLockup => throw _privateConstructorUsedError;
  int get userClaim => throw _privateConstructorUsedError;
  int get server => throw _privateConstructorUsedError;

  /// Create a copy of ChainSwapFees
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ChainSwapFeesCopyWith<ChainSwapFees> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChainSwapFeesCopyWith<$Res> {
  factory $ChainSwapFeesCopyWith(
          ChainSwapFees value, $Res Function(ChainSwapFees) then) =
      _$ChainSwapFeesCopyWithImpl<$Res, ChainSwapFees>;
  @useResult
  $Res call({double percentage, int userLockup, int userClaim, int server});
}

/// @nodoc
class _$ChainSwapFeesCopyWithImpl<$Res, $Val extends ChainSwapFees>
    implements $ChainSwapFeesCopyWith<$Res> {
  _$ChainSwapFeesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ChainSwapFees
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? percentage = null,
    Object? userLockup = null,
    Object? userClaim = null,
    Object? server = null,
  }) {
    return _then(_value.copyWith(
      percentage: null == percentage
          ? _value.percentage
          : percentage // ignore: cast_nullable_to_non_nullable
              as double,
      userLockup: null == userLockup
          ? _value.userLockup
          : userLockup // ignore: cast_nullable_to_non_nullable
              as int,
      userClaim: null == userClaim
          ? _value.userClaim
          : userClaim // ignore: cast_nullable_to_non_nullable
              as int,
      server: null == server
          ? _value.server
          : server // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChainSwapFeesImplCopyWith<$Res>
    implements $ChainSwapFeesCopyWith<$Res> {
  factory _$$ChainSwapFeesImplCopyWith(
          _$ChainSwapFeesImpl value, $Res Function(_$ChainSwapFeesImpl) then) =
      __$$ChainSwapFeesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double percentage, int userLockup, int userClaim, int server});
}

/// @nodoc
class __$$ChainSwapFeesImplCopyWithImpl<$Res>
    extends _$ChainSwapFeesCopyWithImpl<$Res, _$ChainSwapFeesImpl>
    implements _$$ChainSwapFeesImplCopyWith<$Res> {
  __$$ChainSwapFeesImplCopyWithImpl(
      _$ChainSwapFeesImpl _value, $Res Function(_$ChainSwapFeesImpl) _then)
      : super(_value, _then);

  /// Create a copy of ChainSwapFees
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? percentage = null,
    Object? userLockup = null,
    Object? userClaim = null,
    Object? server = null,
  }) {
    return _then(_$ChainSwapFeesImpl(
      percentage: null == percentage
          ? _value.percentage
          : percentage // ignore: cast_nullable_to_non_nullable
              as double,
      userLockup: null == userLockup
          ? _value.userLockup
          : userLockup // ignore: cast_nullable_to_non_nullable
              as int,
      userClaim: null == userClaim
          ? _value.userClaim
          : userClaim // ignore: cast_nullable_to_non_nullable
              as int,
      server: null == server
          ? _value.server
          : server // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ChainSwapFeesImpl implements _ChainSwapFees {
  const _$ChainSwapFeesImpl(
      {required this.percentage,
      required this.userLockup,
      required this.userClaim,
      required this.server});

  @override
  final double percentage;
  @override
  final int userLockup;
  @override
  final int userClaim;
  @override
  final int server;

  @override
  String toString() {
    return 'ChainSwapFees(percentage: $percentage, userLockup: $userLockup, userClaim: $userClaim, server: $server)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChainSwapFeesImpl &&
            (identical(other.percentage, percentage) ||
                other.percentage == percentage) &&
            (identical(other.userLockup, userLockup) ||
                other.userLockup == userLockup) &&
            (identical(other.userClaim, userClaim) ||
                other.userClaim == userClaim) &&
            (identical(other.server, server) || other.server == server));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, percentage, userLockup, userClaim, server);

  /// Create a copy of ChainSwapFees
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ChainSwapFeesImplCopyWith<_$ChainSwapFeesImpl> get copyWith =>
      __$$ChainSwapFeesImplCopyWithImpl<_$ChainSwapFeesImpl>(this, _$identity);
}

abstract class _ChainSwapFees implements ChainSwapFees {
  const factory _ChainSwapFees(
      {required final double percentage,
      required final int userLockup,
      required final int userClaim,
      required final int server}) = _$ChainSwapFeesImpl;

  @override
  double get percentage;
  @override
  int get userLockup;
  @override
  int get userClaim;
  @override
  int get server;

  /// Create a copy of ChainSwapFees
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ChainSwapFeesImplCopyWith<_$ChainSwapFeesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Fees {
  String get boltzUrl => throw _privateConstructorUsedError;

  /// Create a copy of Fees
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $FeesCopyWith<Fees> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FeesCopyWith<$Res> {
  factory $FeesCopyWith(Fees value, $Res Function(Fees) then) =
      _$FeesCopyWithImpl<$Res, Fees>;
  @useResult
  $Res call({String boltzUrl});
}

/// @nodoc
class _$FeesCopyWithImpl<$Res, $Val extends Fees>
    implements $FeesCopyWith<$Res> {
  _$FeesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Fees
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? boltzUrl = null,
  }) {
    return _then(_value.copyWith(
      boltzUrl: null == boltzUrl
          ? _value.boltzUrl
          : boltzUrl // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FeesImplCopyWith<$Res> implements $FeesCopyWith<$Res> {
  factory _$$FeesImplCopyWith(
          _$FeesImpl value, $Res Function(_$FeesImpl) then) =
      __$$FeesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String boltzUrl});
}

/// @nodoc
class __$$FeesImplCopyWithImpl<$Res>
    extends _$FeesCopyWithImpl<$Res, _$FeesImpl>
    implements _$$FeesImplCopyWith<$Res> {
  __$$FeesImplCopyWithImpl(_$FeesImpl _value, $Res Function(_$FeesImpl) _then)
      : super(_value, _then);

  /// Create a copy of Fees
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? boltzUrl = null,
  }) {
    return _then(_$FeesImpl(
      boltzUrl: null == boltzUrl
          ? _value.boltzUrl
          : boltzUrl // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$FeesImpl extends _Fees {
  const _$FeesImpl({required this.boltzUrl}) : super._();

  @override
  final String boltzUrl;

  @override
  String toString() {
    return 'Fees(boltzUrl: $boltzUrl)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FeesImpl &&
            (identical(other.boltzUrl, boltzUrl) ||
                other.boltzUrl == boltzUrl));
  }

  @override
  int get hashCode => Object.hash(runtimeType, boltzUrl);

  /// Create a copy of Fees
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$FeesImplCopyWith<_$FeesImpl> get copyWith =>
      __$$FeesImplCopyWithImpl<_$FeesImpl>(this, _$identity);
}

abstract class _Fees extends Fees {
  const factory _Fees({required final String boltzUrl}) = _$FeesImpl;
  const _Fees._() : super._();

  @override
  String get boltzUrl;

  /// Create a copy of Fees
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$FeesImplCopyWith<_$FeesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MinerFees {
  int get lockup => throw _privateConstructorUsedError;
  int get claim => throw _privateConstructorUsedError;

  /// Create a copy of MinerFees
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MinerFeesCopyWith<MinerFees> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MinerFeesCopyWith<$Res> {
  factory $MinerFeesCopyWith(MinerFees value, $Res Function(MinerFees) then) =
      _$MinerFeesCopyWithImpl<$Res, MinerFees>;
  @useResult
  $Res call({int lockup, int claim});
}

/// @nodoc
class _$MinerFeesCopyWithImpl<$Res, $Val extends MinerFees>
    implements $MinerFeesCopyWith<$Res> {
  _$MinerFeesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MinerFees
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? lockup = null,
    Object? claim = null,
  }) {
    return _then(_value.copyWith(
      lockup: null == lockup
          ? _value.lockup
          : lockup // ignore: cast_nullable_to_non_nullable
              as int,
      claim: null == claim
          ? _value.claim
          : claim // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MinerFeesImplCopyWith<$Res>
    implements $MinerFeesCopyWith<$Res> {
  factory _$$MinerFeesImplCopyWith(
          _$MinerFeesImpl value, $Res Function(_$MinerFeesImpl) then) =
      __$$MinerFeesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int lockup, int claim});
}

/// @nodoc
class __$$MinerFeesImplCopyWithImpl<$Res>
    extends _$MinerFeesCopyWithImpl<$Res, _$MinerFeesImpl>
    implements _$$MinerFeesImplCopyWith<$Res> {
  __$$MinerFeesImplCopyWithImpl(
      _$MinerFeesImpl _value, $Res Function(_$MinerFeesImpl) _then)
      : super(_value, _then);

  /// Create a copy of MinerFees
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? lockup = null,
    Object? claim = null,
  }) {
    return _then(_$MinerFeesImpl(
      lockup: null == lockup
          ? _value.lockup
          : lockup // ignore: cast_nullable_to_non_nullable
              as int,
      claim: null == claim
          ? _value.claim
          : claim // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$MinerFeesImpl implements _MinerFees {
  const _$MinerFeesImpl({required this.lockup, required this.claim});

  @override
  final int lockup;
  @override
  final int claim;

  @override
  String toString() {
    return 'MinerFees(lockup: $lockup, claim: $claim)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MinerFeesImpl &&
            (identical(other.lockup, lockup) || other.lockup == lockup) &&
            (identical(other.claim, claim) || other.claim == claim));
  }

  @override
  int get hashCode => Object.hash(runtimeType, lockup, claim);

  /// Create a copy of MinerFees
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MinerFeesImplCopyWith<_$MinerFeesImpl> get copyWith =>
      __$$MinerFeesImplCopyWithImpl<_$MinerFeesImpl>(this, _$identity);
}

abstract class _MinerFees implements MinerFees {
  const factory _MinerFees(
      {required final int lockup, required final int claim}) = _$MinerFeesImpl;

  @override
  int get lockup;
  @override
  int get claim;

  /// Create a copy of MinerFees
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MinerFeesImplCopyWith<_$MinerFeesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$RevSwapFees {
  double get percentage => throw _privateConstructorUsedError;
  MinerFees get minerFees => throw _privateConstructorUsedError;

  /// Create a copy of RevSwapFees
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $RevSwapFeesCopyWith<RevSwapFees> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RevSwapFeesCopyWith<$Res> {
  factory $RevSwapFeesCopyWith(
          RevSwapFees value, $Res Function(RevSwapFees) then) =
      _$RevSwapFeesCopyWithImpl<$Res, RevSwapFees>;
  @useResult
  $Res call({double percentage, MinerFees minerFees});

  $MinerFeesCopyWith<$Res> get minerFees;
}

/// @nodoc
class _$RevSwapFeesCopyWithImpl<$Res, $Val extends RevSwapFees>
    implements $RevSwapFeesCopyWith<$Res> {
  _$RevSwapFeesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of RevSwapFees
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? percentage = null,
    Object? minerFees = null,
  }) {
    return _then(_value.copyWith(
      percentage: null == percentage
          ? _value.percentage
          : percentage // ignore: cast_nullable_to_non_nullable
              as double,
      minerFees: null == minerFees
          ? _value.minerFees
          : minerFees // ignore: cast_nullable_to_non_nullable
              as MinerFees,
    ) as $Val);
  }

  /// Create a copy of RevSwapFees
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $MinerFeesCopyWith<$Res> get minerFees {
    return $MinerFeesCopyWith<$Res>(_value.minerFees, (value) {
      return _then(_value.copyWith(minerFees: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$RevSwapFeesImplCopyWith<$Res>
    implements $RevSwapFeesCopyWith<$Res> {
  factory _$$RevSwapFeesImplCopyWith(
          _$RevSwapFeesImpl value, $Res Function(_$RevSwapFeesImpl) then) =
      __$$RevSwapFeesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double percentage, MinerFees minerFees});

  @override
  $MinerFeesCopyWith<$Res> get minerFees;
}

/// @nodoc
class __$$RevSwapFeesImplCopyWithImpl<$Res>
    extends _$RevSwapFeesCopyWithImpl<$Res, _$RevSwapFeesImpl>
    implements _$$RevSwapFeesImplCopyWith<$Res> {
  __$$RevSwapFeesImplCopyWithImpl(
      _$RevSwapFeesImpl _value, $Res Function(_$RevSwapFeesImpl) _then)
      : super(_value, _then);

  /// Create a copy of RevSwapFees
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? percentage = null,
    Object? minerFees = null,
  }) {
    return _then(_$RevSwapFeesImpl(
      percentage: null == percentage
          ? _value.percentage
          : percentage // ignore: cast_nullable_to_non_nullable
              as double,
      minerFees: null == minerFees
          ? _value.minerFees
          : minerFees // ignore: cast_nullable_to_non_nullable
              as MinerFees,
    ));
  }
}

/// @nodoc

class _$RevSwapFeesImpl implements _RevSwapFees {
  const _$RevSwapFeesImpl({required this.percentage, required this.minerFees});

  @override
  final double percentage;
  @override
  final MinerFees minerFees;

  @override
  String toString() {
    return 'RevSwapFees(percentage: $percentage, minerFees: $minerFees)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RevSwapFeesImpl &&
            (identical(other.percentage, percentage) ||
                other.percentage == percentage) &&
            (identical(other.minerFees, minerFees) ||
                other.minerFees == minerFees));
  }

  @override
  int get hashCode => Object.hash(runtimeType, percentage, minerFees);

  /// Create a copy of RevSwapFees
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RevSwapFeesImplCopyWith<_$RevSwapFeesImpl> get copyWith =>
      __$$RevSwapFeesImplCopyWithImpl<_$RevSwapFeesImpl>(this, _$identity);
}

abstract class _RevSwapFees implements RevSwapFees {
  const factory _RevSwapFees(
      {required final double percentage,
      required final MinerFees minerFees}) = _$RevSwapFeesImpl;

  @override
  double get percentage;
  @override
  MinerFees get minerFees;

  /// Create a copy of RevSwapFees
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RevSwapFeesImplCopyWith<_$RevSwapFeesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ReverseFeesAndLimits {
  SwapLimits get btcLimits => throw _privateConstructorUsedError;
  SwapLimits get lbtcLimits => throw _privateConstructorUsedError;
  RevSwapFees get btcFees => throw _privateConstructorUsedError;
  RevSwapFees get lbtcFees => throw _privateConstructorUsedError;

  /// Create a copy of ReverseFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ReverseFeesAndLimitsCopyWith<ReverseFeesAndLimits> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ReverseFeesAndLimitsCopyWith<$Res> {
  factory $ReverseFeesAndLimitsCopyWith(ReverseFeesAndLimits value,
          $Res Function(ReverseFeesAndLimits) then) =
      _$ReverseFeesAndLimitsCopyWithImpl<$Res, ReverseFeesAndLimits>;
  @useResult
  $Res call(
      {SwapLimits btcLimits,
      SwapLimits lbtcLimits,
      RevSwapFees btcFees,
      RevSwapFees lbtcFees});

  $SwapLimitsCopyWith<$Res> get btcLimits;
  $SwapLimitsCopyWith<$Res> get lbtcLimits;
  $RevSwapFeesCopyWith<$Res> get btcFees;
  $RevSwapFeesCopyWith<$Res> get lbtcFees;
}

/// @nodoc
class _$ReverseFeesAndLimitsCopyWithImpl<$Res,
        $Val extends ReverseFeesAndLimits>
    implements $ReverseFeesAndLimitsCopyWith<$Res> {
  _$ReverseFeesAndLimitsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ReverseFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? btcLimits = null,
    Object? lbtcLimits = null,
    Object? btcFees = null,
    Object? lbtcFees = null,
  }) {
    return _then(_value.copyWith(
      btcLimits: null == btcLimits
          ? _value.btcLimits
          : btcLimits // ignore: cast_nullable_to_non_nullable
              as SwapLimits,
      lbtcLimits: null == lbtcLimits
          ? _value.lbtcLimits
          : lbtcLimits // ignore: cast_nullable_to_non_nullable
              as SwapLimits,
      btcFees: null == btcFees
          ? _value.btcFees
          : btcFees // ignore: cast_nullable_to_non_nullable
              as RevSwapFees,
      lbtcFees: null == lbtcFees
          ? _value.lbtcFees
          : lbtcFees // ignore: cast_nullable_to_non_nullable
              as RevSwapFees,
    ) as $Val);
  }

  /// Create a copy of ReverseFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $SwapLimitsCopyWith<$Res> get btcLimits {
    return $SwapLimitsCopyWith<$Res>(_value.btcLimits, (value) {
      return _then(_value.copyWith(btcLimits: value) as $Val);
    });
  }

  /// Create a copy of ReverseFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $SwapLimitsCopyWith<$Res> get lbtcLimits {
    return $SwapLimitsCopyWith<$Res>(_value.lbtcLimits, (value) {
      return _then(_value.copyWith(lbtcLimits: value) as $Val);
    });
  }

  /// Create a copy of ReverseFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RevSwapFeesCopyWith<$Res> get btcFees {
    return $RevSwapFeesCopyWith<$Res>(_value.btcFees, (value) {
      return _then(_value.copyWith(btcFees: value) as $Val);
    });
  }

  /// Create a copy of ReverseFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $RevSwapFeesCopyWith<$Res> get lbtcFees {
    return $RevSwapFeesCopyWith<$Res>(_value.lbtcFees, (value) {
      return _then(_value.copyWith(lbtcFees: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$ReverseFeesAndLimitsImplCopyWith<$Res>
    implements $ReverseFeesAndLimitsCopyWith<$Res> {
  factory _$$ReverseFeesAndLimitsImplCopyWith(_$ReverseFeesAndLimitsImpl value,
          $Res Function(_$ReverseFeesAndLimitsImpl) then) =
      __$$ReverseFeesAndLimitsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {SwapLimits btcLimits,
      SwapLimits lbtcLimits,
      RevSwapFees btcFees,
      RevSwapFees lbtcFees});

  @override
  $SwapLimitsCopyWith<$Res> get btcLimits;
  @override
  $SwapLimitsCopyWith<$Res> get lbtcLimits;
  @override
  $RevSwapFeesCopyWith<$Res> get btcFees;
  @override
  $RevSwapFeesCopyWith<$Res> get lbtcFees;
}

/// @nodoc
class __$$ReverseFeesAndLimitsImplCopyWithImpl<$Res>
    extends _$ReverseFeesAndLimitsCopyWithImpl<$Res, _$ReverseFeesAndLimitsImpl>
    implements _$$ReverseFeesAndLimitsImplCopyWith<$Res> {
  __$$ReverseFeesAndLimitsImplCopyWithImpl(_$ReverseFeesAndLimitsImpl _value,
      $Res Function(_$ReverseFeesAndLimitsImpl) _then)
      : super(_value, _then);

  /// Create a copy of ReverseFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? btcLimits = null,
    Object? lbtcLimits = null,
    Object? btcFees = null,
    Object? lbtcFees = null,
  }) {
    return _then(_$ReverseFeesAndLimitsImpl(
      btcLimits: null == btcLimits
          ? _value.btcLimits
          : btcLimits // ignore: cast_nullable_to_non_nullable
              as SwapLimits,
      lbtcLimits: null == lbtcLimits
          ? _value.lbtcLimits
          : lbtcLimits // ignore: cast_nullable_to_non_nullable
              as SwapLimits,
      btcFees: null == btcFees
          ? _value.btcFees
          : btcFees // ignore: cast_nullable_to_non_nullable
              as RevSwapFees,
      lbtcFees: null == lbtcFees
          ? _value.lbtcFees
          : lbtcFees // ignore: cast_nullable_to_non_nullable
              as RevSwapFees,
    ));
  }
}

/// @nodoc

class _$ReverseFeesAndLimitsImpl implements _ReverseFeesAndLimits {
  const _$ReverseFeesAndLimitsImpl(
      {required this.btcLimits,
      required this.lbtcLimits,
      required this.btcFees,
      required this.lbtcFees});

  @override
  final SwapLimits btcLimits;
  @override
  final SwapLimits lbtcLimits;
  @override
  final RevSwapFees btcFees;
  @override
  final RevSwapFees lbtcFees;

  @override
  String toString() {
    return 'ReverseFeesAndLimits(btcLimits: $btcLimits, lbtcLimits: $lbtcLimits, btcFees: $btcFees, lbtcFees: $lbtcFees)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ReverseFeesAndLimitsImpl &&
            (identical(other.btcLimits, btcLimits) ||
                other.btcLimits == btcLimits) &&
            (identical(other.lbtcLimits, lbtcLimits) ||
                other.lbtcLimits == lbtcLimits) &&
            (identical(other.btcFees, btcFees) || other.btcFees == btcFees) &&
            (identical(other.lbtcFees, lbtcFees) ||
                other.lbtcFees == lbtcFees));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, btcLimits, lbtcLimits, btcFees, lbtcFees);

  /// Create a copy of ReverseFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ReverseFeesAndLimitsImplCopyWith<_$ReverseFeesAndLimitsImpl>
      get copyWith =>
          __$$ReverseFeesAndLimitsImplCopyWithImpl<_$ReverseFeesAndLimitsImpl>(
              this, _$identity);
}

abstract class _ReverseFeesAndLimits implements ReverseFeesAndLimits {
  const factory _ReverseFeesAndLimits(
      {required final SwapLimits btcLimits,
      required final SwapLimits lbtcLimits,
      required final RevSwapFees btcFees,
      required final RevSwapFees lbtcFees}) = _$ReverseFeesAndLimitsImpl;

  @override
  SwapLimits get btcLimits;
  @override
  SwapLimits get lbtcLimits;
  @override
  RevSwapFees get btcFees;
  @override
  RevSwapFees get lbtcFees;

  /// Create a copy of ReverseFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ReverseFeesAndLimitsImplCopyWith<_$ReverseFeesAndLimitsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SubSwapFees {
  double get percentage => throw _privateConstructorUsedError;
  int get minerFees => throw _privateConstructorUsedError;

  /// Create a copy of SubSwapFees
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SubSwapFeesCopyWith<SubSwapFees> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubSwapFeesCopyWith<$Res> {
  factory $SubSwapFeesCopyWith(
          SubSwapFees value, $Res Function(SubSwapFees) then) =
      _$SubSwapFeesCopyWithImpl<$Res, SubSwapFees>;
  @useResult
  $Res call({double percentage, int minerFees});
}

/// @nodoc
class _$SubSwapFeesCopyWithImpl<$Res, $Val extends SubSwapFees>
    implements $SubSwapFeesCopyWith<$Res> {
  _$SubSwapFeesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SubSwapFees
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? percentage = null,
    Object? minerFees = null,
  }) {
    return _then(_value.copyWith(
      percentage: null == percentage
          ? _value.percentage
          : percentage // ignore: cast_nullable_to_non_nullable
              as double,
      minerFees: null == minerFees
          ? _value.minerFees
          : minerFees // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SubSwapFeesImplCopyWith<$Res>
    implements $SubSwapFeesCopyWith<$Res> {
  factory _$$SubSwapFeesImplCopyWith(
          _$SubSwapFeesImpl value, $Res Function(_$SubSwapFeesImpl) then) =
      __$$SubSwapFeesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double percentage, int minerFees});
}

/// @nodoc
class __$$SubSwapFeesImplCopyWithImpl<$Res>
    extends _$SubSwapFeesCopyWithImpl<$Res, _$SubSwapFeesImpl>
    implements _$$SubSwapFeesImplCopyWith<$Res> {
  __$$SubSwapFeesImplCopyWithImpl(
      _$SubSwapFeesImpl _value, $Res Function(_$SubSwapFeesImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubSwapFees
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? percentage = null,
    Object? minerFees = null,
  }) {
    return _then(_$SubSwapFeesImpl(
      percentage: null == percentage
          ? _value.percentage
          : percentage // ignore: cast_nullable_to_non_nullable
              as double,
      minerFees: null == minerFees
          ? _value.minerFees
          : minerFees // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SubSwapFeesImpl implements _SubSwapFees {
  const _$SubSwapFeesImpl({required this.percentage, required this.minerFees});

  @override
  final double percentage;
  @override
  final int minerFees;

  @override
  String toString() {
    return 'SubSwapFees(percentage: $percentage, minerFees: $minerFees)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubSwapFeesImpl &&
            (identical(other.percentage, percentage) ||
                other.percentage == percentage) &&
            (identical(other.minerFees, minerFees) ||
                other.minerFees == minerFees));
  }

  @override
  int get hashCode => Object.hash(runtimeType, percentage, minerFees);

  /// Create a copy of SubSwapFees
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SubSwapFeesImplCopyWith<_$SubSwapFeesImpl> get copyWith =>
      __$$SubSwapFeesImplCopyWithImpl<_$SubSwapFeesImpl>(this, _$identity);
}

abstract class _SubSwapFees implements SubSwapFees {
  const factory _SubSwapFees(
      {required final double percentage,
      required final int minerFees}) = _$SubSwapFeesImpl;

  @override
  double get percentage;
  @override
  int get minerFees;

  /// Create a copy of SubSwapFees
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SubSwapFeesImplCopyWith<_$SubSwapFeesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SubmarineFeesAndLimits {
  SwapLimits get btcLimits => throw _privateConstructorUsedError;
  SwapLimits get lbtcLimits => throw _privateConstructorUsedError;
  SubSwapFees get btcFees => throw _privateConstructorUsedError;
  SubSwapFees get lbtcFees => throw _privateConstructorUsedError;

  /// Create a copy of SubmarineFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SubmarineFeesAndLimitsCopyWith<SubmarineFeesAndLimits> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SubmarineFeesAndLimitsCopyWith<$Res> {
  factory $SubmarineFeesAndLimitsCopyWith(SubmarineFeesAndLimits value,
          $Res Function(SubmarineFeesAndLimits) then) =
      _$SubmarineFeesAndLimitsCopyWithImpl<$Res, SubmarineFeesAndLimits>;
  @useResult
  $Res call(
      {SwapLimits btcLimits,
      SwapLimits lbtcLimits,
      SubSwapFees btcFees,
      SubSwapFees lbtcFees});

  $SwapLimitsCopyWith<$Res> get btcLimits;
  $SwapLimitsCopyWith<$Res> get lbtcLimits;
  $SubSwapFeesCopyWith<$Res> get btcFees;
  $SubSwapFeesCopyWith<$Res> get lbtcFees;
}

/// @nodoc
class _$SubmarineFeesAndLimitsCopyWithImpl<$Res,
        $Val extends SubmarineFeesAndLimits>
    implements $SubmarineFeesAndLimitsCopyWith<$Res> {
  _$SubmarineFeesAndLimitsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SubmarineFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? btcLimits = null,
    Object? lbtcLimits = null,
    Object? btcFees = null,
    Object? lbtcFees = null,
  }) {
    return _then(_value.copyWith(
      btcLimits: null == btcLimits
          ? _value.btcLimits
          : btcLimits // ignore: cast_nullable_to_non_nullable
              as SwapLimits,
      lbtcLimits: null == lbtcLimits
          ? _value.lbtcLimits
          : lbtcLimits // ignore: cast_nullable_to_non_nullable
              as SwapLimits,
      btcFees: null == btcFees
          ? _value.btcFees
          : btcFees // ignore: cast_nullable_to_non_nullable
              as SubSwapFees,
      lbtcFees: null == lbtcFees
          ? _value.lbtcFees
          : lbtcFees // ignore: cast_nullable_to_non_nullable
              as SubSwapFees,
    ) as $Val);
  }

  /// Create a copy of SubmarineFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $SwapLimitsCopyWith<$Res> get btcLimits {
    return $SwapLimitsCopyWith<$Res>(_value.btcLimits, (value) {
      return _then(_value.copyWith(btcLimits: value) as $Val);
    });
  }

  /// Create a copy of SubmarineFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $SwapLimitsCopyWith<$Res> get lbtcLimits {
    return $SwapLimitsCopyWith<$Res>(_value.lbtcLimits, (value) {
      return _then(_value.copyWith(lbtcLimits: value) as $Val);
    });
  }

  /// Create a copy of SubmarineFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $SubSwapFeesCopyWith<$Res> get btcFees {
    return $SubSwapFeesCopyWith<$Res>(_value.btcFees, (value) {
      return _then(_value.copyWith(btcFees: value) as $Val);
    });
  }

  /// Create a copy of SubmarineFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $SubSwapFeesCopyWith<$Res> get lbtcFees {
    return $SubSwapFeesCopyWith<$Res>(_value.lbtcFees, (value) {
      return _then(_value.copyWith(lbtcFees: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$SubmarineFeesAndLimitsImplCopyWith<$Res>
    implements $SubmarineFeesAndLimitsCopyWith<$Res> {
  factory _$$SubmarineFeesAndLimitsImplCopyWith(
          _$SubmarineFeesAndLimitsImpl value,
          $Res Function(_$SubmarineFeesAndLimitsImpl) then) =
      __$$SubmarineFeesAndLimitsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {SwapLimits btcLimits,
      SwapLimits lbtcLimits,
      SubSwapFees btcFees,
      SubSwapFees lbtcFees});

  @override
  $SwapLimitsCopyWith<$Res> get btcLimits;
  @override
  $SwapLimitsCopyWith<$Res> get lbtcLimits;
  @override
  $SubSwapFeesCopyWith<$Res> get btcFees;
  @override
  $SubSwapFeesCopyWith<$Res> get lbtcFees;
}

/// @nodoc
class __$$SubmarineFeesAndLimitsImplCopyWithImpl<$Res>
    extends _$SubmarineFeesAndLimitsCopyWithImpl<$Res,
        _$SubmarineFeesAndLimitsImpl>
    implements _$$SubmarineFeesAndLimitsImplCopyWith<$Res> {
  __$$SubmarineFeesAndLimitsImplCopyWithImpl(
      _$SubmarineFeesAndLimitsImpl _value,
      $Res Function(_$SubmarineFeesAndLimitsImpl) _then)
      : super(_value, _then);

  /// Create a copy of SubmarineFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? btcLimits = null,
    Object? lbtcLimits = null,
    Object? btcFees = null,
    Object? lbtcFees = null,
  }) {
    return _then(_$SubmarineFeesAndLimitsImpl(
      btcLimits: null == btcLimits
          ? _value.btcLimits
          : btcLimits // ignore: cast_nullable_to_non_nullable
              as SwapLimits,
      lbtcLimits: null == lbtcLimits
          ? _value.lbtcLimits
          : lbtcLimits // ignore: cast_nullable_to_non_nullable
              as SwapLimits,
      btcFees: null == btcFees
          ? _value.btcFees
          : btcFees // ignore: cast_nullable_to_non_nullable
              as SubSwapFees,
      lbtcFees: null == lbtcFees
          ? _value.lbtcFees
          : lbtcFees // ignore: cast_nullable_to_non_nullable
              as SubSwapFees,
    ));
  }
}

/// @nodoc

class _$SubmarineFeesAndLimitsImpl implements _SubmarineFeesAndLimits {
  const _$SubmarineFeesAndLimitsImpl(
      {required this.btcLimits,
      required this.lbtcLimits,
      required this.btcFees,
      required this.lbtcFees});

  @override
  final SwapLimits btcLimits;
  @override
  final SwapLimits lbtcLimits;
  @override
  final SubSwapFees btcFees;
  @override
  final SubSwapFees lbtcFees;

  @override
  String toString() {
    return 'SubmarineFeesAndLimits(btcLimits: $btcLimits, lbtcLimits: $lbtcLimits, btcFees: $btcFees, lbtcFees: $lbtcFees)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SubmarineFeesAndLimitsImpl &&
            (identical(other.btcLimits, btcLimits) ||
                other.btcLimits == btcLimits) &&
            (identical(other.lbtcLimits, lbtcLimits) ||
                other.lbtcLimits == lbtcLimits) &&
            (identical(other.btcFees, btcFees) || other.btcFees == btcFees) &&
            (identical(other.lbtcFees, lbtcFees) ||
                other.lbtcFees == lbtcFees));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, btcLimits, lbtcLimits, btcFees, lbtcFees);

  /// Create a copy of SubmarineFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SubmarineFeesAndLimitsImplCopyWith<_$SubmarineFeesAndLimitsImpl>
      get copyWith => __$$SubmarineFeesAndLimitsImplCopyWithImpl<
          _$SubmarineFeesAndLimitsImpl>(this, _$identity);
}

abstract class _SubmarineFeesAndLimits implements SubmarineFeesAndLimits {
  const factory _SubmarineFeesAndLimits(
      {required final SwapLimits btcLimits,
      required final SwapLimits lbtcLimits,
      required final SubSwapFees btcFees,
      required final SubSwapFees lbtcFees}) = _$SubmarineFeesAndLimitsImpl;

  @override
  SwapLimits get btcLimits;
  @override
  SwapLimits get lbtcLimits;
  @override
  SubSwapFees get btcFees;
  @override
  SubSwapFees get lbtcFees;

  /// Create a copy of SubmarineFeesAndLimits
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SubmarineFeesAndLimitsImplCopyWith<_$SubmarineFeesAndLimitsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SwapLimits {
  int get minimal => throw _privateConstructorUsedError;
  int get maximal => throw _privateConstructorUsedError;

  /// Create a copy of SwapLimits
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SwapLimitsCopyWith<SwapLimits> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SwapLimitsCopyWith<$Res> {
  factory $SwapLimitsCopyWith(
          SwapLimits value, $Res Function(SwapLimits) then) =
      _$SwapLimitsCopyWithImpl<$Res, SwapLimits>;
  @useResult
  $Res call({int minimal, int maximal});
}

/// @nodoc
class _$SwapLimitsCopyWithImpl<$Res, $Val extends SwapLimits>
    implements $SwapLimitsCopyWith<$Res> {
  _$SwapLimitsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SwapLimits
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? minimal = null,
    Object? maximal = null,
  }) {
    return _then(_value.copyWith(
      minimal: null == minimal
          ? _value.minimal
          : minimal // ignore: cast_nullable_to_non_nullable
              as int,
      maximal: null == maximal
          ? _value.maximal
          : maximal // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SwapLimitsImplCopyWith<$Res>
    implements $SwapLimitsCopyWith<$Res> {
  factory _$$SwapLimitsImplCopyWith(
          _$SwapLimitsImpl value, $Res Function(_$SwapLimitsImpl) then) =
      __$$SwapLimitsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int minimal, int maximal});
}

/// @nodoc
class __$$SwapLimitsImplCopyWithImpl<$Res>
    extends _$SwapLimitsCopyWithImpl<$Res, _$SwapLimitsImpl>
    implements _$$SwapLimitsImplCopyWith<$Res> {
  __$$SwapLimitsImplCopyWithImpl(
      _$SwapLimitsImpl _value, $Res Function(_$SwapLimitsImpl) _then)
      : super(_value, _then);

  /// Create a copy of SwapLimits
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? minimal = null,
    Object? maximal = null,
  }) {
    return _then(_$SwapLimitsImpl(
      minimal: null == minimal
          ? _value.minimal
          : minimal // ignore: cast_nullable_to_non_nullable
              as int,
      maximal: null == maximal
          ? _value.maximal
          : maximal // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SwapLimitsImpl implements _SwapLimits {
  const _$SwapLimitsImpl({required this.minimal, required this.maximal});

  @override
  final int minimal;
  @override
  final int maximal;

  @override
  String toString() {
    return 'SwapLimits(minimal: $minimal, maximal: $maximal)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SwapLimitsImpl &&
            (identical(other.minimal, minimal) || other.minimal == minimal) &&
            (identical(other.maximal, maximal) || other.maximal == maximal));
  }

  @override
  int get hashCode => Object.hash(runtimeType, minimal, maximal);

  /// Create a copy of SwapLimits
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SwapLimitsImplCopyWith<_$SwapLimitsImpl> get copyWith =>
      __$$SwapLimitsImplCopyWithImpl<_$SwapLimitsImpl>(this, _$identity);
}

abstract class _SwapLimits implements SwapLimits {
  const factory _SwapLimits(
      {required final int minimal,
      required final int maximal}) = _$SwapLimitsImpl;

  @override
  int get minimal;
  @override
  int get maximal;

  /// Create a copy of SwapLimits
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SwapLimitsImplCopyWith<_$SwapLimitsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
