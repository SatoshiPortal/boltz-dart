// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

// These functions are ignored because they are not marked as `pub`: `extract_id`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `eq`

/// Liquid-Lightning Swap Class
class LbtcLnSwap {
  final String id;
  final SwapType kind;
  final Chain network;
  final KeyPair keys;
  final BigInt keyIndex;
  final PreImage preimage;
  final LBtcSwapScriptStr swapScript;
  final String invoice;
  final BigInt outAmount;
  final String scriptAddress;
  final String blindingKey;
  final String electrumUrl;
  final String boltzUrl;
  final String? referralId;

  const LbtcLnSwap({
    required this.id,
    required this.kind,
    required this.network,
    required this.keys,
    required this.keyIndex,
    required this.preimage,
    required this.swapScript,
    required this.invoice,
    required this.outAmount,
    required this.scriptAddress,
    required this.blindingKey,
    required this.electrumUrl,
    required this.boltzUrl,
    this.referralId,
  });

  /// Broadcast using boltz's electrum server
  Future<String> broadcastBoltz({required String signedHex}) => BoltzCore
      .instance.api
      .crateApiLbtcLnLbtcLnSwapBroadcastBoltz(that: this, signedHex: signedHex);

  /// Broadcast using your own electrum server that was used to create the swap
  Future<String> broadcastLocal({required String signedHex}) => BoltzCore
      .instance.api
      .crateApiLbtcLnLbtcLnSwapBroadcastLocal(that: this, signedHex: signedHex);

  /// Used to claim a reverse swap.
  Future<String> claim(
          {required String outAddress,
          required TxFee minerFee,
          required bool tryCooperate}) =>
      BoltzCore.instance.api.crateApiLbtcLnLbtcLnSwapClaim(
          that: this,
          outAddress: outAddress,
          minerFee: minerFee,
          tryCooperate: tryCooperate);

  /// After boltz completes a submarine swap, call this function to close the swap cooperatively using Musig.
  /// If this function is not called within ~1 hour, the swap will be closed via the script path.
  /// The benefit of a cooperative close is that the onchain footprint is smaller and makes the transaction look like a single sig tx, while the script path spend is clearly a swap tx.
  Future<void> coopCloseSubmarine() =>
      BoltzCore.instance.api.crateApiLbtcLnLbtcLnSwapCoopCloseSubmarine(
        that: this,
      );

  /// Parse from a JSON string.
  static Future<LbtcLnSwap> fromJson({required String jsonStr}) =>
      BoltzCore.instance.api.crateApiLbtcLnLbtcLnSwapFromJson(jsonStr: jsonStr);

  /// Retrieves the preimage for a completed submarine swap.
  Future<String> getCompletedSubmarinePreimage() => BoltzCore.instance.api
          .crateApiLbtcLnLbtcLnSwapGetCompletedSubmarinePreimage(
        that: this,
      );

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Manually create the class. Primarily used when recovering a swap.
  static Future<LbtcLnSwap> newInstance(
          {required String id,
          required SwapType kind,
          required Chain network,
          required KeyPair keys,
          required BigInt keyIndex,
          required PreImage preimage,
          required LBtcSwapScriptStr swapScript,
          required String invoice,
          required BigInt outAmount,
          required String outAddress,
          required String blindingKey,
          required String electrumUrl,
          required String boltzUrl,
          String? referralId}) =>
      BoltzCore.instance.api.crateApiLbtcLnLbtcLnSwapNew(
          id: id,
          kind: kind,
          network: network,
          keys: keys,
          keyIndex: keyIndex,
          preimage: preimage,
          swapScript: swapScript,
          invoice: invoice,
          outAmount: outAmount,
          outAddress: outAddress,
          blindingKey: blindingKey,
          electrumUrl: electrumUrl,
          boltzUrl: boltzUrl,
          referralId: referralId);

  /// Used to create the class when starting a reverse swap to receive Liquid via Lightning.
  /// Note: The mnemonic should be your wallets mnemonic, the library will derive the keys for the swap from the appropriate path.
  /// The client is expected to manage (increment) the use of index to ensure keys are not reused.
  static Future<LbtcLnSwap> newReverse(
          {required String mnemonic,
          String? passphrase,
          required BigInt index,
          required BigInt outAmount,
          String? outAddress,
          required Chain network,
          required String electrumUrl,
          required String boltzUrl,
          String? description,
          String? referralId}) =>
      BoltzCore.instance.api.crateApiLbtcLnLbtcLnSwapNewReverse(
          mnemonic: mnemonic,
          passphrase: passphrase,
          index: index,
          outAmount: outAmount,
          outAddress: outAddress,
          network: network,
          electrumUrl: electrumUrl,
          boltzUrl: boltzUrl,
          description: description,
          referralId: referralId);

  /// Used to create the class when starting a submarine swap to pay a lightning invoice with Liquid.
  /// Note: The mnemonic should be your wallets mnemonic, the library will derive the keys for the swap from the appropriate path.
  /// The client is expected to manage (increment) the use of index to ensure keys are not reused.
  static Future<LbtcLnSwap> newSubmarine(
          {required String mnemonic,
          String? passphrase,
          required BigInt index,
          required String invoice,
          required Chain network,
          required String electrumUrl,
          required String boltzUrl,
          String? referralId}) =>
      BoltzCore.instance.api.crateApiLbtcLnLbtcLnSwapNewSubmarine(
          mnemonic: mnemonic,
          passphrase: passphrase,
          index: index,
          invoice: invoice,
          network: network,
          electrumUrl: electrumUrl,
          boltzUrl: boltzUrl,
          referralId: referralId);

  /// Used to refund a failed submarine swap.
  Future<String> refund(
          {required String outAddress,
          required TxFee minerFee,
          required bool tryCooperate}) =>
      BoltzCore.instance.api.crateApiLbtcLnLbtcLnSwapRefund(
          that: this,
          outAddress: outAddress,
          minerFee: minerFee,
          tryCooperate: tryCooperate);

  /// Convert instance to a JSON string.
  Future<String> toJson() =>
      BoltzCore.instance.api.crateApiLbtcLnLbtcLnSwapToJson(
        that: this,
      );

  /// Get the size of the transaction. Can be used to estimate the absolute miner fees required, given a fee rate.
  Future<BigInt> txSize({required bool isCooperative}) => BoltzCore.instance.api
      .crateApiLbtcLnLbtcLnSwapTxSize(that: this, isCooperative: isCooperative);

  @override
  int get hashCode =>
      id.hashCode ^
      kind.hashCode ^
      network.hashCode ^
      keys.hashCode ^
      keyIndex.hashCode ^
      preimage.hashCode ^
      swapScript.hashCode ^
      invoice.hashCode ^
      outAmount.hashCode ^
      scriptAddress.hashCode ^
      blindingKey.hashCode ^
      electrumUrl.hashCode ^
      boltzUrl.hashCode ^
      referralId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LbtcLnSwap &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          kind == other.kind &&
          network == other.network &&
          keys == other.keys &&
          keyIndex == other.keyIndex &&
          preimage == other.preimage &&
          swapScript == other.swapScript &&
          invoice == other.invoice &&
          outAmount == other.outAmount &&
          scriptAddress == other.scriptAddress &&
          blindingKey == other.blindingKey &&
          electrumUrl == other.electrumUrl &&
          boltzUrl == other.boltzUrl &&
          referralId == other.referralId;
}
