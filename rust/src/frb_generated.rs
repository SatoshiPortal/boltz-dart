// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.31.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::transform_result_dco;
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.0.0-dev.31";

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire_btc_ln_v_1_swap_claim_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnV1Swap>,
    out_address: impl CstDecode<String>,
    abs_fee: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_v_1_swap_claim",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_abs_fee = abs_fee.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::btc_ln::BtcLnV1Swap::claim(&api_that, api_out_address, api_abs_fee)
                })())
            }
        },
    )
}
fn wire_btc_ln_v_1_swap_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<String>,
    kind: impl CstDecode<crate::api::types::SwapType>,
    network: impl CstDecode<crate::api::types::Chain>,
    keys: impl CstDecode<crate::api::types::KeyPair>,
    preimage: impl CstDecode<crate::api::types::PreImage>,
    redeem_script: impl CstDecode<String>,
    invoice: impl CstDecode<String>,
    script_address: impl CstDecode<String>,
    out_amount: impl CstDecode<u64>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_v_1_swap_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_kind = kind.cst_decode();
            let api_network = network.cst_decode();
            let api_keys = keys.cst_decode();
            let api_preimage = preimage.cst_decode();
            let api_redeem_script = redeem_script.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_script_address = script_address.cst_decode();
            let api_out_amount = out_amount.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::btc_ln::BtcLnV1Swap::new(
                        api_id,
                        api_kind,
                        api_network,
                        api_keys,
                        api_preimage,
                        api_redeem_script,
                        api_invoice,
                        api_script_address,
                        api_out_amount,
                        api_electrum_url,
                        api_boltz_url,
                    ))
                })())
            }
        },
    )
}
fn wire_btc_ln_v_1_swap_new_reverse_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
    index: impl CstDecode<u64>,
    out_amount: impl CstDecode<u64>,
    network: impl CstDecode<crate::api::types::Chain>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    pair_hash: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_v_1_swap_new_reverse",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            let api_index = index.cst_decode();
            let api_out_amount = out_amount.cst_decode();
            let api_network = network.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_pair_hash = pair_hash.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::btc_ln::BtcLnV1Swap::new_reverse(
                        api_mnemonic,
                        api_index,
                        api_out_amount,
                        api_network,
                        api_electrum_url,
                        api_boltz_url,
                        api_pair_hash,
                    )
                })())
            }
        },
    )
}
fn wire_btc_ln_v_1_swap_new_submarine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
    index: impl CstDecode<u64>,
    invoice: impl CstDecode<String>,
    network: impl CstDecode<crate::api::types::Chain>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    pair_hash: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_v_1_swap_new_submarine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            let api_index = index.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_network = network.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_pair_hash = pair_hash.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::btc_ln::BtcLnV1Swap::new_submarine(
                        api_mnemonic,
                        api_index,
                        api_invoice,
                        api_network,
                        api_electrum_url,
                        api_boltz_url,
                        api_pair_hash,
                    )
                })())
            }
        },
    )
}
fn wire_btc_ln_v_1_swap_refund_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnV1Swap>,
    out_address: impl CstDecode<String>,
    abs_fee: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_v_1_swap_refund",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_abs_fee = abs_fee.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::btc_ln::BtcLnV1Swap::refund(&api_that, api_out_address, api_abs_fee)
                })())
            }
        },
    )
}
fn wire_btc_ln_v_1_swap_tx_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnV1Swap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_v_1_swap_tx_size",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::btc_ln::BtcLnV1Swap::tx_size(&api_that)
                })())
            }
        },
    )
}
fn wire_btc_ln_v_2_swap_claim_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnV2Swap>,
    out_address: impl CstDecode<String>,
    abs_fee: impl CstDecode<u64>,
    try_cooperate: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_v_2_swap_claim",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_abs_fee = abs_fee.cst_decode();
            let api_try_cooperate = try_cooperate.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::btc_ln::BtcLnV2Swap::claim(
                        &api_that,
                        api_out_address,
                        api_abs_fee,
                        api_try_cooperate,
                    )
                })())
            }
        },
    )
}
fn wire_btc_ln_v_2_swap_coop_close_submarine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnV2Swap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_v_2_swap_coop_close_submarine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::btc_ln::BtcLnV2Swap::coop_close_submarine(&api_that)
                })())
            }
        },
    )
}
fn wire_btc_ln_v_2_swap_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<String>,
    kind: impl CstDecode<crate::api::types::SwapType>,
    network: impl CstDecode<crate::api::types::Chain>,
    keys: impl CstDecode<crate::api::types::KeyPair>,
    preimage: impl CstDecode<crate::api::types::PreImage>,
    swap_script: impl CstDecode<crate::api::types::BtcSwapScriptV2Str>,
    invoice: impl CstDecode<String>,
    script_address: impl CstDecode<String>,
    out_amount: impl CstDecode<u64>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_v_2_swap_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_kind = kind.cst_decode();
            let api_network = network.cst_decode();
            let api_keys = keys.cst_decode();
            let api_preimage = preimage.cst_decode();
            let api_swap_script = swap_script.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_script_address = script_address.cst_decode();
            let api_out_amount = out_amount.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::btc_ln::BtcLnV2Swap::new(
                        api_id,
                        api_kind,
                        api_network,
                        api_keys,
                        api_preimage,
                        api_swap_script,
                        api_invoice,
                        api_script_address,
                        api_out_amount,
                        api_electrum_url,
                        api_boltz_url,
                    ))
                })())
            }
        },
    )
}
fn wire_btc_ln_v_2_swap_new_reverse_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
    index: impl CstDecode<u64>,
    out_amount: impl CstDecode<u64>,
    network: impl CstDecode<crate::api::types::Chain>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_v_2_swap_new_reverse",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            let api_index = index.cst_decode();
            let api_out_amount = out_amount.cst_decode();
            let api_network = network.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::btc_ln::BtcLnV2Swap::new_reverse(
                        api_mnemonic,
                        api_index,
                        api_out_amount,
                        api_network,
                        api_electrum_url,
                        api_boltz_url,
                    )
                })())
            }
        },
    )
}
fn wire_btc_ln_v_2_swap_new_submarine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
    index: impl CstDecode<u64>,
    invoice: impl CstDecode<String>,
    network: impl CstDecode<crate::api::types::Chain>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_v_2_swap_new_submarine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            let api_index = index.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_network = network.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::btc_ln::BtcLnV2Swap::new_submarine(
                        api_mnemonic,
                        api_index,
                        api_invoice,
                        api_network,
                        api_electrum_url,
                        api_boltz_url,
                    )
                })())
            }
        },
    )
}
fn wire_btc_ln_v_2_swap_refund_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnV2Swap>,
    out_address: impl CstDecode<String>,
    abs_fee: impl CstDecode<u64>,
    try_cooperate: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_v_2_swap_refund",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_abs_fee = abs_fee.cst_decode();
            let api_try_cooperate = try_cooperate.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::btc_ln::BtcLnV2Swap::refund(
                        &api_that,
                        api_out_address,
                        api_abs_fee,
                        api_try_cooperate,
                    )
                })())
            }
        },
    )
}
fn wire_btc_ln_v_2_swap_tx_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnV2Swap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_v_2_swap_tx_size",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::btc_ln::BtcLnV2Swap::tx_size(&api_that)
                })())
            }
        },
    )
}
fn wire_boltz_error_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    kind: impl CstDecode<String>,
    message: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "boltz_error_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_kind = kind.cst_decode();
            let api_message = message.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::error::BoltzError::new(api_kind, api_message))
                })())
            }
        },
    )
}
fn wire_lbtc_ln_v_1_swap_claim_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnV1Swap>,
    out_address: impl CstDecode<String>,
    abs_fee: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_v_1_swap_claim",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_abs_fee = abs_fee.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::lbtc_ln::LbtcLnV1Swap::claim(
                        &api_that,
                        api_out_address,
                        api_abs_fee,
                    )
                })())
            }
        },
    )
}
fn wire_lbtc_ln_v_1_swap_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<String>,
    kind: impl CstDecode<crate::api::types::SwapType>,
    network: impl CstDecode<crate::api::types::Chain>,
    keys: impl CstDecode<crate::api::types::KeyPair>,
    preimage: impl CstDecode<crate::api::types::PreImage>,
    redeem_script: impl CstDecode<String>,
    invoice: impl CstDecode<String>,
    out_amount: impl CstDecode<u64>,
    out_address: impl CstDecode<String>,
    blinding_key: impl CstDecode<String>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_v_1_swap_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_kind = kind.cst_decode();
            let api_network = network.cst_decode();
            let api_keys = keys.cst_decode();
            let api_preimage = preimage.cst_decode();
            let api_redeem_script = redeem_script.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_out_amount = out_amount.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_blinding_key = blinding_key.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::lbtc_ln::LbtcLnV1Swap::new(
                        api_id,
                        api_kind,
                        api_network,
                        api_keys,
                        api_preimage,
                        api_redeem_script,
                        api_invoice,
                        api_out_amount,
                        api_out_address,
                        api_blinding_key,
                        api_electrum_url,
                        api_boltz_url,
                    ))
                })())
            }
        },
    )
}
fn wire_lbtc_ln_v_1_swap_new_reverse_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
    index: impl CstDecode<u64>,
    out_amount: impl CstDecode<u64>,
    network: impl CstDecode<crate::api::types::Chain>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    pair_hash: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_v_1_swap_new_reverse",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            let api_index = index.cst_decode();
            let api_out_amount = out_amount.cst_decode();
            let api_network = network.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_pair_hash = pair_hash.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::lbtc_ln::LbtcLnV1Swap::new_reverse(
                        api_mnemonic,
                        api_index,
                        api_out_amount,
                        api_network,
                        api_electrum_url,
                        api_boltz_url,
                        api_pair_hash,
                    )
                })())
            }
        },
    )
}
fn wire_lbtc_ln_v_1_swap_new_submarine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
    index: impl CstDecode<u64>,
    invoice: impl CstDecode<String>,
    network: impl CstDecode<crate::api::types::Chain>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    pair_hash: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_v_1_swap_new_submarine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            let api_index = index.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_network = network.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_pair_hash = pair_hash.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::lbtc_ln::LbtcLnV1Swap::new_submarine(
                        api_mnemonic,
                        api_index,
                        api_invoice,
                        api_network,
                        api_electrum_url,
                        api_boltz_url,
                        api_pair_hash,
                    )
                })())
            }
        },
    )
}
fn wire_lbtc_ln_v_1_swap_refund_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnV1Swap>,
    out_address: impl CstDecode<String>,
    abs_fee: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_v_1_swap_refund",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_abs_fee = abs_fee.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::lbtc_ln::LbtcLnV1Swap::refund(
                        &api_that,
                        api_out_address,
                        api_abs_fee,
                    )
                })())
            }
        },
    )
}
fn wire_lbtc_ln_v_1_swap_tx_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    swap: impl CstDecode<crate::api::lbtc_ln::LbtcLnV1Swap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_v_1_swap_tx_size",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_swap = swap.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::lbtc_ln::LbtcLnV1Swap::tx_size(api_swap)
                })())
            }
        },
    )
}
fn wire_lbtc_ln_v_2_swap_claim_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnV2Swap>,
    out_address: impl CstDecode<String>,
    abs_fee: impl CstDecode<u64>,
    try_cooperate: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_v_2_swap_claim",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_abs_fee = abs_fee.cst_decode();
            let api_try_cooperate = try_cooperate.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::lbtc_ln::LbtcLnV2Swap::claim(
                        &api_that,
                        api_out_address,
                        api_abs_fee,
                        api_try_cooperate,
                    )
                })())
            }
        },
    )
}
fn wire_lbtc_ln_v_2_swap_coop_close_submarine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnV2Swap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_v_2_swap_coop_close_submarine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::lbtc_ln::LbtcLnV2Swap::coop_close_submarine(&api_that)
                })())
            }
        },
    )
}
fn wire_lbtc_ln_v_2_swap_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<String>,
    kind: impl CstDecode<crate::api::types::SwapType>,
    network: impl CstDecode<crate::api::types::Chain>,
    keys: impl CstDecode<crate::api::types::KeyPair>,
    preimage: impl CstDecode<crate::api::types::PreImage>,
    swap_script: impl CstDecode<crate::api::types::LBtcSwapScriptV2Str>,
    invoice: impl CstDecode<String>,
    out_amount: impl CstDecode<u64>,
    out_address: impl CstDecode<String>,
    blinding_key: impl CstDecode<String>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_v_2_swap_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_kind = kind.cst_decode();
            let api_network = network.cst_decode();
            let api_keys = keys.cst_decode();
            let api_preimage = preimage.cst_decode();
            let api_swap_script = swap_script.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_out_amount = out_amount.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_blinding_key = blinding_key.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::lbtc_ln::LbtcLnV2Swap::new(
                        api_id,
                        api_kind,
                        api_network,
                        api_keys,
                        api_preimage,
                        api_swap_script,
                        api_invoice,
                        api_out_amount,
                        api_out_address,
                        api_blinding_key,
                        api_electrum_url,
                        api_boltz_url,
                    ))
                })())
            }
        },
    )
}
fn wire_lbtc_ln_v_2_swap_new_reverse_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
    index: impl CstDecode<u64>,
    out_amount: impl CstDecode<u64>,
    network: impl CstDecode<crate::api::types::Chain>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_v_2_swap_new_reverse",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            let api_index = index.cst_decode();
            let api_out_amount = out_amount.cst_decode();
            let api_network = network.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::lbtc_ln::LbtcLnV2Swap::new_reverse(
                        api_mnemonic,
                        api_index,
                        api_out_amount,
                        api_network,
                        api_electrum_url,
                        api_boltz_url,
                    )
                })())
            }
        },
    )
}
fn wire_lbtc_ln_v_2_swap_new_submarine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
    index: impl CstDecode<u64>,
    invoice: impl CstDecode<String>,
    network: impl CstDecode<crate::api::types::Chain>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_v_2_swap_new_submarine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            let api_index = index.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_network = network.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::lbtc_ln::LbtcLnV2Swap::new_submarine(
                        api_mnemonic,
                        api_index,
                        api_invoice,
                        api_network,
                        api_electrum_url,
                        api_boltz_url,
                    )
                })())
            }
        },
    )
}
fn wire_lbtc_ln_v_2_swap_refund_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnV2Swap>,
    out_address: impl CstDecode<String>,
    abs_fee: impl CstDecode<u64>,
    try_cooperate: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_v_2_swap_refund",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_abs_fee = abs_fee.cst_decode();
            let api_try_cooperate = try_cooperate.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::lbtc_ln::LbtcLnV2Swap::refund(
                        &api_that,
                        api_out_address,
                        api_abs_fee,
                        api_try_cooperate,
                    )
                })())
            }
        },
    )
}
fn wire_lbtc_ln_v_2_swap_tx_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnV2Swap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_v_2_swap_tx_size",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::lbtc_ln::LbtcLnV2Swap::tx_size(&api_that)
                })())
            }
        },
    )
}
fn wire_all_fees_fetch_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    boltz_url: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "all_fees_fetch",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_boltz_url = boltz_url.cst_decode();
            move |context| {
                transform_result_dco((move || crate::api::types::AllFees::fetch(api_boltz_url))())
            }
        },
    )
}
fn wire_btc_swap_script_v_2_str_new_impl(
    swap_type: impl CstDecode<crate::api::types::SwapType>,
    funding_addrs: impl CstDecode<Option<String>>,
    hashlock: impl CstDecode<String>,
    receiver_pubkey: impl CstDecode<String>,
    locktime: impl CstDecode<u32>,
    sender_pubkey: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_swap_script_v_2_str_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_swap_type = swap_type.cst_decode();
            let api_funding_addrs = funding_addrs.cst_decode();
            let api_hashlock = hashlock.cst_decode();
            let api_receiver_pubkey = receiver_pubkey.cst_decode();
            let api_locktime = locktime.cst_decode();
            let api_sender_pubkey = sender_pubkey.cst_decode();
            transform_result_dco((move || {
                Result::<_, ()>::Ok(crate::api::types::BtcSwapScriptV2Str::new(
                    api_swap_type,
                    api_funding_addrs,
                    api_hashlock,
                    api_receiver_pubkey,
                    api_locktime,
                    api_sender_pubkey,
                ))
            })())
        },
    )
}
fn wire_decoded_invoice_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    s: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decoded_invoice_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_s = s.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::types::DecodedInvoice::from_string(api_s)
                })())
            }
        },
    )
}
fn wire_key_pair_generate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
    network: impl CstDecode<crate::api::types::Chain>,
    index: impl CstDecode<u64>,
    swap_type: impl CstDecode<crate::api::types::SwapType>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "key_pair_generate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            let api_network = network.cst_decode();
            let api_index = index.cst_decode();
            let api_swap_type = swap_type.cst_decode();
            move |context| {
                transform_result_dco((move || {
                    crate::api::types::KeyPair::generate(
                        api_mnemonic,
                        api_network,
                        api_index,
                        api_swap_type,
                    )
                })())
            }
        },
    )
}
fn wire_key_pair_new_impl(
    secret_key: impl CstDecode<String>,
    public_key: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "key_pair_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_secret_key = secret_key.cst_decode();
            let api_public_key = public_key.cst_decode();
            transform_result_dco((move || {
                Result::<_, ()>::Ok(crate::api::types::KeyPair::new(
                    api_secret_key,
                    api_public_key,
                ))
            })())
        },
    )
}
fn wire_l_btc_swap_script_v_2_str_new_impl(
    swap_type: impl CstDecode<crate::api::types::SwapType>,
    funding_addrs: impl CstDecode<Option<String>>,
    hashlock: impl CstDecode<String>,
    receiver_pubkey: impl CstDecode<String>,
    locktime: impl CstDecode<u32>,
    sender_pubkey: impl CstDecode<String>,
    blinding_key: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "l_btc_swap_script_v_2_str_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_swap_type = swap_type.cst_decode();
            let api_funding_addrs = funding_addrs.cst_decode();
            let api_hashlock = hashlock.cst_decode();
            let api_receiver_pubkey = receiver_pubkey.cst_decode();
            let api_locktime = locktime.cst_decode();
            let api_sender_pubkey = sender_pubkey.cst_decode();
            let api_blinding_key = blinding_key.cst_decode();
            transform_result_dco((move || {
                Result::<_, ()>::Ok(crate::api::types::LBtcSwapScriptV2Str::new(
                    api_swap_type,
                    api_funding_addrs,
                    api_hashlock,
                    api_receiver_pubkey,
                    api_locktime,
                    api_sender_pubkey,
                    api_blinding_key,
                ))
            })())
        },
    )
}
fn wire_pre_image_generate_impl(port_: flutter_rust_bridge::for_generated::MessagePort) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "pre_image_generate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco((move || {
                    Result::<_, ()>::Ok(crate::api::types::PreImage::generate())
                })())
            }
        },
    )
}
fn wire_pre_image_new_impl(
    value: impl CstDecode<String>,
    sha256: impl CstDecode<String>,
    hash160: impl CstDecode<String>,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartDco {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::DcoCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "pre_image_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let api_value = value.cst_decode();
            let api_sha256 = sha256.cst_decode();
            let api_hash160 = hash160.cst_decode();
            transform_result_dco((move || {
                Result::<_, ()>::Ok(crate::api::types::PreImage::new(
                    api_value,
                    api_sha256,
                    api_hash160,
                ))
            })())
        },
    )
}

// Section: dart2rust

impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<crate::api::types::Chain> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Chain {
        match self {
            0 => crate::api::types::Chain::Bitcoin,
            1 => crate::api::types::Chain::BitcoinTestnet,
            2 => crate::api::types::Chain::Liquid,
            3 => crate::api::types::Chain::LiquidTestnet,
            _ => unreachable!("Invalid variant for Chain: {}", self),
        }
    }
}
impl CstDecode<f64> for f64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> f64 {
        self
    }
}
impl CstDecode<i32> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<crate::api::types::SwapType> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::SwapType {
        match self {
            0 => crate::api::types::SwapType::Submarine,
            1 => crate::api::types::SwapType::Reverse,
            _ => unreachable!("Invalid variant for SwapType: {}", self),
        }
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u64> for u64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<usize> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self
    }
}
impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::types::AllFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_btcLimits = <crate::api::types::Limits>::sse_decode(deserializer);
        let mut var_lbtcLimits = <crate::api::types::Limits>::sse_decode(deserializer);
        let mut var_btcSubmarine = <crate::api::types::SubmarineSwapFees>::sse_decode(deserializer);
        let mut var_btcReverse = <crate::api::types::ReverseSwapFees>::sse_decode(deserializer);
        let mut var_lbtcSubmarine =
            <crate::api::types::SubmarineSwapFees>::sse_decode(deserializer);
        let mut var_lbtcReverse = <crate::api::types::ReverseSwapFees>::sse_decode(deserializer);
        let mut var_btcPairHash = <String>::sse_decode(deserializer);
        let mut var_lbtcPairHash = <String>::sse_decode(deserializer);
        return crate::api::types::AllFees {
            btc_limits: var_btcLimits,
            lbtc_limits: var_lbtcLimits,
            btc_submarine: var_btcSubmarine,
            btc_reverse: var_btcReverse,
            lbtc_submarine: var_lbtcSubmarine,
            lbtc_reverse: var_lbtcReverse,
            btc_pair_hash: var_btcPairHash,
            lbtc_pair_hash: var_lbtcPairHash,
        };
    }
}

impl SseDecode for crate::api::error::BoltzError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_kind = <String>::sse_decode(deserializer);
        let mut var_message = <String>::sse_decode(deserializer);
        return crate::api::error::BoltzError {
            kind: var_kind,
            message: var_message,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::btc_ln::BtcLnV1Swap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_kind = <crate::api::types::SwapType>::sse_decode(deserializer);
        let mut var_network = <crate::api::types::Chain>::sse_decode(deserializer);
        let mut var_keys = <crate::api::types::KeyPair>::sse_decode(deserializer);
        let mut var_preimage = <crate::api::types::PreImage>::sse_decode(deserializer);
        let mut var_redeemScript = <String>::sse_decode(deserializer);
        let mut var_invoice = <String>::sse_decode(deserializer);
        let mut var_scriptAddress = <String>::sse_decode(deserializer);
        let mut var_outAmount = <u64>::sse_decode(deserializer);
        let mut var_electrumUrl = <String>::sse_decode(deserializer);
        let mut var_boltzUrl = <String>::sse_decode(deserializer);
        return crate::api::btc_ln::BtcLnV1Swap {
            id: var_id,
            kind: var_kind,
            network: var_network,
            keys: var_keys,
            preimage: var_preimage,
            redeem_script: var_redeemScript,
            invoice: var_invoice,
            script_address: var_scriptAddress,
            out_amount: var_outAmount,
            electrum_url: var_electrumUrl,
            boltz_url: var_boltzUrl,
        };
    }
}

impl SseDecode for crate::api::btc_ln::BtcLnV2Swap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_kind = <crate::api::types::SwapType>::sse_decode(deserializer);
        let mut var_network = <crate::api::types::Chain>::sse_decode(deserializer);
        let mut var_keys = <crate::api::types::KeyPair>::sse_decode(deserializer);
        let mut var_preimage = <crate::api::types::PreImage>::sse_decode(deserializer);
        let mut var_swapScript = <crate::api::types::BtcSwapScriptV2Str>::sse_decode(deserializer);
        let mut var_invoice = <String>::sse_decode(deserializer);
        let mut var_scriptAddress = <String>::sse_decode(deserializer);
        let mut var_outAmount = <u64>::sse_decode(deserializer);
        let mut var_electrumUrl = <String>::sse_decode(deserializer);
        let mut var_boltzUrl = <String>::sse_decode(deserializer);
        return crate::api::btc_ln::BtcLnV2Swap {
            id: var_id,
            kind: var_kind,
            network: var_network,
            keys: var_keys,
            preimage: var_preimage,
            swap_script: var_swapScript,
            invoice: var_invoice,
            script_address: var_scriptAddress,
            out_amount: var_outAmount,
            electrum_url: var_electrumUrl,
            boltz_url: var_boltzUrl,
        };
    }
}

impl SseDecode for crate::api::types::BtcSwapScriptV2Str {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_swapType = <crate::api::types::SwapType>::sse_decode(deserializer);
        let mut var_fundingAddrs = <Option<String>>::sse_decode(deserializer);
        let mut var_hashlock = <String>::sse_decode(deserializer);
        let mut var_receiverPubkey = <String>::sse_decode(deserializer);
        let mut var_locktime = <u32>::sse_decode(deserializer);
        let mut var_senderPubkey = <String>::sse_decode(deserializer);
        return crate::api::types::BtcSwapScriptV2Str {
            swap_type: var_swapType,
            funding_addrs: var_fundingAddrs,
            hashlock: var_hashlock,
            receiver_pubkey: var_receiverPubkey,
            locktime: var_locktime,
            sender_pubkey: var_senderPubkey,
        };
    }
}

impl SseDecode for crate::api::types::Chain {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::Chain::Bitcoin,
            1 => crate::api::types::Chain::BitcoinTestnet,
            2 => crate::api::types::Chain::Liquid,
            3 => crate::api::types::Chain::LiquidTestnet,
            _ => unreachable!("Invalid variant for Chain: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::DecodedInvoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_msats = <u64>::sse_decode(deserializer);
        let mut var_expiry = <u64>::sse_decode(deserializer);
        let mut var_expiresIn = <u64>::sse_decode(deserializer);
        let mut var_expiresAt = <u64>::sse_decode(deserializer);
        let mut var_isExpired = <bool>::sse_decode(deserializer);
        let mut var_network = <String>::sse_decode(deserializer);
        let mut var_cltvExpDelta = <u64>::sse_decode(deserializer);
        return crate::api::types::DecodedInvoice {
            msats: var_msats,
            expiry: var_expiry,
            expires_in: var_expiresIn,
            expires_at: var_expiresAt,
            is_expired: var_isExpired,
            network: var_network,
            cltv_exp_delta: var_cltvExpDelta,
        };
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::types::KeyPair {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_secretKey = <String>::sse_decode(deserializer);
        let mut var_publicKey = <String>::sse_decode(deserializer);
        return crate::api::types::KeyPair {
            secret_key: var_secretKey,
            public_key: var_publicKey,
        };
    }
}

impl SseDecode for crate::api::types::LBtcSwapScriptV2Str {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_swapType = <crate::api::types::SwapType>::sse_decode(deserializer);
        let mut var_fundingAddrs = <Option<String>>::sse_decode(deserializer);
        let mut var_hashlock = <String>::sse_decode(deserializer);
        let mut var_receiverPubkey = <String>::sse_decode(deserializer);
        let mut var_locktime = <u32>::sse_decode(deserializer);
        let mut var_senderPubkey = <String>::sse_decode(deserializer);
        let mut var_blindingKey = <String>::sse_decode(deserializer);
        return crate::api::types::LBtcSwapScriptV2Str {
            swap_type: var_swapType,
            funding_addrs: var_fundingAddrs,
            hashlock: var_hashlock,
            receiver_pubkey: var_receiverPubkey,
            locktime: var_locktime,
            sender_pubkey: var_senderPubkey,
            blinding_key: var_blindingKey,
        };
    }
}

impl SseDecode for crate::api::lbtc_ln::LbtcLnV1Swap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_kind = <crate::api::types::SwapType>::sse_decode(deserializer);
        let mut var_network = <crate::api::types::Chain>::sse_decode(deserializer);
        let mut var_keys = <crate::api::types::KeyPair>::sse_decode(deserializer);
        let mut var_preimage = <crate::api::types::PreImage>::sse_decode(deserializer);
        let mut var_redeemScript = <String>::sse_decode(deserializer);
        let mut var_invoice = <String>::sse_decode(deserializer);
        let mut var_outAmount = <u64>::sse_decode(deserializer);
        let mut var_scriptAddress = <String>::sse_decode(deserializer);
        let mut var_blindingKey = <String>::sse_decode(deserializer);
        let mut var_electrumUrl = <String>::sse_decode(deserializer);
        let mut var_boltzUrl = <String>::sse_decode(deserializer);
        return crate::api::lbtc_ln::LbtcLnV1Swap {
            id: var_id,
            kind: var_kind,
            network: var_network,
            keys: var_keys,
            preimage: var_preimage,
            redeem_script: var_redeemScript,
            invoice: var_invoice,
            out_amount: var_outAmount,
            script_address: var_scriptAddress,
            blinding_key: var_blindingKey,
            electrum_url: var_electrumUrl,
            boltz_url: var_boltzUrl,
        };
    }
}

impl SseDecode for crate::api::lbtc_ln::LbtcLnV2Swap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_kind = <crate::api::types::SwapType>::sse_decode(deserializer);
        let mut var_network = <crate::api::types::Chain>::sse_decode(deserializer);
        let mut var_keys = <crate::api::types::KeyPair>::sse_decode(deserializer);
        let mut var_preimage = <crate::api::types::PreImage>::sse_decode(deserializer);
        let mut var_swapScript = <crate::api::types::LBtcSwapScriptV2Str>::sse_decode(deserializer);
        let mut var_invoice = <String>::sse_decode(deserializer);
        let mut var_outAmount = <u64>::sse_decode(deserializer);
        let mut var_scriptAddress = <String>::sse_decode(deserializer);
        let mut var_blindingKey = <String>::sse_decode(deserializer);
        let mut var_electrumUrl = <String>::sse_decode(deserializer);
        let mut var_boltzUrl = <String>::sse_decode(deserializer);
        return crate::api::lbtc_ln::LbtcLnV2Swap {
            id: var_id,
            kind: var_kind,
            network: var_network,
            keys: var_keys,
            preimage: var_preimage,
            swap_script: var_swapScript,
            invoice: var_invoice,
            out_amount: var_outAmount,
            script_address: var_scriptAddress,
            blinding_key: var_blindingKey,
            electrum_url: var_electrumUrl,
            boltz_url: var_boltzUrl,
        };
    }
}

impl SseDecode for crate::api::types::Limits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_minimal = <u64>::sse_decode(deserializer);
        let mut var_maximal = <u64>::sse_decode(deserializer);
        return crate::api::types::Limits {
            minimal: var_minimal,
            maximal: var_maximal,
        };
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::types::PreImage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_value = <String>::sse_decode(deserializer);
        let mut var_sha256 = <String>::sse_decode(deserializer);
        let mut var_hash160 = <String>::sse_decode(deserializer);
        return crate::api::types::PreImage {
            value: var_value,
            sha256: var_sha256,
            hash160: var_hash160,
        };
    }
}

impl SseDecode for crate::api::types::ReverseSwapFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_boltzFeesRate = <f64>::sse_decode(deserializer);
        let mut var_lockupFees = <u64>::sse_decode(deserializer);
        let mut var_claimFeesEstimate = <u64>::sse_decode(deserializer);
        return crate::api::types::ReverseSwapFees {
            boltz_fees_rate: var_boltzFeesRate,
            lockup_fees: var_lockupFees,
            claim_fees_estimate: var_claimFeesEstimate,
        };
    }
}

impl SseDecode for crate::api::types::SubmarineSwapFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_boltzFeesRate = <f64>::sse_decode(deserializer);
        let mut var_claimFees = <u64>::sse_decode(deserializer);
        let mut var_lockupFeesEstimate = <u64>::sse_decode(deserializer);
        return crate::api::types::SubmarineSwapFees {
            boltz_fees_rate: var_boltzFeesRate,
            claim_fees: var_claimFees,
            lockup_fees_estimate: var_lockupFeesEstimate,
        };
    }
}

impl SseDecode for crate::api::types::SwapType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::SwapType::Submarine,
            1 => crate::api::types::SwapType::Reverse,
            _ => unreachable!("Invalid variant for SwapType: {}", inner),
        };
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::AllFees {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.btc_limits.into_into_dart().into_dart(),
            self.lbtc_limits.into_into_dart().into_dart(),
            self.btc_submarine.into_into_dart().into_dart(),
            self.btc_reverse.into_into_dart().into_dart(),
            self.lbtc_submarine.into_into_dart().into_dart(),
            self.lbtc_reverse.into_into_dart().into_dart(),
            self.btc_pair_hash.into_into_dart().into_dart(),
            self.lbtc_pair_hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::AllFees {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::AllFees> for crate::api::types::AllFees {
    fn into_into_dart(self) -> crate::api::types::AllFees {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::BoltzError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.kind.into_into_dart().into_dart(),
            self.message.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::error::BoltzError {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::BoltzError>
    for crate::api::error::BoltzError
{
    fn into_into_dart(self) -> crate::api::error::BoltzError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::btc_ln::BtcLnV1Swap {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.network.into_into_dart().into_dart(),
            self.keys.into_into_dart().into_dart(),
            self.preimage.into_into_dart().into_dart(),
            self.redeem_script.into_into_dart().into_dart(),
            self.invoice.into_into_dart().into_dart(),
            self.script_address.into_into_dart().into_dart(),
            self.out_amount.into_into_dart().into_dart(),
            self.electrum_url.into_into_dart().into_dart(),
            self.boltz_url.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::btc_ln::BtcLnV1Swap
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::btc_ln::BtcLnV1Swap>
    for crate::api::btc_ln::BtcLnV1Swap
{
    fn into_into_dart(self) -> crate::api::btc_ln::BtcLnV1Swap {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::btc_ln::BtcLnV2Swap {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.network.into_into_dart().into_dart(),
            self.keys.into_into_dart().into_dart(),
            self.preimage.into_into_dart().into_dart(),
            self.swap_script.into_into_dart().into_dart(),
            self.invoice.into_into_dart().into_dart(),
            self.script_address.into_into_dart().into_dart(),
            self.out_amount.into_into_dart().into_dart(),
            self.electrum_url.into_into_dart().into_dart(),
            self.boltz_url.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::btc_ln::BtcLnV2Swap
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::btc_ln::BtcLnV2Swap>
    for crate::api::btc_ln::BtcLnV2Swap
{
    fn into_into_dart(self) -> crate::api::btc_ln::BtcLnV2Swap {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::BtcSwapScriptV2Str {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.swap_type.into_into_dart().into_dart(),
            self.funding_addrs.into_into_dart().into_dart(),
            self.hashlock.into_into_dart().into_dart(),
            self.receiver_pubkey.into_into_dart().into_dart(),
            self.locktime.into_into_dart().into_dart(),
            self.sender_pubkey.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::BtcSwapScriptV2Str
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::BtcSwapScriptV2Str>
    for crate::api::types::BtcSwapScriptV2Str
{
    fn into_into_dart(self) -> crate::api::types::BtcSwapScriptV2Str {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Chain {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Bitcoin => 0.into_dart(),
            Self::BitcoinTestnet => 1.into_dart(),
            Self::Liquid => 2.into_dart(),
            Self::LiquidTestnet => 3.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Chain {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Chain> for crate::api::types::Chain {
    fn into_into_dart(self) -> crate::api::types::Chain {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::DecodedInvoice {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.msats.into_into_dart().into_dart(),
            self.expiry.into_into_dart().into_dart(),
            self.expires_in.into_into_dart().into_dart(),
            self.expires_at.into_into_dart().into_dart(),
            self.is_expired.into_into_dart().into_dart(),
            self.network.into_into_dart().into_dart(),
            self.cltv_exp_delta.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::DecodedInvoice
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::DecodedInvoice>
    for crate::api::types::DecodedInvoice
{
    fn into_into_dart(self) -> crate::api::types::DecodedInvoice {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::KeyPair {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.secret_key.into_into_dart().into_dart(),
            self.public_key.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::KeyPair {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::KeyPair> for crate::api::types::KeyPair {
    fn into_into_dart(self) -> crate::api::types::KeyPair {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LBtcSwapScriptV2Str {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.swap_type.into_into_dart().into_dart(),
            self.funding_addrs.into_into_dart().into_dart(),
            self.hashlock.into_into_dart().into_dart(),
            self.receiver_pubkey.into_into_dart().into_dart(),
            self.locktime.into_into_dart().into_dart(),
            self.sender_pubkey.into_into_dart().into_dart(),
            self.blinding_key.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::LBtcSwapScriptV2Str
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LBtcSwapScriptV2Str>
    for crate::api::types::LBtcSwapScriptV2Str
{
    fn into_into_dart(self) -> crate::api::types::LBtcSwapScriptV2Str {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::lbtc_ln::LbtcLnV1Swap {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.network.into_into_dart().into_dart(),
            self.keys.into_into_dart().into_dart(),
            self.preimage.into_into_dart().into_dart(),
            self.redeem_script.into_into_dart().into_dart(),
            self.invoice.into_into_dart().into_dart(),
            self.out_amount.into_into_dart().into_dart(),
            self.script_address.into_into_dart().into_dart(),
            self.blinding_key.into_into_dart().into_dart(),
            self.electrum_url.into_into_dart().into_dart(),
            self.boltz_url.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::lbtc_ln::LbtcLnV1Swap
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::lbtc_ln::LbtcLnV1Swap>
    for crate::api::lbtc_ln::LbtcLnV1Swap
{
    fn into_into_dart(self) -> crate::api::lbtc_ln::LbtcLnV1Swap {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::lbtc_ln::LbtcLnV2Swap {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.network.into_into_dart().into_dart(),
            self.keys.into_into_dart().into_dart(),
            self.preimage.into_into_dart().into_dart(),
            self.swap_script.into_into_dart().into_dart(),
            self.invoice.into_into_dart().into_dart(),
            self.out_amount.into_into_dart().into_dart(),
            self.script_address.into_into_dart().into_dart(),
            self.blinding_key.into_into_dart().into_dart(),
            self.electrum_url.into_into_dart().into_dart(),
            self.boltz_url.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::lbtc_ln::LbtcLnV2Swap
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::lbtc_ln::LbtcLnV2Swap>
    for crate::api::lbtc_ln::LbtcLnV2Swap
{
    fn into_into_dart(self) -> crate::api::lbtc_ln::LbtcLnV2Swap {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Limits {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.minimal.into_into_dart().into_dart(),
            self.maximal.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Limits {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Limits> for crate::api::types::Limits {
    fn into_into_dart(self) -> crate::api::types::Limits {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PreImage {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.value.into_into_dart().into_dart(),
            self.sha256.into_into_dart().into_dart(),
            self.hash160.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::PreImage {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PreImage>
    for crate::api::types::PreImage
{
    fn into_into_dart(self) -> crate::api::types::PreImage {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ReverseSwapFees {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.boltz_fees_rate.into_into_dart().into_dart(),
            self.lockup_fees.into_into_dart().into_dart(),
            self.claim_fees_estimate.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ReverseSwapFees
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ReverseSwapFees>
    for crate::api::types::ReverseSwapFees
{
    fn into_into_dart(self) -> crate::api::types::ReverseSwapFees {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::SubmarineSwapFees {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.boltz_fees_rate.into_into_dart().into_dart(),
            self.claim_fees.into_into_dart().into_dart(),
            self.lockup_fees_estimate.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::SubmarineSwapFees
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::SubmarineSwapFees>
    for crate::api::types::SubmarineSwapFees
{
    fn into_into_dart(self) -> crate::api::types::SubmarineSwapFees {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::SwapType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Submarine => 0.into_dart(),
            Self::Reverse => 1.into_dart(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::SwapType {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::SwapType>
    for crate::api::types::SwapType
{
    fn into_into_dart(self) -> crate::api::types::SwapType {
        self
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::types::AllFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::Limits>::sse_encode(self.btc_limits, serializer);
        <crate::api::types::Limits>::sse_encode(self.lbtc_limits, serializer);
        <crate::api::types::SubmarineSwapFees>::sse_encode(self.btc_submarine, serializer);
        <crate::api::types::ReverseSwapFees>::sse_encode(self.btc_reverse, serializer);
        <crate::api::types::SubmarineSwapFees>::sse_encode(self.lbtc_submarine, serializer);
        <crate::api::types::ReverseSwapFees>::sse_encode(self.lbtc_reverse, serializer);
        <String>::sse_encode(self.btc_pair_hash, serializer);
        <String>::sse_encode(self.lbtc_pair_hash, serializer);
    }
}

impl SseEncode for crate::api::error::BoltzError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.kind, serializer);
        <String>::sse_encode(self.message, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::btc_ln::BtcLnV1Swap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <crate::api::types::SwapType>::sse_encode(self.kind, serializer);
        <crate::api::types::Chain>::sse_encode(self.network, serializer);
        <crate::api::types::KeyPair>::sse_encode(self.keys, serializer);
        <crate::api::types::PreImage>::sse_encode(self.preimage, serializer);
        <String>::sse_encode(self.redeem_script, serializer);
        <String>::sse_encode(self.invoice, serializer);
        <String>::sse_encode(self.script_address, serializer);
        <u64>::sse_encode(self.out_amount, serializer);
        <String>::sse_encode(self.electrum_url, serializer);
        <String>::sse_encode(self.boltz_url, serializer);
    }
}

impl SseEncode for crate::api::btc_ln::BtcLnV2Swap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <crate::api::types::SwapType>::sse_encode(self.kind, serializer);
        <crate::api::types::Chain>::sse_encode(self.network, serializer);
        <crate::api::types::KeyPair>::sse_encode(self.keys, serializer);
        <crate::api::types::PreImage>::sse_encode(self.preimage, serializer);
        <crate::api::types::BtcSwapScriptV2Str>::sse_encode(self.swap_script, serializer);
        <String>::sse_encode(self.invoice, serializer);
        <String>::sse_encode(self.script_address, serializer);
        <u64>::sse_encode(self.out_amount, serializer);
        <String>::sse_encode(self.electrum_url, serializer);
        <String>::sse_encode(self.boltz_url, serializer);
    }
}

impl SseEncode for crate::api::types::BtcSwapScriptV2Str {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::SwapType>::sse_encode(self.swap_type, serializer);
        <Option<String>>::sse_encode(self.funding_addrs, serializer);
        <String>::sse_encode(self.hashlock, serializer);
        <String>::sse_encode(self.receiver_pubkey, serializer);
        <u32>::sse_encode(self.locktime, serializer);
        <String>::sse_encode(self.sender_pubkey, serializer);
    }
}

impl SseEncode for crate::api::types::Chain {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::Chain::Bitcoin => 0,
                crate::api::types::Chain::BitcoinTestnet => 1,
                crate::api::types::Chain::Liquid => 2,
                crate::api::types::Chain::LiquidTestnet => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::DecodedInvoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.msats, serializer);
        <u64>::sse_encode(self.expiry, serializer);
        <u64>::sse_encode(self.expires_in, serializer);
        <u64>::sse_encode(self.expires_at, serializer);
        <bool>::sse_encode(self.is_expired, serializer);
        <String>::sse_encode(self.network, serializer);
        <u64>::sse_encode(self.cltv_exp_delta, serializer);
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::types::KeyPair {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.secret_key, serializer);
        <String>::sse_encode(self.public_key, serializer);
    }
}

impl SseEncode for crate::api::types::LBtcSwapScriptV2Str {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::SwapType>::sse_encode(self.swap_type, serializer);
        <Option<String>>::sse_encode(self.funding_addrs, serializer);
        <String>::sse_encode(self.hashlock, serializer);
        <String>::sse_encode(self.receiver_pubkey, serializer);
        <u32>::sse_encode(self.locktime, serializer);
        <String>::sse_encode(self.sender_pubkey, serializer);
        <String>::sse_encode(self.blinding_key, serializer);
    }
}

impl SseEncode for crate::api::lbtc_ln::LbtcLnV1Swap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <crate::api::types::SwapType>::sse_encode(self.kind, serializer);
        <crate::api::types::Chain>::sse_encode(self.network, serializer);
        <crate::api::types::KeyPair>::sse_encode(self.keys, serializer);
        <crate::api::types::PreImage>::sse_encode(self.preimage, serializer);
        <String>::sse_encode(self.redeem_script, serializer);
        <String>::sse_encode(self.invoice, serializer);
        <u64>::sse_encode(self.out_amount, serializer);
        <String>::sse_encode(self.script_address, serializer);
        <String>::sse_encode(self.blinding_key, serializer);
        <String>::sse_encode(self.electrum_url, serializer);
        <String>::sse_encode(self.boltz_url, serializer);
    }
}

impl SseEncode for crate::api::lbtc_ln::LbtcLnV2Swap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <crate::api::types::SwapType>::sse_encode(self.kind, serializer);
        <crate::api::types::Chain>::sse_encode(self.network, serializer);
        <crate::api::types::KeyPair>::sse_encode(self.keys, serializer);
        <crate::api::types::PreImage>::sse_encode(self.preimage, serializer);
        <crate::api::types::LBtcSwapScriptV2Str>::sse_encode(self.swap_script, serializer);
        <String>::sse_encode(self.invoice, serializer);
        <u64>::sse_encode(self.out_amount, serializer);
        <String>::sse_encode(self.script_address, serializer);
        <String>::sse_encode(self.blinding_key, serializer);
        <String>::sse_encode(self.electrum_url, serializer);
        <String>::sse_encode(self.boltz_url, serializer);
    }
}

impl SseEncode for crate::api::types::Limits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.minimal, serializer);
        <u64>::sse_encode(self.maximal, serializer);
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::types::PreImage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.value, serializer);
        <String>::sse_encode(self.sha256, serializer);
        <String>::sse_encode(self.hash160, serializer);
    }
}

impl SseEncode for crate::api::types::ReverseSwapFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.boltz_fees_rate, serializer);
        <u64>::sse_encode(self.lockup_fees, serializer);
        <u64>::sse_encode(self.claim_fees_estimate, serializer);
    }
}

impl SseEncode for crate::api::types::SubmarineSwapFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.boltz_fees_rate, serializer);
        <u64>::sse_encode(self.claim_fees, serializer);
        <u64>::sse_encode(self.lockup_fees_estimate, serializer);
    }
}

impl SseEncode for crate::api::types::SwapType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::SwapType::Submarine => 0,
                crate::api::types::SwapType::Reverse => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

#[cfg(not(target_family = "wasm"))]
#[path = "frb_generated.io.rs"]
mod io;
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
#[path = "frb_generated.web.rs"]
mod web;
#[cfg(target_family = "wasm")]
pub use web::*;
