// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.0.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 342652895;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__btc_ln__btc_ln_swap_broadcast_boltz_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnSwap>,
    signed_hex: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_broadcast_boltz",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_signed_hex = signed_hex.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok =
                        crate::api::btc_ln::BtcLnSwap::broadcast_boltz(&api_that, api_signed_hex)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_broadcast_local_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnSwap>,
    signed_hex: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_broadcast_local",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_signed_hex = signed_hex.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok =
                        crate::api::btc_ln::BtcLnSwap::broadcast_local(&api_that, api_signed_hex)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_claim_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnSwap>,
    out_address: impl CstDecode<String>,
    miner_fee: impl CstDecode<crate::api::types::TxFee>,
    try_cooperate: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_claim",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_miner_fee = miner_fee.cst_decode();
            let api_try_cooperate = try_cooperate.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::btc_ln::BtcLnSwap::claim(
                        &api_that,
                        api_out_address,
                        api_miner_fee,
                        api_try_cooperate,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_coop_close_submarine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnSwap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_coop_close_submarine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::btc_ln::BtcLnSwap::coop_close_submarine(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_from_json_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    json_str: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_from_json",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_json_str = json_str.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::btc_ln::BtcLnSwap::from_json(&api_json_str)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_get_completed_submarine_preimage_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnSwap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_get_completed_submarine_preimage",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok =
                        crate::api::btc_ln::BtcLnSwap::get_completed_submarine_preimage(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<String>,
    kind: impl CstDecode<crate::api::types::SwapType>,
    network: impl CstDecode<crate::api::types::Chain>,
    keys: impl CstDecode<crate::api::types::KeyPair>,
    key_index: impl CstDecode<u64>,
    preimage: impl CstDecode<crate::api::types::PreImage>,
    swap_script: impl CstDecode<crate::api::types::BtcSwapScriptStr>,
    invoice: impl CstDecode<String>,
    script_address: impl CstDecode<String>,
    out_amount: impl CstDecode<u64>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    referral_id: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_kind = kind.cst_decode();
            let api_network = network.cst_decode();
            let api_keys = keys.cst_decode();
            let api_key_index = key_index.cst_decode();
            let api_preimage = preimage.cst_decode();
            let api_swap_script = swap_script.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_script_address = script_address.cst_decode();
            let api_out_amount = out_amount.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_referral_id = referral_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::btc_ln::BtcLnSwap::new(
                        api_id,
                        api_kind,
                        api_network,
                        api_keys,
                        api_key_index,
                        api_preimage,
                        api_swap_script,
                        api_invoice,
                        api_script_address,
                        api_out_amount,
                        api_electrum_url,
                        api_boltz_url,
                        api_referral_id,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_new_reverse_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
    passphrase: impl CstDecode<String>,
    index: impl CstDecode<u64>,
    out_amount: impl CstDecode<u64>,
    out_address: impl CstDecode<Option<String>>,
    network: impl CstDecode<crate::api::types::Chain>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    description: impl CstDecode<Option<String>>,
    referral_id: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_new_reverse",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            let api_passphrase = passphrase.cst_decode();
            let api_index = index.cst_decode();
            let api_out_amount = out_amount.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_network = network.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_description = description.cst_decode();
            let api_referral_id = referral_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::btc_ln::BtcLnSwap::new_reverse(
                        api_mnemonic,
                        api_passphrase,
                        api_index,
                        api_out_amount,
                        api_out_address,
                        api_network,
                        api_electrum_url,
                        api_boltz_url,
                        api_description,
                        api_referral_id,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_new_submarine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
    passphrase: impl CstDecode<String>,
    index: impl CstDecode<u64>,
    invoice: impl CstDecode<String>,
    network: impl CstDecode<crate::api::types::Chain>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    referral_id: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_new_submarine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            let api_passphrase = passphrase.cst_decode();
            let api_index = index.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_network = network.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_referral_id = referral_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::btc_ln::BtcLnSwap::new_submarine(
                        api_mnemonic,
                        api_passphrase,
                        api_index,
                        api_invoice,
                        api_network,
                        api_electrum_url,
                        api_boltz_url,
                        api_referral_id,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_refund_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnSwap>,
    out_address: impl CstDecode<String>,
    miner_fee: impl CstDecode<crate::api::types::TxFee>,
    try_cooperate: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_refund",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_miner_fee = miner_fee.cst_decode();
            let api_try_cooperate = try_cooperate.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::btc_ln::BtcLnSwap::refund(
                        &api_that,
                        api_out_address,
                        api_miner_fee,
                        api_try_cooperate,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_to_json_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnSwap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_to_json",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::btc_ln::BtcLnSwap::to_json(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_tx_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnSwap>,
    is_cooperative: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_tx_size",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_is_cooperative = is_cooperative.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok =
                        crate::api::btc_ln::BtcLnSwap::tx_size(&api_that, api_is_cooperative)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_broadcast_boltz_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::chain_swap::ChainSwap>,
    signed_hex: impl CstDecode<String>,
    kind: impl CstDecode<crate::api::types::SwapTxKind>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_broadcast_boltz",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_signed_hex = signed_hex.cst_decode();
            let api_kind = kind.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::chain_swap::ChainSwap::broadcast_boltz(
                        &api_that,
                        api_signed_hex,
                        api_kind,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_broadcast_local_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::chain_swap::ChainSwap>,
    signed_hex: impl CstDecode<String>,
    kind: impl CstDecode<crate::api::types::SwapTxKind>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_broadcast_local",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_signed_hex = signed_hex.cst_decode();
            let api_kind = kind.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::chain_swap::ChainSwap::broadcast_local(
                        &api_that,
                        api_signed_hex,
                        api_kind,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_claim_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::chain_swap::ChainSwap>,
    out_address: impl CstDecode<String>,
    refund_address: impl CstDecode<String>,
    miner_fee: impl CstDecode<crate::api::types::TxFee>,
    try_cooperate: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_claim",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_refund_address = refund_address.cst_decode();
            let api_miner_fee = miner_fee.cst_decode();
            let api_try_cooperate = try_cooperate.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::chain_swap::ChainSwap::claim(
                        &api_that,
                        api_out_address,
                        api_refund_address,
                        api_miner_fee,
                        api_try_cooperate,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_from_json_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    json_str: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_from_json",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_json_str = json_str.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::chain_swap::ChainSwap::from_json(&api_json_str)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_get_server_lockup_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::chain_swap::ChainSwap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_get_server_lockup",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok =
                        crate::api::chain_swap::ChainSwap::get_server_lockup(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_get_user_lockup_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::chain_swap::ChainSwap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_get_user_lockup",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::chain_swap::ChainSwap::get_user_lockup(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<String>,
    is_testnet: impl CstDecode<bool>,
    direction: impl CstDecode<crate::api::types::ChainSwapDirection>,
    refund_keys: impl CstDecode<crate::api::types::KeyPair>,
    refund_index: impl CstDecode<u64>,
    claim_keys: impl CstDecode<crate::api::types::KeyPair>,
    claim_index: impl CstDecode<u64>,
    preimage: impl CstDecode<crate::api::types::PreImage>,
    btc_script_str: impl CstDecode<crate::api::types::BtcSwapScriptStr>,
    lbtc_script_str: impl CstDecode<crate::api::types::LBtcSwapScriptStr>,
    script_address: impl CstDecode<String>,
    out_amount: impl CstDecode<u64>,
    btc_electrum_url: impl CstDecode<String>,
    lbtc_electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    referral_id: impl CstDecode<Option<String>>,
    blinding_key: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_is_testnet = is_testnet.cst_decode();
            let api_direction = direction.cst_decode();
            let api_refund_keys = refund_keys.cst_decode();
            let api_refund_index = refund_index.cst_decode();
            let api_claim_keys = claim_keys.cst_decode();
            let api_claim_index = claim_index.cst_decode();
            let api_preimage = preimage.cst_decode();
            let api_btc_script_str = btc_script_str.cst_decode();
            let api_lbtc_script_str = lbtc_script_str.cst_decode();
            let api_script_address = script_address.cst_decode();
            let api_out_amount = out_amount.cst_decode();
            let api_btc_electrum_url = btc_electrum_url.cst_decode();
            let api_lbtc_electrum_url = lbtc_electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_referral_id = referral_id.cst_decode();
            let api_blinding_key = blinding_key.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::chain_swap::ChainSwap::new(
                        api_id,
                        api_is_testnet,
                        api_direction,
                        api_refund_keys,
                        api_refund_index,
                        api_claim_keys,
                        api_claim_index,
                        api_preimage,
                        api_btc_script_str,
                        api_lbtc_script_str,
                        api_script_address,
                        api_out_amount,
                        api_btc_electrum_url,
                        api_lbtc_electrum_url,
                        api_boltz_url,
                        api_referral_id,
                        api_blinding_key,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_new_swap_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    direction: impl CstDecode<crate::api::types::ChainSwapDirection>,
    mnemonic: impl CstDecode<String>,
    passphrase: impl CstDecode<String>,
    index: impl CstDecode<u64>,
    amount: impl CstDecode<u64>,
    is_testnet: impl CstDecode<bool>,
    btc_electrum_url: impl CstDecode<String>,
    lbtc_electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    referral_id: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_new_swap",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_direction = direction.cst_decode();
            let api_mnemonic = mnemonic.cst_decode();
            let api_passphrase = passphrase.cst_decode();
            let api_index = index.cst_decode();
            let api_amount = amount.cst_decode();
            let api_is_testnet = is_testnet.cst_decode();
            let api_btc_electrum_url = btc_electrum_url.cst_decode();
            let api_lbtc_electrum_url = lbtc_electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_referral_id = referral_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::chain_swap::ChainSwap::new_swap(
                        api_direction,
                        api_mnemonic,
                        api_passphrase,
                        api_index,
                        api_amount,
                        api_is_testnet,
                        api_btc_electrum_url,
                        api_lbtc_electrum_url,
                        api_boltz_url,
                        api_referral_id,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_refund_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::chain_swap::ChainSwap>,
    refund_address: impl CstDecode<String>,
    miner_fee: impl CstDecode<crate::api::types::TxFee>,
    try_cooperate: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_refund",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_refund_address = refund_address.cst_decode();
            let api_miner_fee = miner_fee.cst_decode();
            let api_try_cooperate = try_cooperate.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::chain_swap::ChainSwap::refund(
                        &api_that,
                        api_refund_address,
                        api_miner_fee,
                        api_try_cooperate,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_to_json_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::chain_swap::ChainSwap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_to_json",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::chain_swap::ChainSwap::to_json(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__error__boltz_error_message_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::error::BoltzError>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "boltz_error_message",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::error::BoltzError::message(&api_that);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__error__boltz_error_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    kind: impl CstDecode<String>,
    message: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "boltz_error_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_kind = kind.cst_decode();
            let api_message = message.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::error::BoltzError::new(
                        api_kind,
                        api_message,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__fees__fees_chain_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::fees::Fees>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fees_chain",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::fees::Fees::chain(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__fees__fees_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    boltz_url: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fees_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_boltz_url = boltz_url.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::fees::Fees::new(api_boltz_url))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__fees__fees_reverse_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::fees::Fees>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fees_reverse",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::fees::Fees::reverse(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__fees__fees_submarine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::fees::Fees>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fees_submarine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::fees::Fees::submarine(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_broadcast_boltz_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnSwap>,
    signed_hex: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_broadcast_boltz",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_signed_hex = signed_hex.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::lbtc_ln::LbtcLnSwap::broadcast_boltz(
                        &api_that,
                        api_signed_hex,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_broadcast_local_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnSwap>,
    signed_hex: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_broadcast_local",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_signed_hex = signed_hex.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::lbtc_ln::LbtcLnSwap::broadcast_local(
                        &api_that,
                        api_signed_hex,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_claim_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnSwap>,
    out_address: impl CstDecode<String>,
    miner_fee: impl CstDecode<crate::api::types::TxFee>,
    try_cooperate: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_claim",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_miner_fee = miner_fee.cst_decode();
            let api_try_cooperate = try_cooperate.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::lbtc_ln::LbtcLnSwap::claim(
                        &api_that,
                        api_out_address,
                        api_miner_fee,
                        api_try_cooperate,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_coop_close_submarine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnSwap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_coop_close_submarine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok =
                        crate::api::lbtc_ln::LbtcLnSwap::coop_close_submarine(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_from_json_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    json_str: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_from_json",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_json_str = json_str.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::lbtc_ln::LbtcLnSwap::from_json(&api_json_str)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_get_completed_submarine_preimage_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnSwap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_get_completed_submarine_preimage",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok =
                        crate::api::lbtc_ln::LbtcLnSwap::get_completed_submarine_preimage(
                            &api_that,
                        )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<String>,
    kind: impl CstDecode<crate::api::types::SwapType>,
    network: impl CstDecode<crate::api::types::Chain>,
    keys: impl CstDecode<crate::api::types::KeyPair>,
    key_index: impl CstDecode<u64>,
    preimage: impl CstDecode<crate::api::types::PreImage>,
    swap_script: impl CstDecode<crate::api::types::LBtcSwapScriptStr>,
    invoice: impl CstDecode<String>,
    out_amount: impl CstDecode<u64>,
    out_address: impl CstDecode<String>,
    blinding_key: impl CstDecode<String>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    referral_id: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_kind = kind.cst_decode();
            let api_network = network.cst_decode();
            let api_keys = keys.cst_decode();
            let api_key_index = key_index.cst_decode();
            let api_preimage = preimage.cst_decode();
            let api_swap_script = swap_script.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_out_amount = out_amount.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_blinding_key = blinding_key.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_referral_id = referral_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::lbtc_ln::LbtcLnSwap::new(
                        api_id,
                        api_kind,
                        api_network,
                        api_keys,
                        api_key_index,
                        api_preimage,
                        api_swap_script,
                        api_invoice,
                        api_out_amount,
                        api_out_address,
                        api_blinding_key,
                        api_electrum_url,
                        api_boltz_url,
                        api_referral_id,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_new_reverse_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
    passphrase: impl CstDecode<String>,
    index: impl CstDecode<u64>,
    out_amount: impl CstDecode<u64>,
    out_address: impl CstDecode<Option<String>>,
    network: impl CstDecode<crate::api::types::Chain>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    description: impl CstDecode<Option<String>>,
    referral_id: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_new_reverse",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            let api_passphrase = passphrase.cst_decode();
            let api_index = index.cst_decode();
            let api_out_amount = out_amount.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_network = network.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_description = description.cst_decode();
            let api_referral_id = referral_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::lbtc_ln::LbtcLnSwap::new_reverse(
                        api_mnemonic,
                        api_passphrase,
                        api_index,
                        api_out_amount,
                        api_out_address,
                        api_network,
                        api_electrum_url,
                        api_boltz_url,
                        api_description,
                        api_referral_id,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_new_submarine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
    passphrase: impl CstDecode<String>,
    index: impl CstDecode<u64>,
    invoice: impl CstDecode<String>,
    network: impl CstDecode<crate::api::types::Chain>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    referral_id: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_new_submarine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            let api_passphrase = passphrase.cst_decode();
            let api_index = index.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_network = network.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_referral_id = referral_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::lbtc_ln::LbtcLnSwap::new_submarine(
                        api_mnemonic,
                        api_passphrase,
                        api_index,
                        api_invoice,
                        api_network,
                        api_electrum_url,
                        api_boltz_url,
                        api_referral_id,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_refund_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnSwap>,
    out_address: impl CstDecode<String>,
    miner_fee: impl CstDecode<crate::api::types::TxFee>,
    try_cooperate: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_refund",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_miner_fee = miner_fee.cst_decode();
            let api_try_cooperate = try_cooperate.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::lbtc_ln::LbtcLnSwap::refund(
                        &api_that,
                        api_out_address,
                        api_miner_fee,
                        api_try_cooperate,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_to_json_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnSwap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_to_json",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::lbtc_ln::LbtcLnSwap::to_json(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_tx_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnSwap>,
    is_cooperative: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_tx_size",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_is_cooperative = is_cooperative.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok =
                        crate::api::lbtc_ln::LbtcLnSwap::tx_size(&api_that, api_is_cooperative)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__btc_swap_script_str_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    swap_type: impl CstDecode<crate::api::types::SwapType>,
    funding_addrs: impl CstDecode<Option<String>>,
    hashlock: impl CstDecode<String>,
    receiver_pubkey: impl CstDecode<String>,
    locktime: impl CstDecode<u32>,
    sender_pubkey: impl CstDecode<String>,
    side: impl CstDecode<Option<crate::api::types::Side>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_swap_script_str_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_swap_type = swap_type.cst_decode();
            let api_funding_addrs = funding_addrs.cst_decode();
            let api_hashlock = hashlock.cst_decode();
            let api_receiver_pubkey = receiver_pubkey.cst_decode();
            let api_locktime = locktime.cst_decode();
            let api_sender_pubkey = sender_pubkey.cst_decode();
            let api_side = side.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::types::BtcSwapScriptStr::new(
                        api_swap_type,
                        api_funding_addrs,
                        api_hashlock,
                        api_receiver_pubkey,
                        api_locktime,
                        api_sender_pubkey,
                        api_side,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__decoded_invoice_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    s: impl CstDecode<String>,
    boltz_url: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decoded_invoice_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_s = s.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok =
                        crate::api::types::DecodedInvoice::from_string(api_s, api_boltz_url)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__get_voucher_max_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    lnurl: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_voucher_max_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_lnurl = lnurl.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::types::get_voucher_max_amount(api_lnurl)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__invoice_from_lnurl_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    lnurl: impl CstDecode<String>,
    msats: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "invoice_from_lnurl",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_lnurl = lnurl.cst_decode();
            let api_msats = msats.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::types::invoice_from_lnurl(api_lnurl, api_msats)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__key_pair_generate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
    passphrase: impl CstDecode<String>,
    network: impl CstDecode<crate::api::types::Chain>,
    index: impl CstDecode<u64>,
    swap_type: impl CstDecode<crate::api::types::SwapType>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "key_pair_generate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            let api_passphrase = passphrase.cst_decode();
            let api_network = network.cst_decode();
            let api_index = index.cst_decode();
            let api_swap_type = swap_type.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::types::KeyPair::generate(
                        api_mnemonic,
                        api_passphrase,
                        api_network,
                        api_index,
                        api_swap_type,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__key_pair_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    secret_key: impl CstDecode<String>,
    public_key: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "key_pair_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_secret_key = secret_key.cst_decode();
            let api_public_key = public_key.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::types::KeyPair::new(
                        api_secret_key,
                        api_public_key,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__l_btc_swap_script_str_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    swap_type: impl CstDecode<crate::api::types::SwapType>,
    funding_addrs: impl CstDecode<Option<String>>,
    hashlock: impl CstDecode<String>,
    receiver_pubkey: impl CstDecode<String>,
    locktime: impl CstDecode<u32>,
    sender_pubkey: impl CstDecode<String>,
    blinding_key: impl CstDecode<String>,
    side: impl CstDecode<Option<crate::api::types::Side>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "l_btc_swap_script_str_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_swap_type = swap_type.cst_decode();
            let api_funding_addrs = funding_addrs.cst_decode();
            let api_hashlock = hashlock.cst_decode();
            let api_receiver_pubkey = receiver_pubkey.cst_decode();
            let api_locktime = locktime.cst_decode();
            let api_sender_pubkey = sender_pubkey.cst_decode();
            let api_blinding_key = blinding_key.cst_decode();
            let api_side = side.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::types::LBtcSwapScriptStr::new(
                            api_swap_type,
                            api_funding_addrs,
                            api_hashlock,
                            api_receiver_pubkey,
                            api_locktime,
                            api_sender_pubkey,
                            api_blinding_key,
                            api_side,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__pre_image_generate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "pre_image_generate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::types::PreImage::generate())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__pre_image_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    value: impl CstDecode<String>,
    sha256: impl CstDecode<String>,
    hash160: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "pre_image_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_value = value.cst_decode();
            let api_sha256 = sha256.cst_decode();
            let api_hash160 = hash160.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::types::PreImage::new(
                        api_value,
                        api_sha256,
                        api_hash160,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__validate_lnurl_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    lnurl: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "validate_lnurl",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_lnurl = lnurl.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::types::validate_lnurl(api_lnurl))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__withdraw_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    lnurl: impl CstDecode<String>,
    invoice: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "withdraw",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_lnurl = lnurl.cst_decode();
            let api_invoice = invoice.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::types::withdraw(api_lnurl, api_invoice)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}

// Section: dart2rust

impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<crate::api::types::Chain> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Chain {
        match self {
            0 => crate::api::types::Chain::Bitcoin,
            1 => crate::api::types::Chain::BitcoinTestnet,
            2 => crate::api::types::Chain::Liquid,
            3 => crate::api::types::Chain::LiquidTestnet,
            _ => unreachable!("Invalid variant for Chain: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::ChainSwapDirection> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::ChainSwapDirection {
        match self {
            0 => crate::api::types::ChainSwapDirection::BtcToLbtc,
            1 => crate::api::types::ChainSwapDirection::LbtcToBtc,
            _ => unreachable!("Invalid variant for ChainSwapDirection: {}", self),
        }
    }
}
impl CstDecode<f64> for f64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> f64 {
        self
    }
}
impl CstDecode<i32> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<crate::api::types::Side> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Side {
        match self {
            0 => crate::api::types::Side::Lockup,
            1 => crate::api::types::Side::Claim,
            _ => unreachable!("Invalid variant for Side: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::SwapTxKind> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::SwapTxKind {
        match self {
            0 => crate::api::types::SwapTxKind::Claim,
            1 => crate::api::types::SwapTxKind::Refund,
            _ => unreachable!("Invalid variant for SwapTxKind: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::SwapType> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::SwapType {
        match self {
            0 => crate::api::types::SwapType::Submarine,
            1 => crate::api::types::SwapType::Reverse,
            2 => crate::api::types::SwapType::Chain,
            _ => unreachable!("Invalid variant for SwapType: {}", self),
        }
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u64> for u64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<usize> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self
    }
}
impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::error::BoltzError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_kind = <String>::sse_decode(deserializer);
        let mut var_message = <String>::sse_decode(deserializer);
        return crate::api::error::BoltzError {
            kind: var_kind,
            message: var_message,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::btc_ln::BtcLnSwap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_kind = <crate::api::types::SwapType>::sse_decode(deserializer);
        let mut var_network = <crate::api::types::Chain>::sse_decode(deserializer);
        let mut var_keys = <crate::api::types::KeyPair>::sse_decode(deserializer);
        let mut var_keyIndex = <u64>::sse_decode(deserializer);
        let mut var_preimage = <crate::api::types::PreImage>::sse_decode(deserializer);
        let mut var_swapScript = <crate::api::types::BtcSwapScriptStr>::sse_decode(deserializer);
        let mut var_invoice = <String>::sse_decode(deserializer);
        let mut var_scriptAddress = <String>::sse_decode(deserializer);
        let mut var_outAmount = <u64>::sse_decode(deserializer);
        let mut var_electrumUrl = <String>::sse_decode(deserializer);
        let mut var_boltzUrl = <String>::sse_decode(deserializer);
        let mut var_referralId = <Option<String>>::sse_decode(deserializer);
        return crate::api::btc_ln::BtcLnSwap {
            id: var_id,
            kind: var_kind,
            network: var_network,
            keys: var_keys,
            key_index: var_keyIndex,
            preimage: var_preimage,
            swap_script: var_swapScript,
            invoice: var_invoice,
            script_address: var_scriptAddress,
            out_amount: var_outAmount,
            electrum_url: var_electrumUrl,
            boltz_url: var_boltzUrl,
            referral_id: var_referralId,
        };
    }
}

impl SseDecode for crate::api::types::BtcSwapScriptStr {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_swapType = <crate::api::types::SwapType>::sse_decode(deserializer);
        let mut var_fundingAddrs = <Option<String>>::sse_decode(deserializer);
        let mut var_hashlock = <String>::sse_decode(deserializer);
        let mut var_receiverPubkey = <String>::sse_decode(deserializer);
        let mut var_locktime = <u32>::sse_decode(deserializer);
        let mut var_senderPubkey = <String>::sse_decode(deserializer);
        let mut var_side = <Option<crate::api::types::Side>>::sse_decode(deserializer);
        return crate::api::types::BtcSwapScriptStr {
            swap_type: var_swapType,
            funding_addrs: var_fundingAddrs,
            hashlock: var_hashlock,
            receiver_pubkey: var_receiverPubkey,
            locktime: var_locktime,
            sender_pubkey: var_senderPubkey,
            side: var_side,
        };
    }
}

impl SseDecode for crate::api::types::Chain {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::Chain::Bitcoin,
            1 => crate::api::types::Chain::BitcoinTestnet,
            2 => crate::api::types::Chain::Liquid,
            3 => crate::api::types::Chain::LiquidTestnet,
            _ => unreachable!("Invalid variant for Chain: {}", inner),
        };
    }
}

impl SseDecode for crate::api::fees::ChainFeesAndLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_btcLimits = <crate::api::fees::SwapLimits>::sse_decode(deserializer);
        let mut var_lbtcLimits = <crate::api::fees::SwapLimits>::sse_decode(deserializer);
        let mut var_btcFees = <crate::api::fees::ChainSwapFees>::sse_decode(deserializer);
        let mut var_lbtcFees = <crate::api::fees::ChainSwapFees>::sse_decode(deserializer);
        return crate::api::fees::ChainFeesAndLimits {
            btc_limits: var_btcLimits,
            lbtc_limits: var_lbtcLimits,
            btc_fees: var_btcFees,
            lbtc_fees: var_lbtcFees,
        };
    }
}

impl SseDecode for crate::api::chain_swap::ChainSwap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_isTestnet = <bool>::sse_decode(deserializer);
        let mut var_direction = <crate::api::types::ChainSwapDirection>::sse_decode(deserializer);
        let mut var_refundKeys = <crate::api::types::KeyPair>::sse_decode(deserializer);
        let mut var_refundIndex = <u64>::sse_decode(deserializer);
        let mut var_claimKeys = <crate::api::types::KeyPair>::sse_decode(deserializer);
        let mut var_claimIndex = <u64>::sse_decode(deserializer);
        let mut var_preimage = <crate::api::types::PreImage>::sse_decode(deserializer);
        let mut var_btcScriptStr = <crate::api::types::BtcSwapScriptStr>::sse_decode(deserializer);
        let mut var_lbtcScriptStr =
            <crate::api::types::LBtcSwapScriptStr>::sse_decode(deserializer);
        let mut var_scriptAddress = <String>::sse_decode(deserializer);
        let mut var_outAmount = <u64>::sse_decode(deserializer);
        let mut var_btcElectrumUrl = <String>::sse_decode(deserializer);
        let mut var_lbtcElectrumUrl = <String>::sse_decode(deserializer);
        let mut var_boltzUrl = <String>::sse_decode(deserializer);
        let mut var_referralId = <Option<String>>::sse_decode(deserializer);
        let mut var_blindingKey = <String>::sse_decode(deserializer);
        return crate::api::chain_swap::ChainSwap {
            id: var_id,
            is_testnet: var_isTestnet,
            direction: var_direction,
            refund_keys: var_refundKeys,
            refund_index: var_refundIndex,
            claim_keys: var_claimKeys,
            claim_index: var_claimIndex,
            preimage: var_preimage,
            btc_script_str: var_btcScriptStr,
            lbtc_script_str: var_lbtcScriptStr,
            script_address: var_scriptAddress,
            out_amount: var_outAmount,
            btc_electrum_url: var_btcElectrumUrl,
            lbtc_electrum_url: var_lbtcElectrumUrl,
            boltz_url: var_boltzUrl,
            referral_id: var_referralId,
            blinding_key: var_blindingKey,
        };
    }
}

impl SseDecode for crate::api::types::ChainSwapDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::ChainSwapDirection::BtcToLbtc,
            1 => crate::api::types::ChainSwapDirection::LbtcToBtc,
            _ => unreachable!("Invalid variant for ChainSwapDirection: {}", inner),
        };
    }
}

impl SseDecode for crate::api::fees::ChainSwapFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_percentage = <f64>::sse_decode(deserializer);
        let mut var_userLockup = <u64>::sse_decode(deserializer);
        let mut var_userClaim = <u64>::sse_decode(deserializer);
        let mut var_server = <u64>::sse_decode(deserializer);
        return crate::api::fees::ChainSwapFees {
            percentage: var_percentage,
            user_lockup: var_userLockup,
            user_claim: var_userClaim,
            server: var_server,
        };
    }
}

impl SseDecode for crate::api::types::DecodedInvoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_msats = <u64>::sse_decode(deserializer);
        let mut var_expiry = <u64>::sse_decode(deserializer);
        let mut var_expiresIn = <u64>::sse_decode(deserializer);
        let mut var_expiresAt = <u64>::sse_decode(deserializer);
        let mut var_isExpired = <bool>::sse_decode(deserializer);
        let mut var_network = <String>::sse_decode(deserializer);
        let mut var_cltvExpDelta = <u64>::sse_decode(deserializer);
        let mut var_bip21 = <Option<String>>::sse_decode(deserializer);
        let mut var_preimageHash = <String>::sse_decode(deserializer);
        return crate::api::types::DecodedInvoice {
            msats: var_msats,
            expiry: var_expiry,
            expires_in: var_expiresIn,
            expires_at: var_expiresAt,
            is_expired: var_isExpired,
            network: var_network,
            cltv_exp_delta: var_cltvExpDelta,
            bip21: var_bip21,
            preimage_hash: var_preimageHash,
        };
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::fees::Fees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_boltzUrl = <String>::sse_decode(deserializer);
        return crate::api::fees::Fees {
            boltz_url: var_boltzUrl,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::types::KeyPair {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_secretKey = <String>::sse_decode(deserializer);
        let mut var_publicKey = <String>::sse_decode(deserializer);
        return crate::api::types::KeyPair {
            secret_key: var_secretKey,
            public_key: var_publicKey,
        };
    }
}

impl SseDecode for crate::api::types::LBtcSwapScriptStr {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_swapType = <crate::api::types::SwapType>::sse_decode(deserializer);
        let mut var_fundingAddrs = <Option<String>>::sse_decode(deserializer);
        let mut var_hashlock = <String>::sse_decode(deserializer);
        let mut var_receiverPubkey = <String>::sse_decode(deserializer);
        let mut var_locktime = <u32>::sse_decode(deserializer);
        let mut var_senderPubkey = <String>::sse_decode(deserializer);
        let mut var_blindingKey = <String>::sse_decode(deserializer);
        let mut var_side = <Option<crate::api::types::Side>>::sse_decode(deserializer);
        return crate::api::types::LBtcSwapScriptStr {
            swap_type: var_swapType,
            funding_addrs: var_fundingAddrs,
            hashlock: var_hashlock,
            receiver_pubkey: var_receiverPubkey,
            locktime: var_locktime,
            sender_pubkey: var_senderPubkey,
            blinding_key: var_blindingKey,
            side: var_side,
        };
    }
}

impl SseDecode for crate::api::lbtc_ln::LbtcLnSwap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_kind = <crate::api::types::SwapType>::sse_decode(deserializer);
        let mut var_network = <crate::api::types::Chain>::sse_decode(deserializer);
        let mut var_keys = <crate::api::types::KeyPair>::sse_decode(deserializer);
        let mut var_keyIndex = <u64>::sse_decode(deserializer);
        let mut var_preimage = <crate::api::types::PreImage>::sse_decode(deserializer);
        let mut var_swapScript = <crate::api::types::LBtcSwapScriptStr>::sse_decode(deserializer);
        let mut var_invoice = <String>::sse_decode(deserializer);
        let mut var_outAmount = <u64>::sse_decode(deserializer);
        let mut var_scriptAddress = <String>::sse_decode(deserializer);
        let mut var_blindingKey = <String>::sse_decode(deserializer);
        let mut var_electrumUrl = <String>::sse_decode(deserializer);
        let mut var_boltzUrl = <String>::sse_decode(deserializer);
        let mut var_referralId = <Option<String>>::sse_decode(deserializer);
        return crate::api::lbtc_ln::LbtcLnSwap {
            id: var_id,
            kind: var_kind,
            network: var_network,
            keys: var_keys,
            key_index: var_keyIndex,
            preimage: var_preimage,
            swap_script: var_swapScript,
            invoice: var_invoice,
            out_amount: var_outAmount,
            script_address: var_scriptAddress,
            blinding_key: var_blindingKey,
            electrum_url: var_electrumUrl,
            boltz_url: var_boltzUrl,
            referral_id: var_referralId,
        };
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::fees::MinerFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lockup = <u64>::sse_decode(deserializer);
        let mut var_claim = <u64>::sse_decode(deserializer);
        return crate::api::fees::MinerFees {
            lockup: var_lockup,
            claim: var_claim,
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::Side> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::Side>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::types::PreImage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_value = <String>::sse_decode(deserializer);
        let mut var_sha256 = <String>::sse_decode(deserializer);
        let mut var_hash160 = <String>::sse_decode(deserializer);
        return crate::api::types::PreImage {
            value: var_value,
            sha256: var_sha256,
            hash160: var_hash160,
        };
    }
}

impl SseDecode for crate::api::fees::RevSwapFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_percentage = <f64>::sse_decode(deserializer);
        let mut var_minerFees = <crate::api::fees::MinerFees>::sse_decode(deserializer);
        return crate::api::fees::RevSwapFees {
            percentage: var_percentage,
            miner_fees: var_minerFees,
        };
    }
}

impl SseDecode for crate::api::fees::ReverseFeesAndLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_btcLimits = <crate::api::fees::SwapLimits>::sse_decode(deserializer);
        let mut var_lbtcLimits = <crate::api::fees::SwapLimits>::sse_decode(deserializer);
        let mut var_btcFees = <crate::api::fees::RevSwapFees>::sse_decode(deserializer);
        let mut var_lbtcFees = <crate::api::fees::RevSwapFees>::sse_decode(deserializer);
        return crate::api::fees::ReverseFeesAndLimits {
            btc_limits: var_btcLimits,
            lbtc_limits: var_lbtcLimits,
            btc_fees: var_btcFees,
            lbtc_fees: var_lbtcFees,
        };
    }
}

impl SseDecode for crate::api::types::Side {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::Side::Lockup,
            1 => crate::api::types::Side::Claim,
            _ => unreachable!("Invalid variant for Side: {}", inner),
        };
    }
}

impl SseDecode for crate::api::fees::SubSwapFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_percentage = <f64>::sse_decode(deserializer);
        let mut var_minerFees = <u64>::sse_decode(deserializer);
        return crate::api::fees::SubSwapFees {
            percentage: var_percentage,
            miner_fees: var_minerFees,
        };
    }
}

impl SseDecode for crate::api::fees::SubmarineFeesAndLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_btcLimits = <crate::api::fees::SwapLimits>::sse_decode(deserializer);
        let mut var_lbtcLimits = <crate::api::fees::SwapLimits>::sse_decode(deserializer);
        let mut var_btcFees = <crate::api::fees::SubSwapFees>::sse_decode(deserializer);
        let mut var_lbtcFees = <crate::api::fees::SubSwapFees>::sse_decode(deserializer);
        return crate::api::fees::SubmarineFeesAndLimits {
            btc_limits: var_btcLimits,
            lbtc_limits: var_lbtcLimits,
            btc_fees: var_btcFees,
            lbtc_fees: var_lbtcFees,
        };
    }
}

impl SseDecode for crate::api::fees::SwapLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_minimal = <u64>::sse_decode(deserializer);
        let mut var_maximal = <u64>::sse_decode(deserializer);
        return crate::api::fees::SwapLimits {
            minimal: var_minimal,
            maximal: var_maximal,
        };
    }
}

impl SseDecode for crate::api::types::SwapTxKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::SwapTxKind::Claim,
            1 => crate::api::types::SwapTxKind::Refund,
            _ => unreachable!("Invalid variant for SwapTxKind: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::SwapType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::SwapType::Submarine,
            1 => crate::api::types::SwapType::Reverse,
            2 => crate::api::types::SwapType::Chain,
            _ => unreachable!("Invalid variant for SwapType: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::TxFee {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <u64>::sse_decode(deserializer);
                return crate::api::types::TxFee::Absolute(var_field0);
            }
            1 => {
                let mut var_field0 = <f64>::sse_decode(deserializer);
                return crate::api::types::TxFee::Relative(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::BoltzError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.kind.into_into_dart().into_dart(),
            self.message.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::error::BoltzError {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::BoltzError>
    for crate::api::error::BoltzError
{
    fn into_into_dart(self) -> crate::api::error::BoltzError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::btc_ln::BtcLnSwap {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.network.into_into_dart().into_dart(),
            self.keys.into_into_dart().into_dart(),
            self.key_index.into_into_dart().into_dart(),
            self.preimage.into_into_dart().into_dart(),
            self.swap_script.into_into_dart().into_dart(),
            self.invoice.into_into_dart().into_dart(),
            self.script_address.into_into_dart().into_dart(),
            self.out_amount.into_into_dart().into_dart(),
            self.electrum_url.into_into_dart().into_dart(),
            self.boltz_url.into_into_dart().into_dart(),
            self.referral_id.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::btc_ln::BtcLnSwap {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::btc_ln::BtcLnSwap>
    for crate::api::btc_ln::BtcLnSwap
{
    fn into_into_dart(self) -> crate::api::btc_ln::BtcLnSwap {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::BtcSwapScriptStr {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.swap_type.into_into_dart().into_dart(),
            self.funding_addrs.into_into_dart().into_dart(),
            self.hashlock.into_into_dart().into_dart(),
            self.receiver_pubkey.into_into_dart().into_dart(),
            self.locktime.into_into_dart().into_dart(),
            self.sender_pubkey.into_into_dart().into_dart(),
            self.side.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::BtcSwapScriptStr
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::BtcSwapScriptStr>
    for crate::api::types::BtcSwapScriptStr
{
    fn into_into_dart(self) -> crate::api::types::BtcSwapScriptStr {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Chain {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Bitcoin => 0.into_dart(),
            Self::BitcoinTestnet => 1.into_dart(),
            Self::Liquid => 2.into_dart(),
            Self::LiquidTestnet => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Chain {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Chain> for crate::api::types::Chain {
    fn into_into_dart(self) -> crate::api::types::Chain {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::fees::ChainFeesAndLimits {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.btc_limits.into_into_dart().into_dart(),
            self.lbtc_limits.into_into_dart().into_dart(),
            self.btc_fees.into_into_dart().into_dart(),
            self.lbtc_fees.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::fees::ChainFeesAndLimits
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::fees::ChainFeesAndLimits>
    for crate::api::fees::ChainFeesAndLimits
{
    fn into_into_dart(self) -> crate::api::fees::ChainFeesAndLimits {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::chain_swap::ChainSwap {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.is_testnet.into_into_dart().into_dart(),
            self.direction.into_into_dart().into_dart(),
            self.refund_keys.into_into_dart().into_dart(),
            self.refund_index.into_into_dart().into_dart(),
            self.claim_keys.into_into_dart().into_dart(),
            self.claim_index.into_into_dart().into_dart(),
            self.preimage.into_into_dart().into_dart(),
            self.btc_script_str.into_into_dart().into_dart(),
            self.lbtc_script_str.into_into_dart().into_dart(),
            self.script_address.into_into_dart().into_dart(),
            self.out_amount.into_into_dart().into_dart(),
            self.btc_electrum_url.into_into_dart().into_dart(),
            self.lbtc_electrum_url.into_into_dart().into_dart(),
            self.boltz_url.into_into_dart().into_dart(),
            self.referral_id.into_into_dart().into_dart(),
            self.blinding_key.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::chain_swap::ChainSwap
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::chain_swap::ChainSwap>
    for crate::api::chain_swap::ChainSwap
{
    fn into_into_dart(self) -> crate::api::chain_swap::ChainSwap {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChainSwapDirection {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::BtcToLbtc => 0.into_dart(),
            Self::LbtcToBtc => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ChainSwapDirection
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChainSwapDirection>
    for crate::api::types::ChainSwapDirection
{
    fn into_into_dart(self) -> crate::api::types::ChainSwapDirection {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::fees::ChainSwapFees {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.percentage.into_into_dart().into_dart(),
            self.user_lockup.into_into_dart().into_dart(),
            self.user_claim.into_into_dart().into_dart(),
            self.server.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::fees::ChainSwapFees
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::fees::ChainSwapFees>
    for crate::api::fees::ChainSwapFees
{
    fn into_into_dart(self) -> crate::api::fees::ChainSwapFees {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::DecodedInvoice {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.msats.into_into_dart().into_dart(),
            self.expiry.into_into_dart().into_dart(),
            self.expires_in.into_into_dart().into_dart(),
            self.expires_at.into_into_dart().into_dart(),
            self.is_expired.into_into_dart().into_dart(),
            self.network.into_into_dart().into_dart(),
            self.cltv_exp_delta.into_into_dart().into_dart(),
            self.bip21.into_into_dart().into_dart(),
            self.preimage_hash.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::DecodedInvoice
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::DecodedInvoice>
    for crate::api::types::DecodedInvoice
{
    fn into_into_dart(self) -> crate::api::types::DecodedInvoice {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::fees::Fees {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.boltz_url.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::fees::Fees {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::fees::Fees> for crate::api::fees::Fees {
    fn into_into_dart(self) -> crate::api::fees::Fees {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::KeyPair {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.secret_key.into_into_dart().into_dart(),
            self.public_key.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::KeyPair {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::KeyPair> for crate::api::types::KeyPair {
    fn into_into_dart(self) -> crate::api::types::KeyPair {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LBtcSwapScriptStr {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.swap_type.into_into_dart().into_dart(),
            self.funding_addrs.into_into_dart().into_dart(),
            self.hashlock.into_into_dart().into_dart(),
            self.receiver_pubkey.into_into_dart().into_dart(),
            self.locktime.into_into_dart().into_dart(),
            self.sender_pubkey.into_into_dart().into_dart(),
            self.blinding_key.into_into_dart().into_dart(),
            self.side.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::LBtcSwapScriptStr
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LBtcSwapScriptStr>
    for crate::api::types::LBtcSwapScriptStr
{
    fn into_into_dart(self) -> crate::api::types::LBtcSwapScriptStr {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::lbtc_ln::LbtcLnSwap {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.network.into_into_dart().into_dart(),
            self.keys.into_into_dart().into_dart(),
            self.key_index.into_into_dart().into_dart(),
            self.preimage.into_into_dart().into_dart(),
            self.swap_script.into_into_dart().into_dart(),
            self.invoice.into_into_dart().into_dart(),
            self.out_amount.into_into_dart().into_dart(),
            self.script_address.into_into_dart().into_dart(),
            self.blinding_key.into_into_dart().into_dart(),
            self.electrum_url.into_into_dart().into_dart(),
            self.boltz_url.into_into_dart().into_dart(),
            self.referral_id.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::lbtc_ln::LbtcLnSwap
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::lbtc_ln::LbtcLnSwap>
    for crate::api::lbtc_ln::LbtcLnSwap
{
    fn into_into_dart(self) -> crate::api::lbtc_ln::LbtcLnSwap {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::fees::MinerFees {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.lockup.into_into_dart().into_dart(),
            self.claim.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::fees::MinerFees {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::fees::MinerFees>
    for crate::api::fees::MinerFees
{
    fn into_into_dart(self) -> crate::api::fees::MinerFees {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PreImage {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.value.into_into_dart().into_dart(),
            self.sha256.into_into_dart().into_dart(),
            self.hash160.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::PreImage {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PreImage>
    for crate::api::types::PreImage
{
    fn into_into_dart(self) -> crate::api::types::PreImage {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::fees::RevSwapFees {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.percentage.into_into_dart().into_dart(),
            self.miner_fees.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::fees::RevSwapFees {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::fees::RevSwapFees>
    for crate::api::fees::RevSwapFees
{
    fn into_into_dart(self) -> crate::api::fees::RevSwapFees {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::fees::ReverseFeesAndLimits {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.btc_limits.into_into_dart().into_dart(),
            self.lbtc_limits.into_into_dart().into_dart(),
            self.btc_fees.into_into_dart().into_dart(),
            self.lbtc_fees.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::fees::ReverseFeesAndLimits
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::fees::ReverseFeesAndLimits>
    for crate::api::fees::ReverseFeesAndLimits
{
    fn into_into_dart(self) -> crate::api::fees::ReverseFeesAndLimits {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Side {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Lockup => 0.into_dart(),
            Self::Claim => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Side {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Side> for crate::api::types::Side {
    fn into_into_dart(self) -> crate::api::types::Side {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::fees::SubSwapFees {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.percentage.into_into_dart().into_dart(),
            self.miner_fees.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::fees::SubSwapFees {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::fees::SubSwapFees>
    for crate::api::fees::SubSwapFees
{
    fn into_into_dart(self) -> crate::api::fees::SubSwapFees {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::fees::SubmarineFeesAndLimits {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.btc_limits.into_into_dart().into_dart(),
            self.lbtc_limits.into_into_dart().into_dart(),
            self.btc_fees.into_into_dart().into_dart(),
            self.lbtc_fees.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::fees::SubmarineFeesAndLimits
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::fees::SubmarineFeesAndLimits>
    for crate::api::fees::SubmarineFeesAndLimits
{
    fn into_into_dart(self) -> crate::api::fees::SubmarineFeesAndLimits {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::fees::SwapLimits {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.minimal.into_into_dart().into_dart(),
            self.maximal.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::fees::SwapLimits {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::fees::SwapLimits>
    for crate::api::fees::SwapLimits
{
    fn into_into_dart(self) -> crate::api::fees::SwapLimits {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::SwapTxKind {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Claim => 0.into_dart(),
            Self::Refund => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::SwapTxKind {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::SwapTxKind>
    for crate::api::types::SwapTxKind
{
    fn into_into_dart(self) -> crate::api::types::SwapTxKind {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::SwapType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Submarine => 0.into_dart(),
            Self::Reverse => 1.into_dart(),
            Self::Chain => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::SwapType {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::SwapType>
    for crate::api::types::SwapType
{
    fn into_into_dart(self) -> crate::api::types::SwapType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::TxFee {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::TxFee::Absolute(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::TxFee::Relative(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::TxFee {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::TxFee> for crate::api::types::TxFee {
    fn into_into_dart(self) -> crate::api::types::TxFee {
        self
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::error::BoltzError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.kind, serializer);
        <String>::sse_encode(self.message, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::btc_ln::BtcLnSwap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <crate::api::types::SwapType>::sse_encode(self.kind, serializer);
        <crate::api::types::Chain>::sse_encode(self.network, serializer);
        <crate::api::types::KeyPair>::sse_encode(self.keys, serializer);
        <u64>::sse_encode(self.key_index, serializer);
        <crate::api::types::PreImage>::sse_encode(self.preimage, serializer);
        <crate::api::types::BtcSwapScriptStr>::sse_encode(self.swap_script, serializer);
        <String>::sse_encode(self.invoice, serializer);
        <String>::sse_encode(self.script_address, serializer);
        <u64>::sse_encode(self.out_amount, serializer);
        <String>::sse_encode(self.electrum_url, serializer);
        <String>::sse_encode(self.boltz_url, serializer);
        <Option<String>>::sse_encode(self.referral_id, serializer);
    }
}

impl SseEncode for crate::api::types::BtcSwapScriptStr {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::SwapType>::sse_encode(self.swap_type, serializer);
        <Option<String>>::sse_encode(self.funding_addrs, serializer);
        <String>::sse_encode(self.hashlock, serializer);
        <String>::sse_encode(self.receiver_pubkey, serializer);
        <u32>::sse_encode(self.locktime, serializer);
        <String>::sse_encode(self.sender_pubkey, serializer);
        <Option<crate::api::types::Side>>::sse_encode(self.side, serializer);
    }
}

impl SseEncode for crate::api::types::Chain {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::Chain::Bitcoin => 0,
                crate::api::types::Chain::BitcoinTestnet => 1,
                crate::api::types::Chain::Liquid => 2,
                crate::api::types::Chain::LiquidTestnet => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::fees::ChainFeesAndLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::fees::SwapLimits>::sse_encode(self.btc_limits, serializer);
        <crate::api::fees::SwapLimits>::sse_encode(self.lbtc_limits, serializer);
        <crate::api::fees::ChainSwapFees>::sse_encode(self.btc_fees, serializer);
        <crate::api::fees::ChainSwapFees>::sse_encode(self.lbtc_fees, serializer);
    }
}

impl SseEncode for crate::api::chain_swap::ChainSwap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <bool>::sse_encode(self.is_testnet, serializer);
        <crate::api::types::ChainSwapDirection>::sse_encode(self.direction, serializer);
        <crate::api::types::KeyPair>::sse_encode(self.refund_keys, serializer);
        <u64>::sse_encode(self.refund_index, serializer);
        <crate::api::types::KeyPair>::sse_encode(self.claim_keys, serializer);
        <u64>::sse_encode(self.claim_index, serializer);
        <crate::api::types::PreImage>::sse_encode(self.preimage, serializer);
        <crate::api::types::BtcSwapScriptStr>::sse_encode(self.btc_script_str, serializer);
        <crate::api::types::LBtcSwapScriptStr>::sse_encode(self.lbtc_script_str, serializer);
        <String>::sse_encode(self.script_address, serializer);
        <u64>::sse_encode(self.out_amount, serializer);
        <String>::sse_encode(self.btc_electrum_url, serializer);
        <String>::sse_encode(self.lbtc_electrum_url, serializer);
        <String>::sse_encode(self.boltz_url, serializer);
        <Option<String>>::sse_encode(self.referral_id, serializer);
        <String>::sse_encode(self.blinding_key, serializer);
    }
}

impl SseEncode for crate::api::types::ChainSwapDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::ChainSwapDirection::BtcToLbtc => 0,
                crate::api::types::ChainSwapDirection::LbtcToBtc => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::fees::ChainSwapFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.percentage, serializer);
        <u64>::sse_encode(self.user_lockup, serializer);
        <u64>::sse_encode(self.user_claim, serializer);
        <u64>::sse_encode(self.server, serializer);
    }
}

impl SseEncode for crate::api::types::DecodedInvoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.msats, serializer);
        <u64>::sse_encode(self.expiry, serializer);
        <u64>::sse_encode(self.expires_in, serializer);
        <u64>::sse_encode(self.expires_at, serializer);
        <bool>::sse_encode(self.is_expired, serializer);
        <String>::sse_encode(self.network, serializer);
        <u64>::sse_encode(self.cltv_exp_delta, serializer);
        <Option<String>>::sse_encode(self.bip21, serializer);
        <String>::sse_encode(self.preimage_hash, serializer);
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::fees::Fees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.boltz_url, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::types::KeyPair {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.secret_key, serializer);
        <String>::sse_encode(self.public_key, serializer);
    }
}

impl SseEncode for crate::api::types::LBtcSwapScriptStr {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::SwapType>::sse_encode(self.swap_type, serializer);
        <Option<String>>::sse_encode(self.funding_addrs, serializer);
        <String>::sse_encode(self.hashlock, serializer);
        <String>::sse_encode(self.receiver_pubkey, serializer);
        <u32>::sse_encode(self.locktime, serializer);
        <String>::sse_encode(self.sender_pubkey, serializer);
        <String>::sse_encode(self.blinding_key, serializer);
        <Option<crate::api::types::Side>>::sse_encode(self.side, serializer);
    }
}

impl SseEncode for crate::api::lbtc_ln::LbtcLnSwap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <crate::api::types::SwapType>::sse_encode(self.kind, serializer);
        <crate::api::types::Chain>::sse_encode(self.network, serializer);
        <crate::api::types::KeyPair>::sse_encode(self.keys, serializer);
        <u64>::sse_encode(self.key_index, serializer);
        <crate::api::types::PreImage>::sse_encode(self.preimage, serializer);
        <crate::api::types::LBtcSwapScriptStr>::sse_encode(self.swap_script, serializer);
        <String>::sse_encode(self.invoice, serializer);
        <u64>::sse_encode(self.out_amount, serializer);
        <String>::sse_encode(self.script_address, serializer);
        <String>::sse_encode(self.blinding_key, serializer);
        <String>::sse_encode(self.electrum_url, serializer);
        <String>::sse_encode(self.boltz_url, serializer);
        <Option<String>>::sse_encode(self.referral_id, serializer);
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::api::fees::MinerFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.lockup, serializer);
        <u64>::sse_encode(self.claim, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::Side> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::Side>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::types::PreImage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.value, serializer);
        <String>::sse_encode(self.sha256, serializer);
        <String>::sse_encode(self.hash160, serializer);
    }
}

impl SseEncode for crate::api::fees::RevSwapFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.percentage, serializer);
        <crate::api::fees::MinerFees>::sse_encode(self.miner_fees, serializer);
    }
}

impl SseEncode for crate::api::fees::ReverseFeesAndLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::fees::SwapLimits>::sse_encode(self.btc_limits, serializer);
        <crate::api::fees::SwapLimits>::sse_encode(self.lbtc_limits, serializer);
        <crate::api::fees::RevSwapFees>::sse_encode(self.btc_fees, serializer);
        <crate::api::fees::RevSwapFees>::sse_encode(self.lbtc_fees, serializer);
    }
}

impl SseEncode for crate::api::types::Side {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::Side::Lockup => 0,
                crate::api::types::Side::Claim => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::fees::SubSwapFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.percentage, serializer);
        <u64>::sse_encode(self.miner_fees, serializer);
    }
}

impl SseEncode for crate::api::fees::SubmarineFeesAndLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::fees::SwapLimits>::sse_encode(self.btc_limits, serializer);
        <crate::api::fees::SwapLimits>::sse_encode(self.lbtc_limits, serializer);
        <crate::api::fees::SubSwapFees>::sse_encode(self.btc_fees, serializer);
        <crate::api::fees::SubSwapFees>::sse_encode(self.lbtc_fees, serializer);
    }
}

impl SseEncode for crate::api::fees::SwapLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.minimal, serializer);
        <u64>::sse_encode(self.maximal, serializer);
    }
}

impl SseEncode for crate::api::types::SwapTxKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::SwapTxKind::Claim => 0,
                crate::api::types::SwapTxKind::Refund => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::SwapType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::SwapType::Submarine => 0,
                crate::api::types::SwapType::Reverse => 1,
                crate::api::types::SwapType::Chain => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::TxFee {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::TxFee::Absolute(field0) => {
                <i32>::sse_encode(0, serializer);
                <u64>::sse_encode(field0, serializer);
            }
            crate::api::types::TxFee::Relative(field0) => {
                <i32>::sse_encode(1, serializer);
                <f64>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

#[cfg(not(target_family = "wasm"))]
#[path = "frb_generated.io.rs"]
mod io;
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
#[path = "frb_generated.web.rs"]
mod web;
#[cfg(target_family = "wasm")]
pub use web::*;
