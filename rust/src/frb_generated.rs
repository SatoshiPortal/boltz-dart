// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.9.0.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = DcoCodec,
    default_rust_opaque = RustOpaqueNom,
    default_rust_auto_opaque = RustAutoOpaqueNom,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.9.0";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 1150231082;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__error__boltz_error_detail_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::error::BoltzError>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "boltz_error_detail",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::error::BoltzError::detail(&api_that);
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__error__boltz_error_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    kind: impl CstDecode<String>,
    message: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "boltz_error_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_kind = kind.cst_decode();
            let api_message = message.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::error::BoltzError::new(
                        api_kind,
                        api_message,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_broadcast_boltz_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnSwap>,
    signed_hex: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_broadcast_boltz",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_signed_hex = signed_hex.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::btc_ln::BtcLnSwap::broadcast_boltz(
                            &api_that,
                            api_signed_hex,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_broadcast_local_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnSwap>,
    signed_hex: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_broadcast_local",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_signed_hex = signed_hex.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::btc_ln::BtcLnSwap::broadcast_local(
                            &api_that,
                            api_signed_hex,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_claim_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnSwap>,
    out_address: impl CstDecode<String>,
    miner_fee: impl CstDecode<crate::api::types::TxFee>,
    try_cooperate: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_claim",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_miner_fee = miner_fee.cst_decode();
            let api_try_cooperate = try_cooperate.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::btc_ln::BtcLnSwap::claim(
                            &api_that,
                            api_out_address,
                            api_miner_fee,
                            api_try_cooperate,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_coop_close_submarine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnSwap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_coop_close_submarine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok =
                            crate::api::btc_ln::BtcLnSwap::coop_close_submarine(&api_that).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_from_json_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    json_str: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_from_json",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_json_str = json_str.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::btc_ln::BtcLnSwap::from_json(&api_json_str)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_get_completed_submarine_preimage_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnSwap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_get_completed_submarine_preimage",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok =
                            crate::api::btc_ln::BtcLnSwap::get_completed_submarine_preimage(
                                &api_that,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<String>,
    kind: impl CstDecode<crate::api::types::SwapType>,
    network: impl CstDecode<crate::api::types::Chain>,
    keys: impl CstDecode<crate::api::types::KeyPair>,
    key_index: impl CstDecode<u64>,
    preimage: impl CstDecode<crate::api::types::PreImage>,
    swap_script: impl CstDecode<crate::api::types::BtcSwapScriptStr>,
    invoice: impl CstDecode<String>,
    script_address: impl CstDecode<String>,
    out_amount: impl CstDecode<u64>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    referral_id: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_kind = kind.cst_decode();
            let api_network = network.cst_decode();
            let api_keys = keys.cst_decode();
            let api_key_index = key_index.cst_decode();
            let api_preimage = preimage.cst_decode();
            let api_swap_script = swap_script.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_script_address = script_address.cst_decode();
            let api_out_amount = out_amount.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_referral_id = referral_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::btc_ln::BtcLnSwap::new(
                        api_id,
                        api_kind,
                        api_network,
                        api_keys,
                        api_key_index,
                        api_preimage,
                        api_swap_script,
                        api_invoice,
                        api_script_address,
                        api_out_amount,
                        api_electrum_url,
                        api_boltz_url,
                        api_referral_id,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_new_reverse_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
    passphrase: impl CstDecode<Option<String>>,
    index: impl CstDecode<u64>,
    out_amount: impl CstDecode<u64>,
    out_address: impl CstDecode<Option<String>>,
    network: impl CstDecode<crate::api::types::Chain>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    description: impl CstDecode<Option<String>>,
    referral_id: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_new_reverse",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            let api_passphrase = passphrase.cst_decode();
            let api_index = index.cst_decode();
            let api_out_amount = out_amount.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_network = network.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_description = description.cst_decode();
            let api_referral_id = referral_id.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::btc_ln::BtcLnSwap::new_reverse(
                            api_mnemonic,
                            api_passphrase,
                            api_index,
                            api_out_amount,
                            api_out_address,
                            api_network,
                            api_electrum_url,
                            api_boltz_url,
                            api_description,
                            api_referral_id,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_new_submarine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
    passphrase: impl CstDecode<Option<String>>,
    index: impl CstDecode<u64>,
    invoice: impl CstDecode<String>,
    network: impl CstDecode<crate::api::types::Chain>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    referral_id: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_new_submarine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            let api_passphrase = passphrase.cst_decode();
            let api_index = index.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_network = network.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_referral_id = referral_id.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::btc_ln::BtcLnSwap::new_submarine(
                            api_mnemonic,
                            api_passphrase,
                            api_index,
                            api_invoice,
                            api_network,
                            api_electrum_url,
                            api_boltz_url,
                            api_referral_id,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_refund_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnSwap>,
    out_address: impl CstDecode<String>,
    miner_fee: impl CstDecode<crate::api::types::TxFee>,
    try_cooperate: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_refund",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_miner_fee = miner_fee.cst_decode();
            let api_try_cooperate = try_cooperate.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::btc_ln::BtcLnSwap::refund(
                            &api_that,
                            api_out_address,
                            api_miner_fee,
                            api_try_cooperate,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_to_json_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnSwap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_to_json",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::btc_ln::BtcLnSwap::to_json(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__btc_ln__btc_ln_swap_tx_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::btc_ln::BtcLnSwap>,
    is_cooperative: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_ln_swap_tx_size",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_is_cooperative = is_cooperative.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok =
                            crate::api::btc_ln::BtcLnSwap::tx_size(&api_that, api_is_cooperative)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__types__btc_swap_script_str_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    swap_type: impl CstDecode<crate::api::types::SwapType>,
    funding_addrs: impl CstDecode<Option<String>>,
    hashlock: impl CstDecode<String>,
    receiver_pubkey: impl CstDecode<String>,
    locktime: impl CstDecode<u32>,
    sender_pubkey: impl CstDecode<String>,
    side: impl CstDecode<Option<crate::api::types::Side>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "btc_swap_script_str_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_swap_type = swap_type.cst_decode();
            let api_funding_addrs = funding_addrs.cst_decode();
            let api_hashlock = hashlock.cst_decode();
            let api_receiver_pubkey = receiver_pubkey.cst_decode();
            let api_locktime = locktime.cst_decode();
            let api_sender_pubkey = sender_pubkey.cst_decode();
            let api_side = side.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::types::BtcSwapScriptStr::new(
                        api_swap_type,
                        api_funding_addrs,
                        api_hashlock,
                        api_receiver_pubkey,
                        api_locktime,
                        api_sender_pubkey,
                        api_side,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_broadcast_boltz_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::chain_swap::ChainSwap>,
    signed_hex: impl CstDecode<String>,
    kind: impl CstDecode<crate::api::types::SwapTxKind>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_broadcast_boltz",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_signed_hex = signed_hex.cst_decode();
            let api_kind = kind.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::chain_swap::ChainSwap::broadcast_boltz(
                            &api_that,
                            api_signed_hex,
                            api_kind,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_broadcast_local_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::chain_swap::ChainSwap>,
    signed_hex: impl CstDecode<String>,
    kind: impl CstDecode<crate::api::types::SwapTxKind>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_broadcast_local",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_signed_hex = signed_hex.cst_decode();
            let api_kind = kind.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::chain_swap::ChainSwap::broadcast_local(
                            &api_that,
                            api_signed_hex,
                            api_kind,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_claim_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::chain_swap::ChainSwap>,
    out_address: impl CstDecode<String>,
    refund_address: impl CstDecode<String>,
    miner_fee: impl CstDecode<crate::api::types::TxFee>,
    try_cooperate: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_claim",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_refund_address = refund_address.cst_decode();
            let api_miner_fee = miner_fee.cst_decode();
            let api_try_cooperate = try_cooperate.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::chain_swap::ChainSwap::claim(
                            &api_that,
                            api_out_address,
                            api_refund_address,
                            api_miner_fee,
                            api_try_cooperate,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_from_json_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    json_str: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_from_json",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_json_str = json_str.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok =
                            crate::api::chain_swap::ChainSwap::from_json(&api_json_str).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_get_server_lockup_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::chain_swap::ChainSwap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_get_server_lockup",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok =
                            crate::api::chain_swap::ChainSwap::get_server_lockup(&api_that).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_get_user_lockup_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::chain_swap::ChainSwap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_get_user_lockup",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok =
                            crate::api::chain_swap::ChainSwap::get_user_lockup(&api_that).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<String>,
    is_testnet: impl CstDecode<bool>,
    direction: impl CstDecode<crate::api::types::ChainSwapDirection>,
    refund_keys: impl CstDecode<crate::api::types::KeyPair>,
    refund_index: impl CstDecode<u64>,
    claim_keys: impl CstDecode<crate::api::types::KeyPair>,
    claim_index: impl CstDecode<u64>,
    preimage: impl CstDecode<crate::api::types::PreImage>,
    btc_script_str: impl CstDecode<crate::api::types::BtcSwapScriptStr>,
    lbtc_script_str: impl CstDecode<crate::api::types::LBtcSwapScriptStr>,
    script_address: impl CstDecode<String>,
    out_amount: impl CstDecode<u64>,
    btc_electrum_url: impl CstDecode<String>,
    lbtc_electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    referral_id: impl CstDecode<Option<String>>,
    blinding_key: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_is_testnet = is_testnet.cst_decode();
            let api_direction = direction.cst_decode();
            let api_refund_keys = refund_keys.cst_decode();
            let api_refund_index = refund_index.cst_decode();
            let api_claim_keys = claim_keys.cst_decode();
            let api_claim_index = claim_index.cst_decode();
            let api_preimage = preimage.cst_decode();
            let api_btc_script_str = btc_script_str.cst_decode();
            let api_lbtc_script_str = lbtc_script_str.cst_decode();
            let api_script_address = script_address.cst_decode();
            let api_out_amount = out_amount.cst_decode();
            let api_btc_electrum_url = btc_electrum_url.cst_decode();
            let api_lbtc_electrum_url = lbtc_electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_referral_id = referral_id.cst_decode();
            let api_blinding_key = blinding_key.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::chain_swap::ChainSwap::new(
                        api_id,
                        api_is_testnet,
                        api_direction,
                        api_refund_keys,
                        api_refund_index,
                        api_claim_keys,
                        api_claim_index,
                        api_preimage,
                        api_btc_script_str,
                        api_lbtc_script_str,
                        api_script_address,
                        api_out_amount,
                        api_btc_electrum_url,
                        api_lbtc_electrum_url,
                        api_boltz_url,
                        api_referral_id,
                        api_blinding_key,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_new_swap_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    direction: impl CstDecode<crate::api::types::ChainSwapDirection>,
    mnemonic: impl CstDecode<String>,
    passphrase: impl CstDecode<Option<String>>,
    index: impl CstDecode<u64>,
    amount: impl CstDecode<u64>,
    is_testnet: impl CstDecode<bool>,
    btc_electrum_url: impl CstDecode<String>,
    lbtc_electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    referral_id: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_new_swap",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_direction = direction.cst_decode();
            let api_mnemonic = mnemonic.cst_decode();
            let api_passphrase = passphrase.cst_decode();
            let api_index = index.cst_decode();
            let api_amount = amount.cst_decode();
            let api_is_testnet = is_testnet.cst_decode();
            let api_btc_electrum_url = btc_electrum_url.cst_decode();
            let api_lbtc_electrum_url = lbtc_electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_referral_id = referral_id.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::chain_swap::ChainSwap::new_swap(
                            api_direction,
                            api_mnemonic,
                            api_passphrase,
                            api_index,
                            api_amount,
                            api_is_testnet,
                            api_btc_electrum_url,
                            api_lbtc_electrum_url,
                            api_boltz_url,
                            api_referral_id,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_refund_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::chain_swap::ChainSwap>,
    refund_address: impl CstDecode<String>,
    miner_fee: impl CstDecode<crate::api::types::TxFee>,
    try_cooperate: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_refund",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_refund_address = refund_address.cst_decode();
            let api_miner_fee = miner_fee.cst_decode();
            let api_try_cooperate = try_cooperate.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::chain_swap::ChainSwap::refund(
                            &api_that,
                            api_refund_address,
                            api_miner_fee,
                            api_try_cooperate,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__chain_swap__chain_swap_to_json_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::chain_swap::ChainSwap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "chain_swap_to_json",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok =
                            crate::api::chain_swap::ChainSwap::to_json(&api_that).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__types__decoded_invoice_from_string_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    s: impl CstDecode<String>,
    boltz_url: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "decoded_invoice_from_string",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_s = s.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok =
                            crate::api::types::DecodedInvoice::from_string(api_s, api_boltz_url)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__fees__fees_chain_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::fees::Fees>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fees_chain",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::fees::Fees::chain(&api_that).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__fees__fees_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    boltz_url: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fees_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_boltz_url = boltz_url.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::fees::Fees::new(api_boltz_url))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__fees__fees_reverse_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::fees::Fees>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fees_reverse",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::fees::Fees::reverse(&api_that).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__fees__fees_submarine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::fees::Fees>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "fees_submarine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::fees::Fees::submarine(&api_that).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__types__get_voucher_max_amount_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    lnurl: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "get_voucher_max_amount",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_lnurl = lnurl.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok =
                            crate::api::types::get_voucher_max_amount(api_lnurl).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__types__invoice_from_lnurl_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    lnurl: impl CstDecode<String>,
    msats: impl CstDecode<u64>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "invoice_from_lnurl",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_lnurl = lnurl.cst_decode();
            let api_msats = msats.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok =
                            crate::api::types::invoice_from_lnurl(api_lnurl, api_msats).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__types__key_pair_generate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
    passphrase: impl CstDecode<Option<String>>,
    network: impl CstDecode<crate::api::types::Chain>,
    index: impl CstDecode<u64>,
    swap_type: impl CstDecode<crate::api::types::SwapType>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "key_pair_generate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            let api_passphrase = passphrase.cst_decode();
            let api_network = network.cst_decode();
            let api_index = index.cst_decode();
            let api_swap_type = swap_type.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::types::KeyPair::generate(
                        api_mnemonic,
                        api_passphrase,
                        api_network,
                        api_index,
                        api_swap_type,
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__key_pair_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    secret_key: impl CstDecode<String>,
    public_key: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "key_pair_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_secret_key = secret_key.cst_decode();
            let api_public_key = public_key.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::types::KeyPair::new(
                        api_secret_key,
                        api_public_key,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__l_btc_swap_script_str_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    swap_type: impl CstDecode<crate::api::types::SwapType>,
    funding_addrs: impl CstDecode<Option<String>>,
    hashlock: impl CstDecode<String>,
    receiver_pubkey: impl CstDecode<String>,
    locktime: impl CstDecode<u32>,
    sender_pubkey: impl CstDecode<String>,
    blinding_key: impl CstDecode<String>,
    side: impl CstDecode<Option<crate::api::types::Side>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "l_btc_swap_script_str_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_swap_type = swap_type.cst_decode();
            let api_funding_addrs = funding_addrs.cst_decode();
            let api_hashlock = hashlock.cst_decode();
            let api_receiver_pubkey = receiver_pubkey.cst_decode();
            let api_locktime = locktime.cst_decode();
            let api_sender_pubkey = sender_pubkey.cst_decode();
            let api_blinding_key = blinding_key.cst_decode();
            let api_side = side.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::types::LBtcSwapScriptStr::new(
                            api_swap_type,
                            api_funding_addrs,
                            api_hashlock,
                            api_receiver_pubkey,
                            api_locktime,
                            api_sender_pubkey,
                            api_blinding_key,
                            api_side,
                        ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_broadcast_boltz_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnSwap>,
    signed_hex: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_broadcast_boltz",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_signed_hex = signed_hex.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::lbtc_ln::LbtcLnSwap::broadcast_boltz(
                            &api_that,
                            api_signed_hex,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_broadcast_local_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnSwap>,
    signed_hex: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_broadcast_local",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_signed_hex = signed_hex.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::lbtc_ln::LbtcLnSwap::broadcast_local(
                            &api_that,
                            api_signed_hex,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_claim_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnSwap>,
    out_address: impl CstDecode<String>,
    miner_fee: impl CstDecode<crate::api::types::TxFee>,
    try_cooperate: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_claim",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_miner_fee = miner_fee.cst_decode();
            let api_try_cooperate = try_cooperate.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::lbtc_ln::LbtcLnSwap::claim(
                            &api_that,
                            api_out_address,
                            api_miner_fee,
                            api_try_cooperate,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_coop_close_submarine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnSwap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_coop_close_submarine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok =
                            crate::api::lbtc_ln::LbtcLnSwap::coop_close_submarine(&api_that)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_from_json_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    json_str: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_from_json",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_json_str = json_str.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::lbtc_ln::LbtcLnSwap::from_json(&api_json_str)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_get_completed_submarine_preimage_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnSwap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_get_completed_submarine_preimage",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok =
                            crate::api::lbtc_ln::LbtcLnSwap::get_completed_submarine_preimage(
                                &api_that,
                            )
                            .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    id: impl CstDecode<String>,
    kind: impl CstDecode<crate::api::types::SwapType>,
    network: impl CstDecode<crate::api::types::Chain>,
    keys: impl CstDecode<crate::api::types::KeyPair>,
    key_index: impl CstDecode<u64>,
    preimage: impl CstDecode<crate::api::types::PreImage>,
    swap_script: impl CstDecode<crate::api::types::LBtcSwapScriptStr>,
    invoice: impl CstDecode<String>,
    out_amount: impl CstDecode<u64>,
    out_address: impl CstDecode<String>,
    blinding_key: impl CstDecode<String>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    referral_id: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_id = id.cst_decode();
            let api_kind = kind.cst_decode();
            let api_network = network.cst_decode();
            let api_keys = keys.cst_decode();
            let api_key_index = key_index.cst_decode();
            let api_preimage = preimage.cst_decode();
            let api_swap_script = swap_script.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_out_amount = out_amount.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_blinding_key = blinding_key.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_referral_id = referral_id.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::lbtc_ln::LbtcLnSwap::new(
                        api_id,
                        api_kind,
                        api_network,
                        api_keys,
                        api_key_index,
                        api_preimage,
                        api_swap_script,
                        api_invoice,
                        api_out_amount,
                        api_out_address,
                        api_blinding_key,
                        api_electrum_url,
                        api_boltz_url,
                        api_referral_id,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_new_reverse_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
    passphrase: impl CstDecode<Option<String>>,
    index: impl CstDecode<u64>,
    out_amount: impl CstDecode<u64>,
    out_address: impl CstDecode<Option<String>>,
    network: impl CstDecode<crate::api::types::Chain>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    description: impl CstDecode<Option<String>>,
    referral_id: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_new_reverse",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            let api_passphrase = passphrase.cst_decode();
            let api_index = index.cst_decode();
            let api_out_amount = out_amount.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_network = network.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_description = description.cst_decode();
            let api_referral_id = referral_id.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::lbtc_ln::LbtcLnSwap::new_reverse(
                            api_mnemonic,
                            api_passphrase,
                            api_index,
                            api_out_amount,
                            api_out_address,
                            api_network,
                            api_electrum_url,
                            api_boltz_url,
                            api_description,
                            api_referral_id,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_new_submarine_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    mnemonic: impl CstDecode<String>,
    passphrase: impl CstDecode<Option<String>>,
    index: impl CstDecode<u64>,
    invoice: impl CstDecode<String>,
    network: impl CstDecode<crate::api::types::Chain>,
    electrum_url: impl CstDecode<String>,
    boltz_url: impl CstDecode<String>,
    referral_id: impl CstDecode<Option<String>>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_new_submarine",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_mnemonic = mnemonic.cst_decode();
            let api_passphrase = passphrase.cst_decode();
            let api_index = index.cst_decode();
            let api_invoice = invoice.cst_decode();
            let api_network = network.cst_decode();
            let api_electrum_url = electrum_url.cst_decode();
            let api_boltz_url = boltz_url.cst_decode();
            let api_referral_id = referral_id.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::lbtc_ln::LbtcLnSwap::new_submarine(
                            api_mnemonic,
                            api_passphrase,
                            api_index,
                            api_invoice,
                            api_network,
                            api_electrum_url,
                            api_boltz_url,
                            api_referral_id,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_refund_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnSwap>,
    out_address: impl CstDecode<String>,
    miner_fee: impl CstDecode<crate::api::types::TxFee>,
    try_cooperate: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_refund",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_out_address = out_address.cst_decode();
            let api_miner_fee = miner_fee.cst_decode();
            let api_try_cooperate = try_cooperate.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::lbtc_ln::LbtcLnSwap::refund(
                            &api_that,
                            api_out_address,
                            api_miner_fee,
                            api_try_cooperate,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_to_json_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnSwap>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_to_json",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            move |context| {
                transform_result_dco::<_, _, crate::api::error::BoltzError>((move || {
                    let output_ok = crate::api::lbtc_ln::LbtcLnSwap::to_json(&api_that)?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__lbtc_ln__lbtc_ln_swap_tx_size_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    that: impl CstDecode<crate::api::lbtc_ln::LbtcLnSwap>,
    is_cooperative: impl CstDecode<bool>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "lbtc_ln_swap_tx_size",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_that = that.cst_decode();
            let api_is_cooperative = is_cooperative.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok =
                            crate::api::lbtc_ln::LbtcLnSwap::tx_size(&api_that, api_is_cooperative)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__types__pre_image_generate_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "pre_image_generate",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::types::PreImage::generate())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__pre_image_new_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    value: impl CstDecode<String>,
    sha256: impl CstDecode<String>,
    hash160: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "pre_image_new",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_value = value.cst_decode();
            let api_sha256 = sha256.cst_decode();
            let api_hash160 = hash160.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(crate::api::types::PreImage::new(
                        api_value,
                        api_sha256,
                        api_hash160,
                    ))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__validate_lnurl_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    lnurl: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::DcoCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "validate_lnurl",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_lnurl = lnurl.cst_decode();
            move |context| {
                transform_result_dco::<_, _, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::types::validate_lnurl(api_lnurl))?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__types__withdraw_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    lnurl: impl CstDecode<String>,
    invoice: impl CstDecode<String>,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::DcoCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "withdraw",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let api_lnurl = lnurl.cst_decode();
            let api_invoice = invoice.cst_decode();
            move |context| async move {
                transform_result_dco::<_, _, crate::api::error::BoltzError>(
                    (move || async move {
                        let output_ok = crate::api::types::withdraw(api_lnurl, api_invoice).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}

// Section: dart2rust

impl CstDecode<bool> for bool {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bool {
        self
    }
}
impl CstDecode<crate::api::types::Chain> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Chain {
        match self {
            0 => crate::api::types::Chain::Bitcoin,
            1 => crate::api::types::Chain::BitcoinTestnet,
            2 => crate::api::types::Chain::Liquid,
            3 => crate::api::types::Chain::LiquidTestnet,
            _ => unreachable!("Invalid variant for Chain: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::ChainSwapDirection> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::ChainSwapDirection {
        match self {
            0 => crate::api::types::ChainSwapDirection::BtcToLbtc,
            1 => crate::api::types::ChainSwapDirection::LbtcToBtc,
            _ => unreachable!("Invalid variant for ChainSwapDirection: {}", self),
        }
    }
}
impl CstDecode<f64> for f64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> f64 {
        self
    }
}
impl CstDecode<i32> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> i32 {
        self
    }
}
impl CstDecode<crate::api::types::Side> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Side {
        match self {
            0 => crate::api::types::Side::Lockup,
            1 => crate::api::types::Side::Claim,
            _ => unreachable!("Invalid variant for Side: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::SwapTxKind> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::SwapTxKind {
        match self {
            0 => crate::api::types::SwapTxKind::Claim,
            1 => crate::api::types::SwapTxKind::Refund,
            _ => unreachable!("Invalid variant for SwapTxKind: {}", self),
        }
    }
}
impl CstDecode<crate::api::types::SwapType> for i32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::SwapType {
        match self {
            0 => crate::api::types::SwapType::Submarine,
            1 => crate::api::types::SwapType::Reverse,
            2 => crate::api::types::SwapType::Chain,
            _ => unreachable!("Invalid variant for SwapType: {}", self),
        }
    }
}
impl CstDecode<u32> for u32 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u32 {
        self
    }
}
impl CstDecode<u64> for u64 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u64 {
        self
    }
}
impl CstDecode<u8> for u8 {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> u8 {
        self
    }
}
impl CstDecode<usize> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> usize {
        self
    }
}
impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::error::BoltzError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_kind = <String>::sse_decode(deserializer);
        let mut var_message = <String>::sse_decode(deserializer);
        return crate::api::error::BoltzError {
            kind: var_kind,
            message: var_message,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::btc_ln::BtcLnSwap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_kind = <crate::api::types::SwapType>::sse_decode(deserializer);
        let mut var_network = <crate::api::types::Chain>::sse_decode(deserializer);
        let mut var_keys = <crate::api::types::KeyPair>::sse_decode(deserializer);
        let mut var_keyIndex = <u64>::sse_decode(deserializer);
        let mut var_preimage = <crate::api::types::PreImage>::sse_decode(deserializer);
        let mut var_swapScript = <crate::api::types::BtcSwapScriptStr>::sse_decode(deserializer);
        let mut var_invoice = <String>::sse_decode(deserializer);
        let mut var_scriptAddress = <String>::sse_decode(deserializer);
        let mut var_outAmount = <u64>::sse_decode(deserializer);
        let mut var_electrumUrl = <String>::sse_decode(deserializer);
        let mut var_boltzUrl = <String>::sse_decode(deserializer);
        let mut var_referralId = <Option<String>>::sse_decode(deserializer);
        return crate::api::btc_ln::BtcLnSwap {
            id: var_id,
            kind: var_kind,
            network: var_network,
            keys: var_keys,
            key_index: var_keyIndex,
            preimage: var_preimage,
            swap_script: var_swapScript,
            invoice: var_invoice,
            script_address: var_scriptAddress,
            out_amount: var_outAmount,
            electrum_url: var_electrumUrl,
            boltz_url: var_boltzUrl,
            referral_id: var_referralId,
        };
    }
}

impl SseDecode for crate::api::types::BtcSwapScriptStr {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_swapType = <crate::api::types::SwapType>::sse_decode(deserializer);
        let mut var_fundingAddrs = <Option<String>>::sse_decode(deserializer);
        let mut var_hashlock = <String>::sse_decode(deserializer);
        let mut var_receiverPubkey = <String>::sse_decode(deserializer);
        let mut var_locktime = <u32>::sse_decode(deserializer);
        let mut var_senderPubkey = <String>::sse_decode(deserializer);
        let mut var_side = <Option<crate::api::types::Side>>::sse_decode(deserializer);
        return crate::api::types::BtcSwapScriptStr {
            swap_type: var_swapType,
            funding_addrs: var_fundingAddrs,
            hashlock: var_hashlock,
            receiver_pubkey: var_receiverPubkey,
            locktime: var_locktime,
            sender_pubkey: var_senderPubkey,
            side: var_side,
        };
    }
}

impl SseDecode for crate::api::types::Chain {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::Chain::Bitcoin,
            1 => crate::api::types::Chain::BitcoinTestnet,
            2 => crate::api::types::Chain::Liquid,
            3 => crate::api::types::Chain::LiquidTestnet,
            _ => unreachable!("Invalid variant for Chain: {}", inner),
        };
    }
}

impl SseDecode for crate::api::fees::ChainFeesAndLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_btcLimits = <crate::api::fees::SwapLimits>::sse_decode(deserializer);
        let mut var_lbtcLimits = <crate::api::fees::SwapLimits>::sse_decode(deserializer);
        let mut var_btcFees = <crate::api::fees::ChainSwapFees>::sse_decode(deserializer);
        let mut var_lbtcFees = <crate::api::fees::ChainSwapFees>::sse_decode(deserializer);
        return crate::api::fees::ChainFeesAndLimits {
            btc_limits: var_btcLimits,
            lbtc_limits: var_lbtcLimits,
            btc_fees: var_btcFees,
            lbtc_fees: var_lbtcFees,
        };
    }
}

impl SseDecode for crate::api::chain_swap::ChainSwap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_isTestnet = <bool>::sse_decode(deserializer);
        let mut var_direction = <crate::api::types::ChainSwapDirection>::sse_decode(deserializer);
        let mut var_refundKeys = <crate::api::types::KeyPair>::sse_decode(deserializer);
        let mut var_refundIndex = <u64>::sse_decode(deserializer);
        let mut var_claimKeys = <crate::api::types::KeyPair>::sse_decode(deserializer);
        let mut var_claimIndex = <u64>::sse_decode(deserializer);
        let mut var_preimage = <crate::api::types::PreImage>::sse_decode(deserializer);
        let mut var_btcScriptStr = <crate::api::types::BtcSwapScriptStr>::sse_decode(deserializer);
        let mut var_lbtcScriptStr =
            <crate::api::types::LBtcSwapScriptStr>::sse_decode(deserializer);
        let mut var_scriptAddress = <String>::sse_decode(deserializer);
        let mut var_outAmount = <u64>::sse_decode(deserializer);
        let mut var_btcElectrumUrl = <String>::sse_decode(deserializer);
        let mut var_lbtcElectrumUrl = <String>::sse_decode(deserializer);
        let mut var_boltzUrl = <String>::sse_decode(deserializer);
        let mut var_referralId = <Option<String>>::sse_decode(deserializer);
        let mut var_blindingKey = <String>::sse_decode(deserializer);
        return crate::api::chain_swap::ChainSwap {
            id: var_id,
            is_testnet: var_isTestnet,
            direction: var_direction,
            refund_keys: var_refundKeys,
            refund_index: var_refundIndex,
            claim_keys: var_claimKeys,
            claim_index: var_claimIndex,
            preimage: var_preimage,
            btc_script_str: var_btcScriptStr,
            lbtc_script_str: var_lbtcScriptStr,
            script_address: var_scriptAddress,
            out_amount: var_outAmount,
            btc_electrum_url: var_btcElectrumUrl,
            lbtc_electrum_url: var_lbtcElectrumUrl,
            boltz_url: var_boltzUrl,
            referral_id: var_referralId,
            blinding_key: var_blindingKey,
        };
    }
}

impl SseDecode for crate::api::types::ChainSwapDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::ChainSwapDirection::BtcToLbtc,
            1 => crate::api::types::ChainSwapDirection::LbtcToBtc,
            _ => unreachable!("Invalid variant for ChainSwapDirection: {}", inner),
        };
    }
}

impl SseDecode for crate::api::fees::ChainSwapFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_percentage = <f64>::sse_decode(deserializer);
        let mut var_userLockup = <u64>::sse_decode(deserializer);
        let mut var_userClaim = <u64>::sse_decode(deserializer);
        let mut var_server = <u64>::sse_decode(deserializer);
        return crate::api::fees::ChainSwapFees {
            percentage: var_percentage,
            user_lockup: var_userLockup,
            user_claim: var_userClaim,
            server: var_server,
        };
    }
}

impl SseDecode for crate::api::types::DecodedInvoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_msats = <u64>::sse_decode(deserializer);
        let mut var_expiry = <u64>::sse_decode(deserializer);
        let mut var_expiresIn = <u64>::sse_decode(deserializer);
        let mut var_expiresAt = <u64>::sse_decode(deserializer);
        let mut var_isExpired = <bool>::sse_decode(deserializer);
        let mut var_network = <String>::sse_decode(deserializer);
        let mut var_cltvExpDelta = <u64>::sse_decode(deserializer);
        let mut var_bip21 = <Option<String>>::sse_decode(deserializer);
        let mut var_preimageHash = <String>::sse_decode(deserializer);
        let mut var_description = <String>::sse_decode(deserializer);
        return crate::api::types::DecodedInvoice {
            msats: var_msats,
            expiry: var_expiry,
            expires_in: var_expiresIn,
            expires_at: var_expiresAt,
            is_expired: var_isExpired,
            network: var_network,
            cltv_exp_delta: var_cltvExpDelta,
            bip21: var_bip21,
            preimage_hash: var_preimageHash,
            description: var_description,
        };
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::fees::Fees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_boltzUrl = <String>::sse_decode(deserializer);
        return crate::api::fees::Fees {
            boltz_url: var_boltzUrl,
        };
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::types::KeyPair {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_secretKey = <String>::sse_decode(deserializer);
        let mut var_publicKey = <String>::sse_decode(deserializer);
        return crate::api::types::KeyPair {
            secret_key: var_secretKey,
            public_key: var_publicKey,
        };
    }
}

impl SseDecode for crate::api::types::LBtcSwapScriptStr {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_swapType = <crate::api::types::SwapType>::sse_decode(deserializer);
        let mut var_fundingAddrs = <Option<String>>::sse_decode(deserializer);
        let mut var_hashlock = <String>::sse_decode(deserializer);
        let mut var_receiverPubkey = <String>::sse_decode(deserializer);
        let mut var_locktime = <u32>::sse_decode(deserializer);
        let mut var_senderPubkey = <String>::sse_decode(deserializer);
        let mut var_blindingKey = <String>::sse_decode(deserializer);
        let mut var_side = <Option<crate::api::types::Side>>::sse_decode(deserializer);
        return crate::api::types::LBtcSwapScriptStr {
            swap_type: var_swapType,
            funding_addrs: var_fundingAddrs,
            hashlock: var_hashlock,
            receiver_pubkey: var_receiverPubkey,
            locktime: var_locktime,
            sender_pubkey: var_senderPubkey,
            blinding_key: var_blindingKey,
            side: var_side,
        };
    }
}

impl SseDecode for crate::api::lbtc_ln::LbtcLnSwap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_kind = <crate::api::types::SwapType>::sse_decode(deserializer);
        let mut var_network = <crate::api::types::Chain>::sse_decode(deserializer);
        let mut var_keys = <crate::api::types::KeyPair>::sse_decode(deserializer);
        let mut var_keyIndex = <u64>::sse_decode(deserializer);
        let mut var_preimage = <crate::api::types::PreImage>::sse_decode(deserializer);
        let mut var_swapScript = <crate::api::types::LBtcSwapScriptStr>::sse_decode(deserializer);
        let mut var_invoice = <String>::sse_decode(deserializer);
        let mut var_outAmount = <u64>::sse_decode(deserializer);
        let mut var_scriptAddress = <String>::sse_decode(deserializer);
        let mut var_blindingKey = <String>::sse_decode(deserializer);
        let mut var_electrumUrl = <String>::sse_decode(deserializer);
        let mut var_boltzUrl = <String>::sse_decode(deserializer);
        let mut var_referralId = <Option<String>>::sse_decode(deserializer);
        return crate::api::lbtc_ln::LbtcLnSwap {
            id: var_id,
            kind: var_kind,
            network: var_network,
            keys: var_keys,
            key_index: var_keyIndex,
            preimage: var_preimage,
            swap_script: var_swapScript,
            invoice: var_invoice,
            out_amount: var_outAmount,
            script_address: var_scriptAddress,
            blinding_key: var_blindingKey,
            electrum_url: var_electrumUrl,
            boltz_url: var_boltzUrl,
            referral_id: var_referralId,
        };
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::fees::MinerFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_lockup = <u64>::sse_decode(deserializer);
        let mut var_claim = <u64>::sse_decode(deserializer);
        return crate::api::fees::MinerFees {
            lockup: var_lockup,
            claim: var_claim,
        };
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::types::Side> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::types::Side>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::types::PreImage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_value = <String>::sse_decode(deserializer);
        let mut var_sha256 = <String>::sse_decode(deserializer);
        let mut var_hash160 = <String>::sse_decode(deserializer);
        return crate::api::types::PreImage {
            value: var_value,
            sha256: var_sha256,
            hash160: var_hash160,
        };
    }
}

impl SseDecode for crate::api::fees::RevSwapFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_percentage = <f64>::sse_decode(deserializer);
        let mut var_minerFees = <crate::api::fees::MinerFees>::sse_decode(deserializer);
        return crate::api::fees::RevSwapFees {
            percentage: var_percentage,
            miner_fees: var_minerFees,
        };
    }
}

impl SseDecode for crate::api::fees::ReverseFeesAndLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_btcLimits = <crate::api::fees::SwapLimits>::sse_decode(deserializer);
        let mut var_lbtcLimits = <crate::api::fees::SwapLimits>::sse_decode(deserializer);
        let mut var_btcFees = <crate::api::fees::RevSwapFees>::sse_decode(deserializer);
        let mut var_lbtcFees = <crate::api::fees::RevSwapFees>::sse_decode(deserializer);
        return crate::api::fees::ReverseFeesAndLimits {
            btc_limits: var_btcLimits,
            lbtc_limits: var_lbtcLimits,
            btc_fees: var_btcFees,
            lbtc_fees: var_lbtcFees,
        };
    }
}

impl SseDecode for crate::api::types::Side {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::Side::Lockup,
            1 => crate::api::types::Side::Claim,
            _ => unreachable!("Invalid variant for Side: {}", inner),
        };
    }
}

impl SseDecode for crate::api::fees::SubSwapFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_percentage = <f64>::sse_decode(deserializer);
        let mut var_minerFees = <u64>::sse_decode(deserializer);
        return crate::api::fees::SubSwapFees {
            percentage: var_percentage,
            miner_fees: var_minerFees,
        };
    }
}

impl SseDecode for crate::api::fees::SubmarineFeesAndLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_btcLimits = <crate::api::fees::SwapLimits>::sse_decode(deserializer);
        let mut var_lbtcLimits = <crate::api::fees::SwapLimits>::sse_decode(deserializer);
        let mut var_btcFees = <crate::api::fees::SubSwapFees>::sse_decode(deserializer);
        let mut var_lbtcFees = <crate::api::fees::SubSwapFees>::sse_decode(deserializer);
        return crate::api::fees::SubmarineFeesAndLimits {
            btc_limits: var_btcLimits,
            lbtc_limits: var_lbtcLimits,
            btc_fees: var_btcFees,
            lbtc_fees: var_lbtcFees,
        };
    }
}

impl SseDecode for crate::api::fees::SwapLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_minimal = <u64>::sse_decode(deserializer);
        let mut var_maximal = <u64>::sse_decode(deserializer);
        return crate::api::fees::SwapLimits {
            minimal: var_minimal,
            maximal: var_maximal,
        };
    }
}

impl SseDecode for crate::api::types::SwapTxKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::SwapTxKind::Claim,
            1 => crate::api::types::SwapTxKind::Refund,
            _ => unreachable!("Invalid variant for SwapTxKind: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::SwapType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::types::SwapType::Submarine,
            1 => crate::api::types::SwapType::Reverse,
            2 => crate::api::types::SwapType::Chain,
            _ => unreachable!("Invalid variant for SwapType: {}", inner),
        };
    }
}

impl SseDecode for crate::api::types::TxFee {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 = <u64>::sse_decode(deserializer);
                return crate::api::types::TxFee::Absolute(var_field0);
            }
            1 => {
                let mut var_field0 = <f64>::sse_decode(deserializer);
                return crate::api::types::TxFee::Relative(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::error::BoltzError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.kind.into_into_dart().into_dart(),
            self.message.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::error::BoltzError {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::error::BoltzError>
    for crate::api::error::BoltzError
{
    fn into_into_dart(self) -> crate::api::error::BoltzError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::btc_ln::BtcLnSwap {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.network.into_into_dart().into_dart(),
            self.keys.into_into_dart().into_dart(),
            self.key_index.into_into_dart().into_dart(),
            self.preimage.into_into_dart().into_dart(),
            self.swap_script.into_into_dart().into_dart(),
            self.invoice.into_into_dart().into_dart(),
            self.script_address.into_into_dart().into_dart(),
            self.out_amount.into_into_dart().into_dart(),
            self.electrum_url.into_into_dart().into_dart(),
            self.boltz_url.into_into_dart().into_dart(),
            self.referral_id.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::btc_ln::BtcLnSwap {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::btc_ln::BtcLnSwap>
    for crate::api::btc_ln::BtcLnSwap
{
    fn into_into_dart(self) -> crate::api::btc_ln::BtcLnSwap {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::BtcSwapScriptStr {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.swap_type.into_into_dart().into_dart(),
            self.funding_addrs.into_into_dart().into_dart(),
            self.hashlock.into_into_dart().into_dart(),
            self.receiver_pubkey.into_into_dart().into_dart(),
            self.locktime.into_into_dart().into_dart(),
            self.sender_pubkey.into_into_dart().into_dart(),
            self.side.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::BtcSwapScriptStr
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::BtcSwapScriptStr>
    for crate::api::types::BtcSwapScriptStr
{
    fn into_into_dart(self) -> crate::api::types::BtcSwapScriptStr {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Chain {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Bitcoin => 0.into_dart(),
            Self::BitcoinTestnet => 1.into_dart(),
            Self::Liquid => 2.into_dart(),
            Self::LiquidTestnet => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Chain {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Chain> for crate::api::types::Chain {
    fn into_into_dart(self) -> crate::api::types::Chain {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::fees::ChainFeesAndLimits {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.btc_limits.into_into_dart().into_dart(),
            self.lbtc_limits.into_into_dart().into_dart(),
            self.btc_fees.into_into_dart().into_dart(),
            self.lbtc_fees.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::fees::ChainFeesAndLimits
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::fees::ChainFeesAndLimits>
    for crate::api::fees::ChainFeesAndLimits
{
    fn into_into_dart(self) -> crate::api::fees::ChainFeesAndLimits {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::chain_swap::ChainSwap {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.is_testnet.into_into_dart().into_dart(),
            self.direction.into_into_dart().into_dart(),
            self.refund_keys.into_into_dart().into_dart(),
            self.refund_index.into_into_dart().into_dart(),
            self.claim_keys.into_into_dart().into_dart(),
            self.claim_index.into_into_dart().into_dart(),
            self.preimage.into_into_dart().into_dart(),
            self.btc_script_str.into_into_dart().into_dart(),
            self.lbtc_script_str.into_into_dart().into_dart(),
            self.script_address.into_into_dart().into_dart(),
            self.out_amount.into_into_dart().into_dart(),
            self.btc_electrum_url.into_into_dart().into_dart(),
            self.lbtc_electrum_url.into_into_dart().into_dart(),
            self.boltz_url.into_into_dart().into_dart(),
            self.referral_id.into_into_dart().into_dart(),
            self.blinding_key.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::chain_swap::ChainSwap
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::chain_swap::ChainSwap>
    for crate::api::chain_swap::ChainSwap
{
    fn into_into_dart(self) -> crate::api::chain_swap::ChainSwap {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::ChainSwapDirection {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::BtcToLbtc => 0.into_dart(),
            Self::LbtcToBtc => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::ChainSwapDirection
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::ChainSwapDirection>
    for crate::api::types::ChainSwapDirection
{
    fn into_into_dart(self) -> crate::api::types::ChainSwapDirection {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::fees::ChainSwapFees {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.percentage.into_into_dart().into_dart(),
            self.user_lockup.into_into_dart().into_dart(),
            self.user_claim.into_into_dart().into_dart(),
            self.server.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::fees::ChainSwapFees
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::fees::ChainSwapFees>
    for crate::api::fees::ChainSwapFees
{
    fn into_into_dart(self) -> crate::api::fees::ChainSwapFees {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::DecodedInvoice {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.msats.into_into_dart().into_dart(),
            self.expiry.into_into_dart().into_dart(),
            self.expires_in.into_into_dart().into_dart(),
            self.expires_at.into_into_dart().into_dart(),
            self.is_expired.into_into_dart().into_dart(),
            self.network.into_into_dart().into_dart(),
            self.cltv_exp_delta.into_into_dart().into_dart(),
            self.bip21.into_into_dart().into_dart(),
            self.preimage_hash.into_into_dart().into_dart(),
            self.description.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::DecodedInvoice
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::DecodedInvoice>
    for crate::api::types::DecodedInvoice
{
    fn into_into_dart(self) -> crate::api::types::DecodedInvoice {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::fees::Fees {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.boltz_url.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::fees::Fees {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::fees::Fees> for crate::api::fees::Fees {
    fn into_into_dart(self) -> crate::api::fees::Fees {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::KeyPair {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.secret_key.into_into_dart().into_dart(),
            self.public_key.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::KeyPair {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::KeyPair> for crate::api::types::KeyPair {
    fn into_into_dart(self) -> crate::api::types::KeyPair {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::LBtcSwapScriptStr {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.swap_type.into_into_dart().into_dart(),
            self.funding_addrs.into_into_dart().into_dart(),
            self.hashlock.into_into_dart().into_dart(),
            self.receiver_pubkey.into_into_dart().into_dart(),
            self.locktime.into_into_dart().into_dart(),
            self.sender_pubkey.into_into_dart().into_dart(),
            self.blinding_key.into_into_dart().into_dart(),
            self.side.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::types::LBtcSwapScriptStr
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::LBtcSwapScriptStr>
    for crate::api::types::LBtcSwapScriptStr
{
    fn into_into_dart(self) -> crate::api::types::LBtcSwapScriptStr {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::lbtc_ln::LbtcLnSwap {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.kind.into_into_dart().into_dart(),
            self.network.into_into_dart().into_dart(),
            self.keys.into_into_dart().into_dart(),
            self.key_index.into_into_dart().into_dart(),
            self.preimage.into_into_dart().into_dart(),
            self.swap_script.into_into_dart().into_dart(),
            self.invoice.into_into_dart().into_dart(),
            self.out_amount.into_into_dart().into_dart(),
            self.script_address.into_into_dart().into_dart(),
            self.blinding_key.into_into_dart().into_dart(),
            self.electrum_url.into_into_dart().into_dart(),
            self.boltz_url.into_into_dart().into_dart(),
            self.referral_id.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::lbtc_ln::LbtcLnSwap
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::lbtc_ln::LbtcLnSwap>
    for crate::api::lbtc_ln::LbtcLnSwap
{
    fn into_into_dart(self) -> crate::api::lbtc_ln::LbtcLnSwap {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::fees::MinerFees {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.lockup.into_into_dart().into_dart(),
            self.claim.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::fees::MinerFees {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::fees::MinerFees>
    for crate::api::fees::MinerFees
{
    fn into_into_dart(self) -> crate::api::fees::MinerFees {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::PreImage {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.value.into_into_dart().into_dart(),
            self.sha256.into_into_dart().into_dart(),
            self.hash160.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::PreImage {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::PreImage>
    for crate::api::types::PreImage
{
    fn into_into_dart(self) -> crate::api::types::PreImage {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::fees::RevSwapFees {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.percentage.into_into_dart().into_dart(),
            self.miner_fees.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::fees::RevSwapFees {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::fees::RevSwapFees>
    for crate::api::fees::RevSwapFees
{
    fn into_into_dart(self) -> crate::api::fees::RevSwapFees {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::fees::ReverseFeesAndLimits {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.btc_limits.into_into_dart().into_dart(),
            self.lbtc_limits.into_into_dart().into_dart(),
            self.btc_fees.into_into_dart().into_dart(),
            self.lbtc_fees.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::fees::ReverseFeesAndLimits
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::fees::ReverseFeesAndLimits>
    for crate::api::fees::ReverseFeesAndLimits
{
    fn into_into_dart(self) -> crate::api::fees::ReverseFeesAndLimits {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::Side {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Lockup => 0.into_dart(),
            Self::Claim => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::Side {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::Side> for crate::api::types::Side {
    fn into_into_dart(self) -> crate::api::types::Side {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::fees::SubSwapFees {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.percentage.into_into_dart().into_dart(),
            self.miner_fees.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::fees::SubSwapFees {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::fees::SubSwapFees>
    for crate::api::fees::SubSwapFees
{
    fn into_into_dart(self) -> crate::api::fees::SubSwapFees {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::fees::SubmarineFeesAndLimits {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.btc_limits.into_into_dart().into_dart(),
            self.lbtc_limits.into_into_dart().into_dart(),
            self.btc_fees.into_into_dart().into_dart(),
            self.lbtc_fees.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::fees::SubmarineFeesAndLimits
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::fees::SubmarineFeesAndLimits>
    for crate::api::fees::SubmarineFeesAndLimits
{
    fn into_into_dart(self) -> crate::api::fees::SubmarineFeesAndLimits {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::fees::SwapLimits {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.minimal.into_into_dart().into_dart(),
            self.maximal.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::fees::SwapLimits {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::fees::SwapLimits>
    for crate::api::fees::SwapLimits
{
    fn into_into_dart(self) -> crate::api::fees::SwapLimits {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::SwapTxKind {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Claim => 0.into_dart(),
            Self::Refund => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::SwapTxKind {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::SwapTxKind>
    for crate::api::types::SwapTxKind
{
    fn into_into_dart(self) -> crate::api::types::SwapTxKind {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::SwapType {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Submarine => 0.into_dart(),
            Self::Reverse => 1.into_dart(),
            Self::Chain => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::SwapType {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::SwapType>
    for crate::api::types::SwapType
{
    fn into_into_dart(self) -> crate::api::types::SwapType {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::types::TxFee {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::types::TxFee::Absolute(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::types::TxFee::Relative(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::types::TxFee {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::types::TxFee> for crate::api::types::TxFee {
    fn into_into_dart(self) -> crate::api::types::TxFee {
        self
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::error::BoltzError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.kind, serializer);
        <String>::sse_encode(self.message, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::btc_ln::BtcLnSwap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <crate::api::types::SwapType>::sse_encode(self.kind, serializer);
        <crate::api::types::Chain>::sse_encode(self.network, serializer);
        <crate::api::types::KeyPair>::sse_encode(self.keys, serializer);
        <u64>::sse_encode(self.key_index, serializer);
        <crate::api::types::PreImage>::sse_encode(self.preimage, serializer);
        <crate::api::types::BtcSwapScriptStr>::sse_encode(self.swap_script, serializer);
        <String>::sse_encode(self.invoice, serializer);
        <String>::sse_encode(self.script_address, serializer);
        <u64>::sse_encode(self.out_amount, serializer);
        <String>::sse_encode(self.electrum_url, serializer);
        <String>::sse_encode(self.boltz_url, serializer);
        <Option<String>>::sse_encode(self.referral_id, serializer);
    }
}

impl SseEncode for crate::api::types::BtcSwapScriptStr {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::SwapType>::sse_encode(self.swap_type, serializer);
        <Option<String>>::sse_encode(self.funding_addrs, serializer);
        <String>::sse_encode(self.hashlock, serializer);
        <String>::sse_encode(self.receiver_pubkey, serializer);
        <u32>::sse_encode(self.locktime, serializer);
        <String>::sse_encode(self.sender_pubkey, serializer);
        <Option<crate::api::types::Side>>::sse_encode(self.side, serializer);
    }
}

impl SseEncode for crate::api::types::Chain {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::Chain::Bitcoin => 0,
                crate::api::types::Chain::BitcoinTestnet => 1,
                crate::api::types::Chain::Liquid => 2,
                crate::api::types::Chain::LiquidTestnet => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::fees::ChainFeesAndLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::fees::SwapLimits>::sse_encode(self.btc_limits, serializer);
        <crate::api::fees::SwapLimits>::sse_encode(self.lbtc_limits, serializer);
        <crate::api::fees::ChainSwapFees>::sse_encode(self.btc_fees, serializer);
        <crate::api::fees::ChainSwapFees>::sse_encode(self.lbtc_fees, serializer);
    }
}

impl SseEncode for crate::api::chain_swap::ChainSwap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <bool>::sse_encode(self.is_testnet, serializer);
        <crate::api::types::ChainSwapDirection>::sse_encode(self.direction, serializer);
        <crate::api::types::KeyPair>::sse_encode(self.refund_keys, serializer);
        <u64>::sse_encode(self.refund_index, serializer);
        <crate::api::types::KeyPair>::sse_encode(self.claim_keys, serializer);
        <u64>::sse_encode(self.claim_index, serializer);
        <crate::api::types::PreImage>::sse_encode(self.preimage, serializer);
        <crate::api::types::BtcSwapScriptStr>::sse_encode(self.btc_script_str, serializer);
        <crate::api::types::LBtcSwapScriptStr>::sse_encode(self.lbtc_script_str, serializer);
        <String>::sse_encode(self.script_address, serializer);
        <u64>::sse_encode(self.out_amount, serializer);
        <String>::sse_encode(self.btc_electrum_url, serializer);
        <String>::sse_encode(self.lbtc_electrum_url, serializer);
        <String>::sse_encode(self.boltz_url, serializer);
        <Option<String>>::sse_encode(self.referral_id, serializer);
        <String>::sse_encode(self.blinding_key, serializer);
    }
}

impl SseEncode for crate::api::types::ChainSwapDirection {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::ChainSwapDirection::BtcToLbtc => 0,
                crate::api::types::ChainSwapDirection::LbtcToBtc => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::fees::ChainSwapFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.percentage, serializer);
        <u64>::sse_encode(self.user_lockup, serializer);
        <u64>::sse_encode(self.user_claim, serializer);
        <u64>::sse_encode(self.server, serializer);
    }
}

impl SseEncode for crate::api::types::DecodedInvoice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.msats, serializer);
        <u64>::sse_encode(self.expiry, serializer);
        <u64>::sse_encode(self.expires_in, serializer);
        <u64>::sse_encode(self.expires_at, serializer);
        <bool>::sse_encode(self.is_expired, serializer);
        <String>::sse_encode(self.network, serializer);
        <u64>::sse_encode(self.cltv_exp_delta, serializer);
        <Option<String>>::sse_encode(self.bip21, serializer);
        <String>::sse_encode(self.preimage_hash, serializer);
        <String>::sse_encode(self.description, serializer);
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::fees::Fees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.boltz_url, serializer);
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::types::KeyPair {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.secret_key, serializer);
        <String>::sse_encode(self.public_key, serializer);
    }
}

impl SseEncode for crate::api::types::LBtcSwapScriptStr {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::types::SwapType>::sse_encode(self.swap_type, serializer);
        <Option<String>>::sse_encode(self.funding_addrs, serializer);
        <String>::sse_encode(self.hashlock, serializer);
        <String>::sse_encode(self.receiver_pubkey, serializer);
        <u32>::sse_encode(self.locktime, serializer);
        <String>::sse_encode(self.sender_pubkey, serializer);
        <String>::sse_encode(self.blinding_key, serializer);
        <Option<crate::api::types::Side>>::sse_encode(self.side, serializer);
    }
}

impl SseEncode for crate::api::lbtc_ln::LbtcLnSwap {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <crate::api::types::SwapType>::sse_encode(self.kind, serializer);
        <crate::api::types::Chain>::sse_encode(self.network, serializer);
        <crate::api::types::KeyPair>::sse_encode(self.keys, serializer);
        <u64>::sse_encode(self.key_index, serializer);
        <crate::api::types::PreImage>::sse_encode(self.preimage, serializer);
        <crate::api::types::LBtcSwapScriptStr>::sse_encode(self.swap_script, serializer);
        <String>::sse_encode(self.invoice, serializer);
        <u64>::sse_encode(self.out_amount, serializer);
        <String>::sse_encode(self.script_address, serializer);
        <String>::sse_encode(self.blinding_key, serializer);
        <String>::sse_encode(self.electrum_url, serializer);
        <String>::sse_encode(self.boltz_url, serializer);
        <Option<String>>::sse_encode(self.referral_id, serializer);
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::api::fees::MinerFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.lockup, serializer);
        <u64>::sse_encode(self.claim, serializer);
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::types::Side> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::types::Side>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for crate::api::types::PreImage {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.value, serializer);
        <String>::sse_encode(self.sha256, serializer);
        <String>::sse_encode(self.hash160, serializer);
    }
}

impl SseEncode for crate::api::fees::RevSwapFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.percentage, serializer);
        <crate::api::fees::MinerFees>::sse_encode(self.miner_fees, serializer);
    }
}

impl SseEncode for crate::api::fees::ReverseFeesAndLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::fees::SwapLimits>::sse_encode(self.btc_limits, serializer);
        <crate::api::fees::SwapLimits>::sse_encode(self.lbtc_limits, serializer);
        <crate::api::fees::RevSwapFees>::sse_encode(self.btc_fees, serializer);
        <crate::api::fees::RevSwapFees>::sse_encode(self.lbtc_fees, serializer);
    }
}

impl SseEncode for crate::api::types::Side {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::Side::Lockup => 0,
                crate::api::types::Side::Claim => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::fees::SubSwapFees {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <f64>::sse_encode(self.percentage, serializer);
        <u64>::sse_encode(self.miner_fees, serializer);
    }
}

impl SseEncode for crate::api::fees::SubmarineFeesAndLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <crate::api::fees::SwapLimits>::sse_encode(self.btc_limits, serializer);
        <crate::api::fees::SwapLimits>::sse_encode(self.lbtc_limits, serializer);
        <crate::api::fees::SubSwapFees>::sse_encode(self.btc_fees, serializer);
        <crate::api::fees::SubSwapFees>::sse_encode(self.lbtc_fees, serializer);
    }
}

impl SseEncode for crate::api::fees::SwapLimits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <u64>::sse_encode(self.minimal, serializer);
        <u64>::sse_encode(self.maximal, serializer);
    }
}

impl SseEncode for crate::api::types::SwapTxKind {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::SwapTxKind::Claim => 0,
                crate::api::types::SwapTxKind::Refund => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::SwapType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::types::SwapType::Submarine => 0,
                crate::api::types::SwapType::Reverse => 1,
                crate::api::types::SwapType::Chain => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::types::TxFee {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::types::TxFee::Absolute(field0) => {
                <i32>::sse_encode(0, serializer);
                <u64>::sse_encode(field0, serializer);
            }
            crate::api::types::TxFee::Relative(field0) => {
                <i32>::sse_encode(1, serializer);
                <f64>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.9.0.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    // Section: dart2rust

    impl CstDecode<String> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            let vec: Vec<u8> = self.cst_decode();
            String::from_utf8(vec).unwrap()
        }
    }
    impl CstDecode<crate::api::error::BoltzError> for wire_cst_boltz_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::BoltzError {
            crate::api::error::BoltzError {
                kind: self.kind.cst_decode(),
                message: self.message.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::error::BoltzError> for *mut wire_cst_boltz_error {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::BoltzError {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::error::BoltzError>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::btc_ln::BtcLnSwap> for *mut wire_cst_btc_ln_swap {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::btc_ln::BtcLnSwap {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::btc_ln::BtcLnSwap>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::BtcSwapScriptStr> for *mut wire_cst_btc_swap_script_str {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::BtcSwapScriptStr {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::BtcSwapScriptStr>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::chain_swap::ChainSwap> for *mut wire_cst_chain_swap {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::chain_swap::ChainSwap {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::chain_swap::ChainSwap>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::fees::Fees> for *mut wire_cst_fees {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::fees::Fees {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::fees::Fees>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::KeyPair> for *mut wire_cst_key_pair {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::KeyPair {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::KeyPair>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::LBtcSwapScriptStr> for *mut wire_cst_l_btc_swap_script_str {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::LBtcSwapScriptStr {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::LBtcSwapScriptStr>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::lbtc_ln::LbtcLnSwap> for *mut wire_cst_lbtc_ln_swap {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::lbtc_ln::LbtcLnSwap {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::lbtc_ln::LbtcLnSwap>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::PreImage> for *mut wire_cst_pre_image {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PreImage {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::PreImage>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::Side> for *mut i32 {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Side {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::Side>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::types::TxFee> for *mut wire_cst_tx_fee {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::TxFee {
            let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
            CstDecode::<crate::api::types::TxFee>::cst_decode(*wrap).into()
        }
    }
    impl CstDecode<crate::api::btc_ln::BtcLnSwap> for wire_cst_btc_ln_swap {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::btc_ln::BtcLnSwap {
            crate::api::btc_ln::BtcLnSwap {
                id: self.id.cst_decode(),
                kind: self.kind.cst_decode(),
                network: self.network.cst_decode(),
                keys: self.keys.cst_decode(),
                key_index: self.key_index.cst_decode(),
                preimage: self.preimage.cst_decode(),
                swap_script: self.swap_script.cst_decode(),
                invoice: self.invoice.cst_decode(),
                script_address: self.script_address.cst_decode(),
                out_amount: self.out_amount.cst_decode(),
                electrum_url: self.electrum_url.cst_decode(),
                boltz_url: self.boltz_url.cst_decode(),
                referral_id: self.referral_id.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::BtcSwapScriptStr> for wire_cst_btc_swap_script_str {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::BtcSwapScriptStr {
            crate::api::types::BtcSwapScriptStr {
                swap_type: self.swap_type.cst_decode(),
                funding_addrs: self.funding_addrs.cst_decode(),
                hashlock: self.hashlock.cst_decode(),
                receiver_pubkey: self.receiver_pubkey.cst_decode(),
                locktime: self.locktime.cst_decode(),
                sender_pubkey: self.sender_pubkey.cst_decode(),
                side: self.side.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::fees::ChainFeesAndLimits> for wire_cst_chain_fees_and_limits {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::fees::ChainFeesAndLimits {
            crate::api::fees::ChainFeesAndLimits {
                btc_limits: self.btc_limits.cst_decode(),
                lbtc_limits: self.lbtc_limits.cst_decode(),
                btc_fees: self.btc_fees.cst_decode(),
                lbtc_fees: self.lbtc_fees.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::chain_swap::ChainSwap> for wire_cst_chain_swap {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::chain_swap::ChainSwap {
            crate::api::chain_swap::ChainSwap {
                id: self.id.cst_decode(),
                is_testnet: self.is_testnet.cst_decode(),
                direction: self.direction.cst_decode(),
                refund_keys: self.refund_keys.cst_decode(),
                refund_index: self.refund_index.cst_decode(),
                claim_keys: self.claim_keys.cst_decode(),
                claim_index: self.claim_index.cst_decode(),
                preimage: self.preimage.cst_decode(),
                btc_script_str: self.btc_script_str.cst_decode(),
                lbtc_script_str: self.lbtc_script_str.cst_decode(),
                script_address: self.script_address.cst_decode(),
                out_amount: self.out_amount.cst_decode(),
                btc_electrum_url: self.btc_electrum_url.cst_decode(),
                lbtc_electrum_url: self.lbtc_electrum_url.cst_decode(),
                boltz_url: self.boltz_url.cst_decode(),
                referral_id: self.referral_id.cst_decode(),
                blinding_key: self.blinding_key.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::fees::ChainSwapFees> for wire_cst_chain_swap_fees {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::fees::ChainSwapFees {
            crate::api::fees::ChainSwapFees {
                percentage: self.percentage.cst_decode(),
                user_lockup: self.user_lockup.cst_decode(),
                user_claim: self.user_claim.cst_decode(),
                server: self.server.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::DecodedInvoice> for wire_cst_decoded_invoice {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::DecodedInvoice {
            crate::api::types::DecodedInvoice {
                msats: self.msats.cst_decode(),
                expiry: self.expiry.cst_decode(),
                expires_in: self.expires_in.cst_decode(),
                expires_at: self.expires_at.cst_decode(),
                is_expired: self.is_expired.cst_decode(),
                network: self.network.cst_decode(),
                cltv_exp_delta: self.cltv_exp_delta.cst_decode(),
                bip21: self.bip21.cst_decode(),
                preimage_hash: self.preimage_hash.cst_decode(),
                description: self.description.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::fees::Fees> for wire_cst_fees {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::fees::Fees {
            crate::api::fees::Fees {
                boltz_url: self.boltz_url.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::KeyPair> for wire_cst_key_pair {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::KeyPair {
            crate::api::types::KeyPair {
                secret_key: self.secret_key.cst_decode(),
                public_key: self.public_key.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::LBtcSwapScriptStr> for wire_cst_l_btc_swap_script_str {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::LBtcSwapScriptStr {
            crate::api::types::LBtcSwapScriptStr {
                swap_type: self.swap_type.cst_decode(),
                funding_addrs: self.funding_addrs.cst_decode(),
                hashlock: self.hashlock.cst_decode(),
                receiver_pubkey: self.receiver_pubkey.cst_decode(),
                locktime: self.locktime.cst_decode(),
                sender_pubkey: self.sender_pubkey.cst_decode(),
                blinding_key: self.blinding_key.cst_decode(),
                side: self.side.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::lbtc_ln::LbtcLnSwap> for wire_cst_lbtc_ln_swap {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::lbtc_ln::LbtcLnSwap {
            crate::api::lbtc_ln::LbtcLnSwap {
                id: self.id.cst_decode(),
                kind: self.kind.cst_decode(),
                network: self.network.cst_decode(),
                keys: self.keys.cst_decode(),
                key_index: self.key_index.cst_decode(),
                preimage: self.preimage.cst_decode(),
                swap_script: self.swap_script.cst_decode(),
                invoice: self.invoice.cst_decode(),
                out_amount: self.out_amount.cst_decode(),
                script_address: self.script_address.cst_decode(),
                blinding_key: self.blinding_key.cst_decode(),
                electrum_url: self.electrum_url.cst_decode(),
                boltz_url: self.boltz_url.cst_decode(),
                referral_id: self.referral_id.cst_decode(),
            }
        }
    }
    impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_strict {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            unsafe {
                let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
                flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
            }
        }
    }
    impl CstDecode<crate::api::fees::MinerFees> for wire_cst_miner_fees {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::fees::MinerFees {
            crate::api::fees::MinerFees {
                lockup: self.lockup.cst_decode(),
                claim: self.claim.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::PreImage> for wire_cst_pre_image {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PreImage {
            crate::api::types::PreImage {
                value: self.value.cst_decode(),
                sha256: self.sha256.cst_decode(),
                hash160: self.hash160.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::fees::RevSwapFees> for wire_cst_rev_swap_fees {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::fees::RevSwapFees {
            crate::api::fees::RevSwapFees {
                percentage: self.percentage.cst_decode(),
                miner_fees: self.miner_fees.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::fees::ReverseFeesAndLimits> for wire_cst_reverse_fees_and_limits {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::fees::ReverseFeesAndLimits {
            crate::api::fees::ReverseFeesAndLimits {
                btc_limits: self.btc_limits.cst_decode(),
                lbtc_limits: self.lbtc_limits.cst_decode(),
                btc_fees: self.btc_fees.cst_decode(),
                lbtc_fees: self.lbtc_fees.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::fees::SubSwapFees> for wire_cst_sub_swap_fees {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::fees::SubSwapFees {
            crate::api::fees::SubSwapFees {
                percentage: self.percentage.cst_decode(),
                miner_fees: self.miner_fees.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::fees::SubmarineFeesAndLimits> for wire_cst_submarine_fees_and_limits {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::fees::SubmarineFeesAndLimits {
            crate::api::fees::SubmarineFeesAndLimits {
                btc_limits: self.btc_limits.cst_decode(),
                lbtc_limits: self.lbtc_limits.cst_decode(),
                btc_fees: self.btc_fees.cst_decode(),
                lbtc_fees: self.lbtc_fees.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::fees::SwapLimits> for wire_cst_swap_limits {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::fees::SwapLimits {
            crate::api::fees::SwapLimits {
                minimal: self.minimal.cst_decode(),
                maximal: self.maximal.cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::TxFee> for wire_cst_tx_fee {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::TxFee {
            match self.tag {
                0 => {
                    let ans = unsafe { self.kind.Absolute };
                    crate::api::types::TxFee::Absolute(ans.field0.cst_decode())
                }
                1 => {
                    let ans = unsafe { self.kind.Relative };
                    crate::api::types::TxFee::Relative(ans.field0.cst_decode())
                }
                _ => unreachable!(),
            }
        }
    }
    impl NewWithNullPtr for wire_cst_boltz_error {
        fn new_with_null_ptr() -> Self {
            Self {
                kind: core::ptr::null_mut(),
                message: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_boltz_error {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_btc_ln_swap {
        fn new_with_null_ptr() -> Self {
            Self {
                id: core::ptr::null_mut(),
                kind: Default::default(),
                network: Default::default(),
                keys: Default::default(),
                key_index: Default::default(),
                preimage: Default::default(),
                swap_script: Default::default(),
                invoice: core::ptr::null_mut(),
                script_address: core::ptr::null_mut(),
                out_amount: Default::default(),
                electrum_url: core::ptr::null_mut(),
                boltz_url: core::ptr::null_mut(),
                referral_id: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_btc_ln_swap {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_btc_swap_script_str {
        fn new_with_null_ptr() -> Self {
            Self {
                swap_type: Default::default(),
                funding_addrs: core::ptr::null_mut(),
                hashlock: core::ptr::null_mut(),
                receiver_pubkey: core::ptr::null_mut(),
                locktime: Default::default(),
                sender_pubkey: core::ptr::null_mut(),
                side: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_btc_swap_script_str {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_chain_fees_and_limits {
        fn new_with_null_ptr() -> Self {
            Self {
                btc_limits: Default::default(),
                lbtc_limits: Default::default(),
                btc_fees: Default::default(),
                lbtc_fees: Default::default(),
            }
        }
    }
    impl Default for wire_cst_chain_fees_and_limits {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_chain_swap {
        fn new_with_null_ptr() -> Self {
            Self {
                id: core::ptr::null_mut(),
                is_testnet: Default::default(),
                direction: Default::default(),
                refund_keys: Default::default(),
                refund_index: Default::default(),
                claim_keys: Default::default(),
                claim_index: Default::default(),
                preimage: Default::default(),
                btc_script_str: Default::default(),
                lbtc_script_str: Default::default(),
                script_address: core::ptr::null_mut(),
                out_amount: Default::default(),
                btc_electrum_url: core::ptr::null_mut(),
                lbtc_electrum_url: core::ptr::null_mut(),
                boltz_url: core::ptr::null_mut(),
                referral_id: core::ptr::null_mut(),
                blinding_key: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_chain_swap {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_chain_swap_fees {
        fn new_with_null_ptr() -> Self {
            Self {
                percentage: Default::default(),
                user_lockup: Default::default(),
                user_claim: Default::default(),
                server: Default::default(),
            }
        }
    }
    impl Default for wire_cst_chain_swap_fees {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_decoded_invoice {
        fn new_with_null_ptr() -> Self {
            Self {
                msats: Default::default(),
                expiry: Default::default(),
                expires_in: Default::default(),
                expires_at: Default::default(),
                is_expired: Default::default(),
                network: core::ptr::null_mut(),
                cltv_exp_delta: Default::default(),
                bip21: core::ptr::null_mut(),
                preimage_hash: core::ptr::null_mut(),
                description: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_decoded_invoice {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_fees {
        fn new_with_null_ptr() -> Self {
            Self {
                boltz_url: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_fees {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_key_pair {
        fn new_with_null_ptr() -> Self {
            Self {
                secret_key: core::ptr::null_mut(),
                public_key: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_key_pair {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_l_btc_swap_script_str {
        fn new_with_null_ptr() -> Self {
            Self {
                swap_type: Default::default(),
                funding_addrs: core::ptr::null_mut(),
                hashlock: core::ptr::null_mut(),
                receiver_pubkey: core::ptr::null_mut(),
                locktime: Default::default(),
                sender_pubkey: core::ptr::null_mut(),
                blinding_key: core::ptr::null_mut(),
                side: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_l_btc_swap_script_str {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_lbtc_ln_swap {
        fn new_with_null_ptr() -> Self {
            Self {
                id: core::ptr::null_mut(),
                kind: Default::default(),
                network: Default::default(),
                keys: Default::default(),
                key_index: Default::default(),
                preimage: Default::default(),
                swap_script: Default::default(),
                invoice: core::ptr::null_mut(),
                out_amount: Default::default(),
                script_address: core::ptr::null_mut(),
                blinding_key: core::ptr::null_mut(),
                electrum_url: core::ptr::null_mut(),
                boltz_url: core::ptr::null_mut(),
                referral_id: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_lbtc_ln_swap {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_miner_fees {
        fn new_with_null_ptr() -> Self {
            Self {
                lockup: Default::default(),
                claim: Default::default(),
            }
        }
    }
    impl Default for wire_cst_miner_fees {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_pre_image {
        fn new_with_null_ptr() -> Self {
            Self {
                value: core::ptr::null_mut(),
                sha256: core::ptr::null_mut(),
                hash160: core::ptr::null_mut(),
            }
        }
    }
    impl Default for wire_cst_pre_image {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_rev_swap_fees {
        fn new_with_null_ptr() -> Self {
            Self {
                percentage: Default::default(),
                miner_fees: Default::default(),
            }
        }
    }
    impl Default for wire_cst_rev_swap_fees {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_reverse_fees_and_limits {
        fn new_with_null_ptr() -> Self {
            Self {
                btc_limits: Default::default(),
                lbtc_limits: Default::default(),
                btc_fees: Default::default(),
                lbtc_fees: Default::default(),
            }
        }
    }
    impl Default for wire_cst_reverse_fees_and_limits {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_sub_swap_fees {
        fn new_with_null_ptr() -> Self {
            Self {
                percentage: Default::default(),
                miner_fees: Default::default(),
            }
        }
    }
    impl Default for wire_cst_sub_swap_fees {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_submarine_fees_and_limits {
        fn new_with_null_ptr() -> Self {
            Self {
                btc_limits: Default::default(),
                lbtc_limits: Default::default(),
                btc_fees: Default::default(),
                lbtc_fees: Default::default(),
            }
        }
    }
    impl Default for wire_cst_submarine_fees_and_limits {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_swap_limits {
        fn new_with_null_ptr() -> Self {
            Self {
                minimal: Default::default(),
                maximal: Default::default(),
            }
        }
    }
    impl Default for wire_cst_swap_limits {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }
    impl NewWithNullPtr for wire_cst_tx_fee {
        fn new_with_null_ptr() -> Self {
            Self {
                tag: -1,
                kind: TxFeeKind { nil__: () },
            }
        }
    }
    impl Default for wire_cst_tx_fee {
        fn default() -> Self {
            Self::new_with_null_ptr()
        }
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__error__boltz_error_detail(
        port_: i64,
        that: *mut wire_cst_boltz_error,
    ) {
        wire__crate__api__error__boltz_error_detail_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__error__boltz_error_new(
        port_: i64,
        kind: *mut wire_cst_list_prim_u_8_strict,
        message: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__error__boltz_error_new_impl(port_, kind, message)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__btc_ln__btc_ln_swap_broadcast_boltz(
        port_: i64,
        that: *mut wire_cst_btc_ln_swap,
        signed_hex: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_broadcast_boltz_impl(port_, that, signed_hex)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__btc_ln__btc_ln_swap_broadcast_local(
        port_: i64,
        that: *mut wire_cst_btc_ln_swap,
        signed_hex: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_broadcast_local_impl(port_, that, signed_hex)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__btc_ln__btc_ln_swap_claim(
        port_: i64,
        that: *mut wire_cst_btc_ln_swap,
        out_address: *mut wire_cst_list_prim_u_8_strict,
        miner_fee: *mut wire_cst_tx_fee,
        try_cooperate: bool,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_claim_impl(
            port_,
            that,
            out_address,
            miner_fee,
            try_cooperate,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__btc_ln__btc_ln_swap_coop_close_submarine(
        port_: i64,
        that: *mut wire_cst_btc_ln_swap,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_coop_close_submarine_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__btc_ln__btc_ln_swap_from_json(
        port_: i64,
        json_str: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_from_json_impl(port_, json_str)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__btc_ln__btc_ln_swap_get_completed_submarine_preimage(
        port_: i64,
        that: *mut wire_cst_btc_ln_swap,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_get_completed_submarine_preimage_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__btc_ln__btc_ln_swap_new(
        port_: i64,
        id: *mut wire_cst_list_prim_u_8_strict,
        kind: i32,
        network: i32,
        keys: *mut wire_cst_key_pair,
        key_index: u64,
        preimage: *mut wire_cst_pre_image,
        swap_script: *mut wire_cst_btc_swap_script_str,
        invoice: *mut wire_cst_list_prim_u_8_strict,
        script_address: *mut wire_cst_list_prim_u_8_strict,
        out_amount: u64,
        electrum_url: *mut wire_cst_list_prim_u_8_strict,
        boltz_url: *mut wire_cst_list_prim_u_8_strict,
        referral_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_new_impl(
            port_,
            id,
            kind,
            network,
            keys,
            key_index,
            preimage,
            swap_script,
            invoice,
            script_address,
            out_amount,
            electrum_url,
            boltz_url,
            referral_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__btc_ln__btc_ln_swap_new_reverse(
        port_: i64,
        mnemonic: *mut wire_cst_list_prim_u_8_strict,
        passphrase: *mut wire_cst_list_prim_u_8_strict,
        index: u64,
        out_amount: u64,
        out_address: *mut wire_cst_list_prim_u_8_strict,
        network: i32,
        electrum_url: *mut wire_cst_list_prim_u_8_strict,
        boltz_url: *mut wire_cst_list_prim_u_8_strict,
        description: *mut wire_cst_list_prim_u_8_strict,
        referral_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_new_reverse_impl(
            port_,
            mnemonic,
            passphrase,
            index,
            out_amount,
            out_address,
            network,
            electrum_url,
            boltz_url,
            description,
            referral_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__btc_ln__btc_ln_swap_new_submarine(
        port_: i64,
        mnemonic: *mut wire_cst_list_prim_u_8_strict,
        passphrase: *mut wire_cst_list_prim_u_8_strict,
        index: u64,
        invoice: *mut wire_cst_list_prim_u_8_strict,
        network: i32,
        electrum_url: *mut wire_cst_list_prim_u_8_strict,
        boltz_url: *mut wire_cst_list_prim_u_8_strict,
        referral_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_new_submarine_impl(
            port_,
            mnemonic,
            passphrase,
            index,
            invoice,
            network,
            electrum_url,
            boltz_url,
            referral_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__btc_ln__btc_ln_swap_refund(
        port_: i64,
        that: *mut wire_cst_btc_ln_swap,
        out_address: *mut wire_cst_list_prim_u_8_strict,
        miner_fee: *mut wire_cst_tx_fee,
        try_cooperate: bool,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_refund_impl(
            port_,
            that,
            out_address,
            miner_fee,
            try_cooperate,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__btc_ln__btc_ln_swap_to_json(
        port_: i64,
        that: *mut wire_cst_btc_ln_swap,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_to_json_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__btc_ln__btc_ln_swap_tx_size(
        port_: i64,
        that: *mut wire_cst_btc_ln_swap,
        is_cooperative: bool,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_tx_size_impl(port_, that, is_cooperative)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__types__btc_swap_script_str_new(
        port_: i64,
        swap_type: i32,
        funding_addrs: *mut wire_cst_list_prim_u_8_strict,
        hashlock: *mut wire_cst_list_prim_u_8_strict,
        receiver_pubkey: *mut wire_cst_list_prim_u_8_strict,
        locktime: u32,
        sender_pubkey: *mut wire_cst_list_prim_u_8_strict,
        side: *mut i32,
    ) {
        wire__crate__api__types__btc_swap_script_str_new_impl(
            port_,
            swap_type,
            funding_addrs,
            hashlock,
            receiver_pubkey,
            locktime,
            sender_pubkey,
            side,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__chain_swap__chain_swap_broadcast_boltz(
        port_: i64,
        that: *mut wire_cst_chain_swap,
        signed_hex: *mut wire_cst_list_prim_u_8_strict,
        kind: i32,
    ) {
        wire__crate__api__chain_swap__chain_swap_broadcast_boltz_impl(port_, that, signed_hex, kind)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__chain_swap__chain_swap_broadcast_local(
        port_: i64,
        that: *mut wire_cst_chain_swap,
        signed_hex: *mut wire_cst_list_prim_u_8_strict,
        kind: i32,
    ) {
        wire__crate__api__chain_swap__chain_swap_broadcast_local_impl(port_, that, signed_hex, kind)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__chain_swap__chain_swap_claim(
        port_: i64,
        that: *mut wire_cst_chain_swap,
        out_address: *mut wire_cst_list_prim_u_8_strict,
        refund_address: *mut wire_cst_list_prim_u_8_strict,
        miner_fee: *mut wire_cst_tx_fee,
        try_cooperate: bool,
    ) {
        wire__crate__api__chain_swap__chain_swap_claim_impl(
            port_,
            that,
            out_address,
            refund_address,
            miner_fee,
            try_cooperate,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__chain_swap__chain_swap_from_json(
        port_: i64,
        json_str: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__chain_swap__chain_swap_from_json_impl(port_, json_str)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__chain_swap__chain_swap_get_server_lockup(
        port_: i64,
        that: *mut wire_cst_chain_swap,
    ) {
        wire__crate__api__chain_swap__chain_swap_get_server_lockup_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__chain_swap__chain_swap_get_user_lockup(
        port_: i64,
        that: *mut wire_cst_chain_swap,
    ) {
        wire__crate__api__chain_swap__chain_swap_get_user_lockup_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__chain_swap__chain_swap_new(
        port_: i64,
        id: *mut wire_cst_list_prim_u_8_strict,
        is_testnet: bool,
        direction: i32,
        refund_keys: *mut wire_cst_key_pair,
        refund_index: u64,
        claim_keys: *mut wire_cst_key_pair,
        claim_index: u64,
        preimage: *mut wire_cst_pre_image,
        btc_script_str: *mut wire_cst_btc_swap_script_str,
        lbtc_script_str: *mut wire_cst_l_btc_swap_script_str,
        script_address: *mut wire_cst_list_prim_u_8_strict,
        out_amount: u64,
        btc_electrum_url: *mut wire_cst_list_prim_u_8_strict,
        lbtc_electrum_url: *mut wire_cst_list_prim_u_8_strict,
        boltz_url: *mut wire_cst_list_prim_u_8_strict,
        referral_id: *mut wire_cst_list_prim_u_8_strict,
        blinding_key: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__chain_swap__chain_swap_new_impl(
            port_,
            id,
            is_testnet,
            direction,
            refund_keys,
            refund_index,
            claim_keys,
            claim_index,
            preimage,
            btc_script_str,
            lbtc_script_str,
            script_address,
            out_amount,
            btc_electrum_url,
            lbtc_electrum_url,
            boltz_url,
            referral_id,
            blinding_key,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__chain_swap__chain_swap_new_swap(
        port_: i64,
        direction: i32,
        mnemonic: *mut wire_cst_list_prim_u_8_strict,
        passphrase: *mut wire_cst_list_prim_u_8_strict,
        index: u64,
        amount: u64,
        is_testnet: bool,
        btc_electrum_url: *mut wire_cst_list_prim_u_8_strict,
        lbtc_electrum_url: *mut wire_cst_list_prim_u_8_strict,
        boltz_url: *mut wire_cst_list_prim_u_8_strict,
        referral_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__chain_swap__chain_swap_new_swap_impl(
            port_,
            direction,
            mnemonic,
            passphrase,
            index,
            amount,
            is_testnet,
            btc_electrum_url,
            lbtc_electrum_url,
            boltz_url,
            referral_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__chain_swap__chain_swap_refund(
        port_: i64,
        that: *mut wire_cst_chain_swap,
        refund_address: *mut wire_cst_list_prim_u_8_strict,
        miner_fee: *mut wire_cst_tx_fee,
        try_cooperate: bool,
    ) {
        wire__crate__api__chain_swap__chain_swap_refund_impl(
            port_,
            that,
            refund_address,
            miner_fee,
            try_cooperate,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__chain_swap__chain_swap_to_json(
        port_: i64,
        that: *mut wire_cst_chain_swap,
    ) {
        wire__crate__api__chain_swap__chain_swap_to_json_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__types__decoded_invoice_from_string(
        port_: i64,
        s: *mut wire_cst_list_prim_u_8_strict,
        boltz_url: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__types__decoded_invoice_from_string_impl(port_, s, boltz_url)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__fees__fees_chain(
        port_: i64,
        that: *mut wire_cst_fees,
    ) {
        wire__crate__api__fees__fees_chain_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__fees__fees_new(
        port_: i64,
        boltz_url: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__fees__fees_new_impl(port_, boltz_url)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__fees__fees_reverse(
        port_: i64,
        that: *mut wire_cst_fees,
    ) {
        wire__crate__api__fees__fees_reverse_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__fees__fees_submarine(
        port_: i64,
        that: *mut wire_cst_fees,
    ) {
        wire__crate__api__fees__fees_submarine_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__types__get_voucher_max_amount(
        port_: i64,
        lnurl: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__types__get_voucher_max_amount_impl(port_, lnurl)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__types__invoice_from_lnurl(
        port_: i64,
        lnurl: *mut wire_cst_list_prim_u_8_strict,
        msats: u64,
    ) {
        wire__crate__api__types__invoice_from_lnurl_impl(port_, lnurl, msats)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__types__key_pair_generate(
        port_: i64,
        mnemonic: *mut wire_cst_list_prim_u_8_strict,
        passphrase: *mut wire_cst_list_prim_u_8_strict,
        network: i32,
        index: u64,
        swap_type: i32,
    ) {
        wire__crate__api__types__key_pair_generate_impl(
            port_, mnemonic, passphrase, network, index, swap_type,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__types__key_pair_new(
        port_: i64,
        secret_key: *mut wire_cst_list_prim_u_8_strict,
        public_key: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__types__key_pair_new_impl(port_, secret_key, public_key)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__types__l_btc_swap_script_str_new(
        port_: i64,
        swap_type: i32,
        funding_addrs: *mut wire_cst_list_prim_u_8_strict,
        hashlock: *mut wire_cst_list_prim_u_8_strict,
        receiver_pubkey: *mut wire_cst_list_prim_u_8_strict,
        locktime: u32,
        sender_pubkey: *mut wire_cst_list_prim_u_8_strict,
        blinding_key: *mut wire_cst_list_prim_u_8_strict,
        side: *mut i32,
    ) {
        wire__crate__api__types__l_btc_swap_script_str_new_impl(
            port_,
            swap_type,
            funding_addrs,
            hashlock,
            receiver_pubkey,
            locktime,
            sender_pubkey,
            blinding_key,
            side,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__lbtc_ln__lbtc_ln_swap_broadcast_boltz(
        port_: i64,
        that: *mut wire_cst_lbtc_ln_swap,
        signed_hex: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_broadcast_boltz_impl(port_, that, signed_hex)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__lbtc_ln__lbtc_ln_swap_broadcast_local(
        port_: i64,
        that: *mut wire_cst_lbtc_ln_swap,
        signed_hex: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_broadcast_local_impl(port_, that, signed_hex)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__lbtc_ln__lbtc_ln_swap_claim(
        port_: i64,
        that: *mut wire_cst_lbtc_ln_swap,
        out_address: *mut wire_cst_list_prim_u_8_strict,
        miner_fee: *mut wire_cst_tx_fee,
        try_cooperate: bool,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_claim_impl(
            port_,
            that,
            out_address,
            miner_fee,
            try_cooperate,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__lbtc_ln__lbtc_ln_swap_coop_close_submarine(
        port_: i64,
        that: *mut wire_cst_lbtc_ln_swap,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_coop_close_submarine_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__lbtc_ln__lbtc_ln_swap_from_json(
        port_: i64,
        json_str: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_from_json_impl(port_, json_str)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__lbtc_ln__lbtc_ln_swap_get_completed_submarine_preimage(
        port_: i64,
        that: *mut wire_cst_lbtc_ln_swap,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_get_completed_submarine_preimage_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__lbtc_ln__lbtc_ln_swap_new(
        port_: i64,
        id: *mut wire_cst_list_prim_u_8_strict,
        kind: i32,
        network: i32,
        keys: *mut wire_cst_key_pair,
        key_index: u64,
        preimage: *mut wire_cst_pre_image,
        swap_script: *mut wire_cst_l_btc_swap_script_str,
        invoice: *mut wire_cst_list_prim_u_8_strict,
        out_amount: u64,
        out_address: *mut wire_cst_list_prim_u_8_strict,
        blinding_key: *mut wire_cst_list_prim_u_8_strict,
        electrum_url: *mut wire_cst_list_prim_u_8_strict,
        boltz_url: *mut wire_cst_list_prim_u_8_strict,
        referral_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_new_impl(
            port_,
            id,
            kind,
            network,
            keys,
            key_index,
            preimage,
            swap_script,
            invoice,
            out_amount,
            out_address,
            blinding_key,
            electrum_url,
            boltz_url,
            referral_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__lbtc_ln__lbtc_ln_swap_new_reverse(
        port_: i64,
        mnemonic: *mut wire_cst_list_prim_u_8_strict,
        passphrase: *mut wire_cst_list_prim_u_8_strict,
        index: u64,
        out_amount: u64,
        out_address: *mut wire_cst_list_prim_u_8_strict,
        network: i32,
        electrum_url: *mut wire_cst_list_prim_u_8_strict,
        boltz_url: *mut wire_cst_list_prim_u_8_strict,
        description: *mut wire_cst_list_prim_u_8_strict,
        referral_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_new_reverse_impl(
            port_,
            mnemonic,
            passphrase,
            index,
            out_amount,
            out_address,
            network,
            electrum_url,
            boltz_url,
            description,
            referral_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__lbtc_ln__lbtc_ln_swap_new_submarine(
        port_: i64,
        mnemonic: *mut wire_cst_list_prim_u_8_strict,
        passphrase: *mut wire_cst_list_prim_u_8_strict,
        index: u64,
        invoice: *mut wire_cst_list_prim_u_8_strict,
        network: i32,
        electrum_url: *mut wire_cst_list_prim_u_8_strict,
        boltz_url: *mut wire_cst_list_prim_u_8_strict,
        referral_id: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_new_submarine_impl(
            port_,
            mnemonic,
            passphrase,
            index,
            invoice,
            network,
            electrum_url,
            boltz_url,
            referral_id,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__lbtc_ln__lbtc_ln_swap_refund(
        port_: i64,
        that: *mut wire_cst_lbtc_ln_swap,
        out_address: *mut wire_cst_list_prim_u_8_strict,
        miner_fee: *mut wire_cst_tx_fee,
        try_cooperate: bool,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_refund_impl(
            port_,
            that,
            out_address,
            miner_fee,
            try_cooperate,
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__lbtc_ln__lbtc_ln_swap_to_json(
        port_: i64,
        that: *mut wire_cst_lbtc_ln_swap,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_to_json_impl(port_, that)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__lbtc_ln__lbtc_ln_swap_tx_size(
        port_: i64,
        that: *mut wire_cst_lbtc_ln_swap,
        is_cooperative: bool,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_tx_size_impl(port_, that, is_cooperative)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__types__pre_image_generate(port_: i64) {
        wire__crate__api__types__pre_image_generate_impl(port_)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__types__pre_image_new(
        port_: i64,
        value: *mut wire_cst_list_prim_u_8_strict,
        sha256: *mut wire_cst_list_prim_u_8_strict,
        hash160: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__types__pre_image_new_impl(port_, value, sha256, hash160)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__types__validate_lnurl(
        port_: i64,
        lnurl: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__types__validate_lnurl_impl(port_, lnurl)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_wire__crate__api__types__withdraw(
        port_: i64,
        lnurl: *mut wire_cst_list_prim_u_8_strict,
        invoice: *mut wire_cst_list_prim_u_8_strict,
    ) {
        wire__crate__api__types__withdraw_impl(port_, lnurl, invoice)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_cst_new_box_autoadd_boltz_error() -> *mut wire_cst_boltz_error {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_boltz_error::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_cst_new_box_autoadd_btc_ln_swap() -> *mut wire_cst_btc_ln_swap {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_btc_ln_swap::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_cst_new_box_autoadd_btc_swap_script_str(
    ) -> *mut wire_cst_btc_swap_script_str {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_btc_swap_script_str::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_cst_new_box_autoadd_chain_swap() -> *mut wire_cst_chain_swap {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_chain_swap::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_cst_new_box_autoadd_fees() -> *mut wire_cst_fees {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_fees::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_cst_new_box_autoadd_key_pair() -> *mut wire_cst_key_pair {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_key_pair::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_cst_new_box_autoadd_l_btc_swap_script_str(
    ) -> *mut wire_cst_l_btc_swap_script_str {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_l_btc_swap_script_str::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_cst_new_box_autoadd_lbtc_ln_swap() -> *mut wire_cst_lbtc_ln_swap
    {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(
            wire_cst_lbtc_ln_swap::new_with_null_ptr(),
        )
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_cst_new_box_autoadd_pre_image() -> *mut wire_cst_pre_image {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_pre_image::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_cst_new_box_autoadd_side(value: i32) -> *mut i32 {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(value)
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_cst_new_box_autoadd_tx_fee() -> *mut wire_cst_tx_fee {
        flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_tx_fee::new_with_null_ptr())
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_boltz_cst_new_list_prim_u_8_strict(
        len: i32,
    ) -> *mut wire_cst_list_prim_u_8_strict {
        let ans = wire_cst_list_prim_u_8_strict {
            ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
            len,
        };
        flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
    }

    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_boltz_error {
        kind: *mut wire_cst_list_prim_u_8_strict,
        message: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_btc_ln_swap {
        id: *mut wire_cst_list_prim_u_8_strict,
        kind: i32,
        network: i32,
        keys: wire_cst_key_pair,
        key_index: u64,
        preimage: wire_cst_pre_image,
        swap_script: wire_cst_btc_swap_script_str,
        invoice: *mut wire_cst_list_prim_u_8_strict,
        script_address: *mut wire_cst_list_prim_u_8_strict,
        out_amount: u64,
        electrum_url: *mut wire_cst_list_prim_u_8_strict,
        boltz_url: *mut wire_cst_list_prim_u_8_strict,
        referral_id: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_btc_swap_script_str {
        swap_type: i32,
        funding_addrs: *mut wire_cst_list_prim_u_8_strict,
        hashlock: *mut wire_cst_list_prim_u_8_strict,
        receiver_pubkey: *mut wire_cst_list_prim_u_8_strict,
        locktime: u32,
        sender_pubkey: *mut wire_cst_list_prim_u_8_strict,
        side: *mut i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_chain_fees_and_limits {
        btc_limits: wire_cst_swap_limits,
        lbtc_limits: wire_cst_swap_limits,
        btc_fees: wire_cst_chain_swap_fees,
        lbtc_fees: wire_cst_chain_swap_fees,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_chain_swap {
        id: *mut wire_cst_list_prim_u_8_strict,
        is_testnet: bool,
        direction: i32,
        refund_keys: wire_cst_key_pair,
        refund_index: u64,
        claim_keys: wire_cst_key_pair,
        claim_index: u64,
        preimage: wire_cst_pre_image,
        btc_script_str: wire_cst_btc_swap_script_str,
        lbtc_script_str: wire_cst_l_btc_swap_script_str,
        script_address: *mut wire_cst_list_prim_u_8_strict,
        out_amount: u64,
        btc_electrum_url: *mut wire_cst_list_prim_u_8_strict,
        lbtc_electrum_url: *mut wire_cst_list_prim_u_8_strict,
        boltz_url: *mut wire_cst_list_prim_u_8_strict,
        referral_id: *mut wire_cst_list_prim_u_8_strict,
        blinding_key: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_chain_swap_fees {
        percentage: f64,
        user_lockup: u64,
        user_claim: u64,
        server: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_decoded_invoice {
        msats: u64,
        expiry: u64,
        expires_in: u64,
        expires_at: u64,
        is_expired: bool,
        network: *mut wire_cst_list_prim_u_8_strict,
        cltv_exp_delta: u64,
        bip21: *mut wire_cst_list_prim_u_8_strict,
        preimage_hash: *mut wire_cst_list_prim_u_8_strict,
        description: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_fees {
        boltz_url: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_key_pair {
        secret_key: *mut wire_cst_list_prim_u_8_strict,
        public_key: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_l_btc_swap_script_str {
        swap_type: i32,
        funding_addrs: *mut wire_cst_list_prim_u_8_strict,
        hashlock: *mut wire_cst_list_prim_u_8_strict,
        receiver_pubkey: *mut wire_cst_list_prim_u_8_strict,
        locktime: u32,
        sender_pubkey: *mut wire_cst_list_prim_u_8_strict,
        blinding_key: *mut wire_cst_list_prim_u_8_strict,
        side: *mut i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_lbtc_ln_swap {
        id: *mut wire_cst_list_prim_u_8_strict,
        kind: i32,
        network: i32,
        keys: wire_cst_key_pair,
        key_index: u64,
        preimage: wire_cst_pre_image,
        swap_script: wire_cst_l_btc_swap_script_str,
        invoice: *mut wire_cst_list_prim_u_8_strict,
        out_amount: u64,
        script_address: *mut wire_cst_list_prim_u_8_strict,
        blinding_key: *mut wire_cst_list_prim_u_8_strict,
        electrum_url: *mut wire_cst_list_prim_u_8_strict,
        boltz_url: *mut wire_cst_list_prim_u_8_strict,
        referral_id: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_list_prim_u_8_strict {
        ptr: *mut u8,
        len: i32,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_miner_fees {
        lockup: u64,
        claim: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_pre_image {
        value: *mut wire_cst_list_prim_u_8_strict,
        sha256: *mut wire_cst_list_prim_u_8_strict,
        hash160: *mut wire_cst_list_prim_u_8_strict,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_rev_swap_fees {
        percentage: f64,
        miner_fees: wire_cst_miner_fees,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_reverse_fees_and_limits {
        btc_limits: wire_cst_swap_limits,
        lbtc_limits: wire_cst_swap_limits,
        btc_fees: wire_cst_rev_swap_fees,
        lbtc_fees: wire_cst_rev_swap_fees,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_sub_swap_fees {
        percentage: f64,
        miner_fees: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_submarine_fees_and_limits {
        btc_limits: wire_cst_swap_limits,
        lbtc_limits: wire_cst_swap_limits,
        btc_fees: wire_cst_sub_swap_fees,
        lbtc_fees: wire_cst_sub_swap_fees,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_swap_limits {
        minimal: u64,
        maximal: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_tx_fee {
        tag: i32,
        kind: TxFeeKind,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub union TxFeeKind {
        Absolute: wire_cst_TxFee_Absolute,
        Relative: wire_cst_TxFee_Relative,
        nil__: (),
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_TxFee_Absolute {
        field0: u64,
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct wire_cst_TxFee_Relative {
        field0: f64,
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.9.0.

    // Section: imports

    use super::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();

    // Section: dart2rust

    impl CstDecode<String> for String {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            self
        }
    }
    impl CstDecode<crate::api::error::BoltzError>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::error::BoltzError {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            crate::api::error::BoltzError {
                kind: self_.get(0).cst_decode(),
                message: self_.get(1).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::btc_ln::BtcLnSwap>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::btc_ln::BtcLnSwap {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                13,
                "Expected 13 elements, got {}",
                self_.length()
            );
            crate::api::btc_ln::BtcLnSwap {
                id: self_.get(0).cst_decode(),
                kind: self_.get(1).cst_decode(),
                network: self_.get(2).cst_decode(),
                keys: self_.get(3).cst_decode(),
                key_index: self_.get(4).cst_decode(),
                preimage: self_.get(5).cst_decode(),
                swap_script: self_.get(6).cst_decode(),
                invoice: self_.get(7).cst_decode(),
                script_address: self_.get(8).cst_decode(),
                out_amount: self_.get(9).cst_decode(),
                electrum_url: self_.get(10).cst_decode(),
                boltz_url: self_.get(11).cst_decode(),
                referral_id: self_.get(12).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::BtcSwapScriptStr>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::BtcSwapScriptStr {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                7,
                "Expected 7 elements, got {}",
                self_.length()
            );
            crate::api::types::BtcSwapScriptStr {
                swap_type: self_.get(0).cst_decode(),
                funding_addrs: self_.get(1).cst_decode(),
                hashlock: self_.get(2).cst_decode(),
                receiver_pubkey: self_.get(3).cst_decode(),
                locktime: self_.get(4).cst_decode(),
                sender_pubkey: self_.get(5).cst_decode(),
                side: self_.get(6).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::fees::ChainFeesAndLimits>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::fees::ChainFeesAndLimits {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                4,
                "Expected 4 elements, got {}",
                self_.length()
            );
            crate::api::fees::ChainFeesAndLimits {
                btc_limits: self_.get(0).cst_decode(),
                lbtc_limits: self_.get(1).cst_decode(),
                btc_fees: self_.get(2).cst_decode(),
                lbtc_fees: self_.get(3).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::chain_swap::ChainSwap>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::chain_swap::ChainSwap {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                17,
                "Expected 17 elements, got {}",
                self_.length()
            );
            crate::api::chain_swap::ChainSwap {
                id: self_.get(0).cst_decode(),
                is_testnet: self_.get(1).cst_decode(),
                direction: self_.get(2).cst_decode(),
                refund_keys: self_.get(3).cst_decode(),
                refund_index: self_.get(4).cst_decode(),
                claim_keys: self_.get(5).cst_decode(),
                claim_index: self_.get(6).cst_decode(),
                preimage: self_.get(7).cst_decode(),
                btc_script_str: self_.get(8).cst_decode(),
                lbtc_script_str: self_.get(9).cst_decode(),
                script_address: self_.get(10).cst_decode(),
                out_amount: self_.get(11).cst_decode(),
                btc_electrum_url: self_.get(12).cst_decode(),
                lbtc_electrum_url: self_.get(13).cst_decode(),
                boltz_url: self_.get(14).cst_decode(),
                referral_id: self_.get(15).cst_decode(),
                blinding_key: self_.get(16).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::fees::ChainSwapFees>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::fees::ChainSwapFees {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                4,
                "Expected 4 elements, got {}",
                self_.length()
            );
            crate::api::fees::ChainSwapFees {
                percentage: self_.get(0).cst_decode(),
                user_lockup: self_.get(1).cst_decode(),
                user_claim: self_.get(2).cst_decode(),
                server: self_.get(3).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::DecodedInvoice>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::DecodedInvoice {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                10,
                "Expected 10 elements, got {}",
                self_.length()
            );
            crate::api::types::DecodedInvoice {
                msats: self_.get(0).cst_decode(),
                expiry: self_.get(1).cst_decode(),
                expires_in: self_.get(2).cst_decode(),
                expires_at: self_.get(3).cst_decode(),
                is_expired: self_.get(4).cst_decode(),
                network: self_.get(5).cst_decode(),
                cltv_exp_delta: self_.get(6).cst_decode(),
                bip21: self_.get(7).cst_decode(),
                preimage_hash: self_.get(8).cst_decode(),
                description: self_.get(9).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::fees::Fees>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::fees::Fees {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                1,
                "Expected 1 elements, got {}",
                self_.length()
            );
            crate::api::fees::Fees {
                boltz_url: self_.get(0).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::KeyPair>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::KeyPair {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            crate::api::types::KeyPair {
                secret_key: self_.get(0).cst_decode(),
                public_key: self_.get(1).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::LBtcSwapScriptStr>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::LBtcSwapScriptStr {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                8,
                "Expected 8 elements, got {}",
                self_.length()
            );
            crate::api::types::LBtcSwapScriptStr {
                swap_type: self_.get(0).cst_decode(),
                funding_addrs: self_.get(1).cst_decode(),
                hashlock: self_.get(2).cst_decode(),
                receiver_pubkey: self_.get(3).cst_decode(),
                locktime: self_.get(4).cst_decode(),
                sender_pubkey: self_.get(5).cst_decode(),
                blinding_key: self_.get(6).cst_decode(),
                side: self_.get(7).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::lbtc_ln::LbtcLnSwap>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::lbtc_ln::LbtcLnSwap {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                14,
                "Expected 14 elements, got {}",
                self_.length()
            );
            crate::api::lbtc_ln::LbtcLnSwap {
                id: self_.get(0).cst_decode(),
                kind: self_.get(1).cst_decode(),
                network: self_.get(2).cst_decode(),
                keys: self_.get(3).cst_decode(),
                key_index: self_.get(4).cst_decode(),
                preimage: self_.get(5).cst_decode(),
                swap_script: self_.get(6).cst_decode(),
                invoice: self_.get(7).cst_decode(),
                out_amount: self_.get(8).cst_decode(),
                script_address: self_.get(9).cst_decode(),
                blinding_key: self_.get(10).cst_decode(),
                electrum_url: self_.get(11).cst_decode(),
                boltz_url: self_.get(12).cst_decode(),
                referral_id: self_.get(13).cst_decode(),
            }
        }
    }
    impl CstDecode<Vec<u8>> for Box<[u8]> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            self.into_vec()
        }
    }
    impl CstDecode<crate::api::fees::MinerFees>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::fees::MinerFees {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            crate::api::fees::MinerFees {
                lockup: self_.get(0).cst_decode(),
                claim: self_.get(1).cst_decode(),
            }
        }
    }
    impl CstDecode<Option<String>> for Option<String> {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Option<String> {
            self.map(CstDecode::cst_decode)
        }
    }
    impl CstDecode<crate::api::types::PreImage>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::PreImage {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                3,
                "Expected 3 elements, got {}",
                self_.length()
            );
            crate::api::types::PreImage {
                value: self_.get(0).cst_decode(),
                sha256: self_.get(1).cst_decode(),
                hash160: self_.get(2).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::fees::RevSwapFees>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::fees::RevSwapFees {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            crate::api::fees::RevSwapFees {
                percentage: self_.get(0).cst_decode(),
                miner_fees: self_.get(1).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::fees::ReverseFeesAndLimits>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::fees::ReverseFeesAndLimits {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                4,
                "Expected 4 elements, got {}",
                self_.length()
            );
            crate::api::fees::ReverseFeesAndLimits {
                btc_limits: self_.get(0).cst_decode(),
                lbtc_limits: self_.get(1).cst_decode(),
                btc_fees: self_.get(2).cst_decode(),
                lbtc_fees: self_.get(3).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::fees::SubSwapFees>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::fees::SubSwapFees {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            crate::api::fees::SubSwapFees {
                percentage: self_.get(0).cst_decode(),
                miner_fees: self_.get(1).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::fees::SubmarineFeesAndLimits>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::fees::SubmarineFeesAndLimits {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                4,
                "Expected 4 elements, got {}",
                self_.length()
            );
            crate::api::fees::SubmarineFeesAndLimits {
                btc_limits: self_.get(0).cst_decode(),
                lbtc_limits: self_.get(1).cst_decode(),
                btc_fees: self_.get(2).cst_decode(),
                lbtc_fees: self_.get(3).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::fees::SwapLimits>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::fees::SwapLimits {
            let self_ = self
                .dyn_into::<flutter_rust_bridge::for_generated::js_sys::Array>()
                .unwrap();
            assert_eq!(
                self_.length(),
                2,
                "Expected 2 elements, got {}",
                self_.length()
            );
            crate::api::fees::SwapLimits {
                minimal: self_.get(0).cst_decode(),
                maximal: self_.get(1).cst_decode(),
            }
        }
    }
    impl CstDecode<crate::api::types::TxFee>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::TxFee {
            let self_ = self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Array>();
            match self_.get(0).unchecked_into_f64() as _ {
                0 => crate::api::types::TxFee::Absolute(self_.get(1).cst_decode()),
                1 => crate::api::types::TxFee::Relative(self_.get(1).cst_decode()),
                _ => unreachable!(),
            }
        }
    }
    impl CstDecode<String> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> String {
            self.as_string().expect("non-UTF-8 string, or not a string")
        }
    }
    impl CstDecode<bool> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> bool {
            self.is_truthy()
        }
    }
    impl CstDecode<crate::api::types::Chain>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Chain {
            (self.unchecked_into_f64() as i32).cst_decode()
        }
    }
    impl CstDecode<crate::api::types::ChainSwapDirection>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::ChainSwapDirection {
            (self.unchecked_into_f64() as i32).cst_decode()
        }
    }
    impl CstDecode<f64> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> f64 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<i32> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> i32 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<Vec<u8>> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> Vec<u8> {
            self.unchecked_into::<flutter_rust_bridge::for_generated::js_sys::Uint8Array>()
                .to_vec()
                .into()
        }
    }
    impl CstDecode<crate::api::types::Side>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::Side {
            (self.unchecked_into_f64() as i32).cst_decode()
        }
    }
    impl CstDecode<crate::api::types::SwapTxKind>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::SwapTxKind {
            (self.unchecked_into_f64() as i32).cst_decode()
        }
    }
    impl CstDecode<crate::api::types::SwapType>
        for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue
    {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> crate::api::types::SwapType {
            (self.unchecked_into_f64() as i32).cst_decode()
        }
    }
    impl CstDecode<u32> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u32 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<u64> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u64 {
            ::std::convert::TryInto::<u64>::try_into(self).unwrap() as _
        }
    }
    impl CstDecode<u8> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> u8 {
            self.unchecked_into_f64() as _
        }
    }
    impl CstDecode<usize> for flutter_rust_bridge::for_generated::wasm_bindgen::JsValue {
        // Codec=Cst (C-struct based), see doc to use other codecs
        fn cst_decode(self) -> usize {
            ::std::convert::TryInto::<u64>::try_into(self).unwrap() as _
        }
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__error__boltz_error_detail(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__error__boltz_error_detail_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__error__boltz_error_new(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        kind: String,
        message: String,
    ) {
        wire__crate__api__error__boltz_error_new_impl(port_, kind, message)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__btc_ln__btc_ln_swap_broadcast_boltz(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        signed_hex: String,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_broadcast_boltz_impl(port_, that, signed_hex)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__btc_ln__btc_ln_swap_broadcast_local(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        signed_hex: String,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_broadcast_local_impl(port_, that, signed_hex)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__btc_ln__btc_ln_swap_claim(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        out_address: String,
        miner_fee: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        try_cooperate: bool,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_claim_impl(
            port_,
            that,
            out_address,
            miner_fee,
            try_cooperate,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__btc_ln__btc_ln_swap_coop_close_submarine(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_coop_close_submarine_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__btc_ln__btc_ln_swap_from_json(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        json_str: String,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_from_json_impl(port_, json_str)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__btc_ln__btc_ln_swap_get_completed_submarine_preimage(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_get_completed_submarine_preimage_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__btc_ln__btc_ln_swap_new(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        id: String,
        kind: i32,
        network: i32,
        keys: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        key_index: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        preimage: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        swap_script: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        invoice: String,
        script_address: String,
        out_amount: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        electrum_url: String,
        boltz_url: String,
        referral_id: Option<String>,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_new_impl(
            port_,
            id,
            kind,
            network,
            keys,
            key_index,
            preimage,
            swap_script,
            invoice,
            script_address,
            out_amount,
            electrum_url,
            boltz_url,
            referral_id,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__btc_ln__btc_ln_swap_new_reverse(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        mnemonic: String,
        passphrase: Option<String>,
        index: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        out_amount: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        out_address: Option<String>,
        network: i32,
        electrum_url: String,
        boltz_url: String,
        description: Option<String>,
        referral_id: Option<String>,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_new_reverse_impl(
            port_,
            mnemonic,
            passphrase,
            index,
            out_amount,
            out_address,
            network,
            electrum_url,
            boltz_url,
            description,
            referral_id,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__btc_ln__btc_ln_swap_new_submarine(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        mnemonic: String,
        passphrase: Option<String>,
        index: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        invoice: String,
        network: i32,
        electrum_url: String,
        boltz_url: String,
        referral_id: Option<String>,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_new_submarine_impl(
            port_,
            mnemonic,
            passphrase,
            index,
            invoice,
            network,
            electrum_url,
            boltz_url,
            referral_id,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__btc_ln__btc_ln_swap_refund(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        out_address: String,
        miner_fee: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        try_cooperate: bool,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_refund_impl(
            port_,
            that,
            out_address,
            miner_fee,
            try_cooperate,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__btc_ln__btc_ln_swap_to_json(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_to_json_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__btc_ln__btc_ln_swap_tx_size(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        is_cooperative: bool,
    ) {
        wire__crate__api__btc_ln__btc_ln_swap_tx_size_impl(port_, that, is_cooperative)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__types__btc_swap_script_str_new(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        swap_type: i32,
        funding_addrs: Option<String>,
        hashlock: String,
        receiver_pubkey: String,
        locktime: u32,
        sender_pubkey: String,
        side: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__types__btc_swap_script_str_new_impl(
            port_,
            swap_type,
            funding_addrs,
            hashlock,
            receiver_pubkey,
            locktime,
            sender_pubkey,
            side,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__chain_swap__chain_swap_broadcast_boltz(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        signed_hex: String,
        kind: i32,
    ) {
        wire__crate__api__chain_swap__chain_swap_broadcast_boltz_impl(port_, that, signed_hex, kind)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__chain_swap__chain_swap_broadcast_local(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        signed_hex: String,
        kind: i32,
    ) {
        wire__crate__api__chain_swap__chain_swap_broadcast_local_impl(port_, that, signed_hex, kind)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__chain_swap__chain_swap_claim(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        out_address: String,
        refund_address: String,
        miner_fee: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        try_cooperate: bool,
    ) {
        wire__crate__api__chain_swap__chain_swap_claim_impl(
            port_,
            that,
            out_address,
            refund_address,
            miner_fee,
            try_cooperate,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__chain_swap__chain_swap_from_json(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        json_str: String,
    ) {
        wire__crate__api__chain_swap__chain_swap_from_json_impl(port_, json_str)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__chain_swap__chain_swap_get_server_lockup(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__chain_swap__chain_swap_get_server_lockup_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__chain_swap__chain_swap_get_user_lockup(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__chain_swap__chain_swap_get_user_lockup_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__chain_swap__chain_swap_new(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        id: String,
        is_testnet: bool,
        direction: i32,
        refund_keys: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        refund_index: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        claim_keys: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        claim_index: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        preimage: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        btc_script_str: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        lbtc_script_str: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        script_address: String,
        out_amount: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        btc_electrum_url: String,
        lbtc_electrum_url: String,
        boltz_url: String,
        referral_id: Option<String>,
        blinding_key: String,
    ) {
        wire__crate__api__chain_swap__chain_swap_new_impl(
            port_,
            id,
            is_testnet,
            direction,
            refund_keys,
            refund_index,
            claim_keys,
            claim_index,
            preimage,
            btc_script_str,
            lbtc_script_str,
            script_address,
            out_amount,
            btc_electrum_url,
            lbtc_electrum_url,
            boltz_url,
            referral_id,
            blinding_key,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__chain_swap__chain_swap_new_swap(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        direction: i32,
        mnemonic: String,
        passphrase: Option<String>,
        index: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        amount: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        is_testnet: bool,
        btc_electrum_url: String,
        lbtc_electrum_url: String,
        boltz_url: String,
        referral_id: Option<String>,
    ) {
        wire__crate__api__chain_swap__chain_swap_new_swap_impl(
            port_,
            direction,
            mnemonic,
            passphrase,
            index,
            amount,
            is_testnet,
            btc_electrum_url,
            lbtc_electrum_url,
            boltz_url,
            referral_id,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__chain_swap__chain_swap_refund(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        refund_address: String,
        miner_fee: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        try_cooperate: bool,
    ) {
        wire__crate__api__chain_swap__chain_swap_refund_impl(
            port_,
            that,
            refund_address,
            miner_fee,
            try_cooperate,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__chain_swap__chain_swap_to_json(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__chain_swap__chain_swap_to_json_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__types__decoded_invoice_from_string(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        s: String,
        boltz_url: Option<String>,
    ) {
        wire__crate__api__types__decoded_invoice_from_string_impl(port_, s, boltz_url)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__fees__fees_chain(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__fees__fees_chain_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__fees__fees_new(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        boltz_url: String,
    ) {
        wire__crate__api__fees__fees_new_impl(port_, boltz_url)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__fees__fees_reverse(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__fees__fees_reverse_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__fees__fees_submarine(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__fees__fees_submarine_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__types__get_voucher_max_amount(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        lnurl: String,
    ) {
        wire__crate__api__types__get_voucher_max_amount_impl(port_, lnurl)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__types__invoice_from_lnurl(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        lnurl: String,
        msats: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__types__invoice_from_lnurl_impl(port_, lnurl, msats)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__types__key_pair_generate(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        mnemonic: String,
        passphrase: Option<String>,
        network: i32,
        index: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        swap_type: i32,
    ) {
        wire__crate__api__types__key_pair_generate_impl(
            port_, mnemonic, passphrase, network, index, swap_type,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__types__key_pair_new(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        secret_key: String,
        public_key: String,
    ) {
        wire__crate__api__types__key_pair_new_impl(port_, secret_key, public_key)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__types__l_btc_swap_script_str_new(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        swap_type: i32,
        funding_addrs: Option<String>,
        hashlock: String,
        receiver_pubkey: String,
        locktime: u32,
        sender_pubkey: String,
        blinding_key: String,
        side: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__types__l_btc_swap_script_str_new_impl(
            port_,
            swap_type,
            funding_addrs,
            hashlock,
            receiver_pubkey,
            locktime,
            sender_pubkey,
            blinding_key,
            side,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__lbtc_ln__lbtc_ln_swap_broadcast_boltz(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        signed_hex: String,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_broadcast_boltz_impl(port_, that, signed_hex)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__lbtc_ln__lbtc_ln_swap_broadcast_local(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        signed_hex: String,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_broadcast_local_impl(port_, that, signed_hex)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__lbtc_ln__lbtc_ln_swap_claim(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        out_address: String,
        miner_fee: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        try_cooperate: bool,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_claim_impl(
            port_,
            that,
            out_address,
            miner_fee,
            try_cooperate,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__lbtc_ln__lbtc_ln_swap_coop_close_submarine(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_coop_close_submarine_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__lbtc_ln__lbtc_ln_swap_from_json(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        json_str: String,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_from_json_impl(port_, json_str)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__lbtc_ln__lbtc_ln_swap_get_completed_submarine_preimage(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_get_completed_submarine_preimage_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__lbtc_ln__lbtc_ln_swap_new(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        id: String,
        kind: i32,
        network: i32,
        keys: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        key_index: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        preimage: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        swap_script: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        invoice: String,
        out_amount: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        out_address: String,
        blinding_key: String,
        electrum_url: String,
        boltz_url: String,
        referral_id: Option<String>,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_new_impl(
            port_,
            id,
            kind,
            network,
            keys,
            key_index,
            preimage,
            swap_script,
            invoice,
            out_amount,
            out_address,
            blinding_key,
            electrum_url,
            boltz_url,
            referral_id,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__lbtc_ln__lbtc_ln_swap_new_reverse(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        mnemonic: String,
        passphrase: Option<String>,
        index: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        out_amount: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        out_address: Option<String>,
        network: i32,
        electrum_url: String,
        boltz_url: String,
        description: Option<String>,
        referral_id: Option<String>,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_new_reverse_impl(
            port_,
            mnemonic,
            passphrase,
            index,
            out_amount,
            out_address,
            network,
            electrum_url,
            boltz_url,
            description,
            referral_id,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__lbtc_ln__lbtc_ln_swap_new_submarine(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        mnemonic: String,
        passphrase: Option<String>,
        index: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        invoice: String,
        network: i32,
        electrum_url: String,
        boltz_url: String,
        referral_id: Option<String>,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_new_submarine_impl(
            port_,
            mnemonic,
            passphrase,
            index,
            invoice,
            network,
            electrum_url,
            boltz_url,
            referral_id,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__lbtc_ln__lbtc_ln_swap_refund(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        out_address: String,
        miner_fee: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        try_cooperate: bool,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_refund_impl(
            port_,
            that,
            out_address,
            miner_fee,
            try_cooperate,
        )
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__lbtc_ln__lbtc_ln_swap_to_json(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_to_json_impl(port_, that)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__lbtc_ln__lbtc_ln_swap_tx_size(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        that: flutter_rust_bridge::for_generated::wasm_bindgen::JsValue,
        is_cooperative: bool,
    ) {
        wire__crate__api__lbtc_ln__lbtc_ln_swap_tx_size_impl(port_, that, is_cooperative)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__types__pre_image_generate(
        port_: flutter_rust_bridge::for_generated::MessagePort,
    ) {
        wire__crate__api__types__pre_image_generate_impl(port_)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__types__pre_image_new(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        value: String,
        sha256: String,
        hash160: String,
    ) {
        wire__crate__api__types__pre_image_new_impl(port_, value, sha256, hash160)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__types__validate_lnurl(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        lnurl: String,
    ) {
        wire__crate__api__types__validate_lnurl_impl(port_, lnurl)
    }

    #[wasm_bindgen]
    pub fn wire__crate__api__types__withdraw(
        port_: flutter_rust_bridge::for_generated::MessagePort,
        lnurl: String,
        invoice: String,
    ) {
        wire__crate__api__types__withdraw_impl(port_, lnurl, invoice)
    }
}
#[cfg(target_family = "wasm")]
pub use web::*;
